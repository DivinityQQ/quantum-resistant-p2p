{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Quantum Resistant P2P Documentation","text":"<p>Welcome to the documentation for the Quantum Resistant P2P application.</p>"},{"location":"#overview","title":"Overview","text":"<p>This application provides a secure peer-to-peer communication platform using post-quantum cryptographic algorithms to ensure security against quantum computer attacks.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Post-Quantum Security: Uses algorithms resistant to quantum computing attacks</li> <li>Secure Messaging: End-to-end encrypted messaging</li> <li>File Transfer: Securely transfer files between peers</li> <li>Key Management: Advanced key management with automatic rotation</li> <li>User-Friendly Interface: Easy to use Qt-based interface</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>See the User Guide for installation and usage instructions</li> <li>Review the Architecture for a high-level overview of the system</li> <li>Browse the API Reference for detailed documentation of the codebase</li> </ul>"},{"location":"#license","title":"License","text":"<p>quantum-resistant-p2p is licensed under the MIT License; see LICENSE for details.</p>"},{"location":"#credits","title":"Credits","text":"<p>This project uses the Open Quantum Safe (OQS) library for post-quantum cryptography.</p>"},{"location":"architecture/","title":"Quantum-Resistant P2P Architecture Overview","text":""},{"location":"architecture/#1-system-architecture","title":"1. System Architecture","text":"<p>The Quantum-Resistant P2P application is designed as a secure peer-to-peer communication platform that uses post-quantum cryptographic algorithms to ensure forward security. The system consists of several key components organized in a layered architecture:</p> <p></p>"},{"location":"architecture/#11-core-components","title":"1.1 Core Components","text":""},{"location":"architecture/#111-networking-layer","title":"1.1.1 Networking Layer","text":"<ul> <li>P2PNode: Handles direct peer-to-peer connections, message passing, and connection management</li> <li>NodeDiscovery: Provides mechanisms for discovering other peers on the network via broadcast and direct announcements</li> </ul>"},{"location":"architecture/#112-cryptography-layer","title":"1.1.2 Cryptography Layer","text":"<ul> <li>Key Exchange: Implements post-quantum key exchange algorithms (ML-KEM, HQC, FrodoKEM)</li> <li>Symmetric Encryption: Provides authenticated encryption with associated data (AES-256-GCM, ChaCha20Poly1305)</li> <li>Digital Signatures: Implements post-quantum signature schemes (ML-DSA, SPHINCS+)</li> <li>KeyStorage: Securely stores cryptographic keys using password-based encryption with Argon2id</li> </ul>"},{"location":"architecture/#113-application-layer","title":"1.1.3 Application Layer","text":"<ul> <li>SecureMessaging: Coordinates cryptographic operations for secure communication</li> <li>SecureLogger: Provides encrypted, tamper-evident logging of security events</li> <li>MessageStore: Stores and manages conversation history with unread message tracking</li> </ul>"},{"location":"architecture/#114-user-interface-layer","title":"1.1.4 User Interface Layer","text":"<ul> <li>MainWindow: Primary application window with menu and status bar</li> <li>MessagingWidget: UI for message conversations and file transfers</li> <li>PeerListWidget: UI for displaying and interacting with peers</li> <li>Settings Dialogs: Various dialogs for configuring cryptographic settings</li> <li>Security Dialogs: Key history viewer, log viewer, security metrics dialogs</li> </ul>"},{"location":"architecture/#12-component-interactions","title":"1.2 Component Interactions","text":"<p>The application follows a modular design where components interact through well-defined interfaces:</p> <ol> <li>The P2PNode provides the networking foundation, with higher-level components like SecureMessaging built on top</li> <li>The cryptographic algorithms are abstracted through base classes, allowing easy algorithm switching</li> <li>The UI components interact with the application logic through signal/slot connections and async tasks</li> </ol>"},{"location":"architecture/#2-data-flow","title":"2. Data Flow","text":""},{"location":"architecture/#21-peer-discovery-process","title":"2.1 Peer Discovery Process","text":"<pre><code>sequenceDiagram\n    participant Node A\n    participant Network\n    participant Node B\n\n    Node A-&gt;&gt;Network: Broadcast Announcement\n    Network-&gt;&gt;Node B: Forward Announcement\n    Node B-&gt;&gt;Node B: Record Node A\n    Node B-&gt;&gt;Node A: Direct Connection\n    Node A-&gt;&gt;Node B: Share Crypto Settings\n    Node B-&gt;&gt;Node A: Share Crypto Settings\n    Note over Node A,Node B: Compatibility Check</code></pre>"},{"location":"architecture/#22-secure-message-exchange","title":"2.2 Secure Message Exchange","text":"<pre><code>sequenceDiagram\n    participant Alice\n    participant Bob\n\n    Alice-&gt;&gt;Bob: Key Exchange Initiation\n    Note over Bob: Verify signature &amp; Compatibility\n    Bob-&gt;&gt;Alice: Key Exchange Response\n    Alice-&gt;&gt;Bob: Key Exchange Confirmation\n    Alice-&gt;&gt;Bob: Key Exchange Test Message\n    Note over Alice,Bob: Secure Channel Established\n\n    Note over Alice: 1. Create message object\n    Note over Alice: 2. Sign message with ML-DSA/SPHINCS+\n    Note over Alice: 3. Create signed package with signature\n    Note over Alice: 4. Prepare AEAD associated data\n    Note over Alice: 5. Encrypt signed package with AES-GCM/ChaCha20\n    Alice-&gt;&gt;Bob: Send encrypted package with associated data\n\n    Note over Bob: 1. Extract associated data and ciphertext\n    Note over Bob: 2. Verify associated data authenticity\n    Note over Bob: 3. Decrypt ciphertext with shared key\n    Note over Bob: 4. Verify message signature\n    Note over Bob: 5. Process decrypted &amp; verified message\n\n    Bob-&gt;&gt;Alice: Encrypted &amp; Signed Response (same process)</code></pre>"},{"location":"architecture/#3-security-architecture","title":"3. Security Architecture","text":""},{"location":"architecture/#31-post-quantum-security","title":"3.1 Post-Quantum Security","text":"<p>The application implements several post-quantum algorithms to protect against future quantum computing threats:</p> <ul> <li>Lattice-based: ML-KEM (formerly Kyber) and ML-DSA (formerly Dilithium)</li> <li>Code-based: HQC key encapsulation</li> <li>Hash-based: SPHINCS+ signatures</li> <li>Standard LWE: FrodoKEM</li> </ul> <p>These are complemented by classical strong symmetric encryption:</p> <ul> <li>AES-256-GCM with AEAD</li> <li>ChaCha20-Poly1305 with AEAD</li> </ul>"},{"location":"architecture/#32-cryptographic-protocol","title":"3.2 Cryptographic Protocol","text":"<p>The secure communication protocol follows these steps:</p> <ol> <li>Key Exchange: Establish a shared secret using a post-quantum KEM with ephemeral keypairs</li> <li>Key Derivation: Use HKDF to derive symmetric keys from the shared secret</li> <li>Message Protection: Implement sign-then-encrypt approach:</li> <li>Create the message with content and metadata</li> <li>Sign the message JSON with sender's private key</li> <li>Create a signed package with message, signature, and public key</li> <li>Create associated data with critical metadata (message ID, sender/recipient IDs, timestamp)</li> <li>Encrypt the signed package using AEAD with the associated data</li> <li>Message Verification:</li> <li>Verify the associated data integrity</li> <li>Decrypt the ciphertext using the shared key</li> <li>Verify the signature of the decrypted message</li> <li>Process the verified message</li> </ol>"},{"location":"architecture/#33-key-management","title":"3.3 Key Management","text":"<ul> <li>Ephemeral Keys: Fresh keypairs generated for each key exchange for forward secrecy</li> <li>Key Storage: All keys are stored in encrypted form using Argon2id for password-based key derivation</li> <li>Key Rotation: The application supports re-establishing keys when cryptographic settings change</li> <li>Key History: Secure view of past key exchanges with on-demand decryption</li> <li>Secure Deletion: Secure cleanup of sensitive material from memory</li> </ul>"},{"location":"architecture/#34-algorithm-parameter-specifics","title":"3.4 Algorithm Parameter Specifics","text":"<p>The application provides different security levels for each post-quantum algorithm:</p> Algorithm NIST Level Variant Security Against Classical &amp; Quantum Attackers ML-KEM 1 ML-KEM-512 ~128 bits ML-KEM 3 ML-KEM-768 ~192 bits ML-KEM 5 ML-KEM-1024 ~256 bits HQC 1 HQC-128 ~128 bits HQC 3 HQC-192 ~192 bits HQC 5 HQC-256 ~256 bits FrodoKEM 1 FrodoKEM-640-(AES/SHAKE) ~128 bits FrodoKEM 3 FrodoKEM-976-(AES/SHAKE) ~192 bits FrodoKEM 5 FrodoKEM-1344-(AES/SHAKE) ~256 bits ML-DSA 2 ML-DSA-44 ~128 bits ML-DSA 3 ML-DSA-65 ~192 bits ML-DSA 5 ML-DSA-87 ~256 bits SPHINCS+ 1 SPHINCS+-SHA2-128f-simple ~128 bits SPHINCS+ 3 SPHINCS+-SHA2-192f-simple ~192 bits SPHINCS+ 5 SPHINCS+-SHA2-256f-simple ~256 bits <p>Note on Symmetric Algorithms: - AES-256-GCM: 256-bit keys (providing ~128-bit security against quantum attacks via Grover's algorithm) - ChaCha20-Poly1305: 256-bit keys (providing ~128-bit security against quantum attacks via Grover's algorithm)</p>"},{"location":"architecture/#35-secure-random-number-generation","title":"3.5 Secure Random Number Generation","text":"<p>The application uses cryptographically secure random number generation for all security-critical operations:</p> <ol> <li>System-Level RNG: Uses <code>os.urandom()</code> which directly accesses the OS entropy source (/dev/urandom on Unix, CryptGenRandom on Windows)</li> <li>Nonce Generation: 12-byte (96-bit) random nonces for all AEAD operations</li> <li>Salt Generation: 16-byte (128-bit) random salts for key derivation</li> <li>Algorithm-Specific RNG: The liboqs library uses its own secure RNG for post-quantum operations</li> <li>Unique Identifiers: UUID v4 generation for message IDs using Python's cryptographically secure <code>uuid.uuid4()</code></li> </ol>"},{"location":"architecture/#36-forward-secrecy-guarantees","title":"3.6 Forward Secrecy Guarantees","text":"<p>The application implements forward secrecy through several mechanisms:</p> <ol> <li>Ephemeral Keypairs: Fresh keypairs are generated for each key exchange session</li> <li>Key Lifecycle Management:</li> <li>Private keys are deleted immediately after use in key exchange</li> <li>Keys are stored only in memory during active sessions</li> <li>Private key material is explicitly overwritten in memory when no longer needed</li> <li>Session Independence: Each connection uses completely independent keying material</li> <li>Compromise Containment: If a session key is compromised, it does not affect the security of past or future communications</li> <li>Re-keying on Settings Change: When cryptographic settings change, all session keys are regenerated</li> </ol>"},{"location":"architecture/#4-network-protocol","title":"4. Network Protocol","text":""},{"location":"architecture/#41-message-types","title":"4.1 Message Types","text":"<p>The P2P network protocol defines several message types:</p> Message Type Purpose hello Initial connection establishment hello_response Response to hello message key_exchange_init Begin key exchange process key_exchange_response Response with encapsulated key key_exchange_confirm Confirmation of successful key establishment key_exchange_test Test message to verify secure channel key_exchange_rejected Notification of key exchange rejection with reason secure_message Encrypted and signed message content crypto_settings_update Inform peer about cryptographic algorithm changes crypto_settings_request Request peer's cryptographic settings"},{"location":"architecture/#42-message-security-model","title":"4.2 Message Security Model","text":"<p>The application implements a layered security approach for each message:</p> <pre><code>flowchart TD\n    A[\"Original Message (plaintext or file content)\"]\n    B[\"Digital Signature Layer\n        (Ensures authenticity and integrity)\"]\n    C[\"Symmetric Encryption Layer with AEAD\n        (Ensures confidentiality and tamper detection)\"]\n    D[\"Associated Authenticated Data\n        (Ensures metadata integrity)\"]\n\n    A --&gt; B --&gt; C --&gt; D</code></pre>"},{"location":"architecture/#43-aead-implementation","title":"4.3 AEAD Implementation","text":"<p>The application uses Authenticated Encryption with Associated Data (AEAD) for message protection:</p> <ol> <li>Confidentiality: The message content is encrypted to protect it from unauthorized readers</li> <li>Authentication: The ciphertext includes an authentication tag to detect tampering</li> <li>Associated Data: Critical metadata is bound to the ciphertext but not encrypted</li> <li>Benefits:</li> <li>Metadata can be used for routing without decryption</li> <li>Changes to either ciphertext or associated data will cause authentication to fail</li> <li>Protection against replay attacks by including message IDs and timestamps</li> </ol> <p>This is implemented using: - AES-256-GCM: Uses a 12-byte random nonce and GCM mode for AEAD - ChaCha20-Poly1305: Uses a 12-byte random nonce and Poly1305 for authentication</p>"},{"location":"architecture/#44-large-message-handling","title":"4.4 Large Message Handling","text":"<p>For large messages (like file transfers), the application uses a chunking mechanism:</p> <ol> <li>The sender splits the message into chunks of configurable size (default 64KB)</li> <li>Header includes:</li> <li>Flags byte indicating chunking</li> <li>UUID for message identification</li> <li>Total chunks count and size</li> <li>Individual chunk index and size</li> <li>The receiver reassembles the chunks into the complete message</li> <li>Error handling for incomplete transmissions</li> </ol>"},{"location":"architecture/#45-peer-identity-verification","title":"4.5 Peer Identity Verification","text":"<p>The application implements a multi-layered approach to peer identity verification:</p> <ol> <li>Persistent Node Identifiers: Each node has a unique ID persisted across sessions</li> <li>Signed Key Exchange: All key exchange messages are signed using post-quantum signatures</li> <li>Identity Binding: The key exchange protocol explicitly binds:</li> <li>Sender and recipient IDs</li> <li>Timestamps to prevent replay attacks</li> <li>Message IDs for uniqueness verification</li> <li>Verification Checks:</li> <li>Sender/recipient ID validation on every message</li> <li>Signature verification on all key material</li> <li>Timestamp validation (5-minute window) to prevent replays</li> <li>Visual Verification: The UI displays truncated peer IDs (first 8 characters) for visual verification</li> <li>Connection Metadata: Peers share algorithm preferences which must remain consistent during a session</li> </ol> <p>This implementation does not provide full protection against man-in-the-middle attacks on initial connection without additional out-of-band verification.</p>"},{"location":"architecture/#5-secure-storage-architecture","title":"5. Secure Storage Architecture","text":"<p>The secure storage layer provides comprehensive protection for sensitive data at rest through several integrated components:</p>"},{"location":"architecture/#51-keystorage","title":"5.1 KeyStorage","text":"<p>Provides encrypted storage for cryptographic keys with strong security properties:</p> <ul> <li>Password-Based Encryption: Uses Argon2id key derivation (100MB memory, parallelism 4) for master key generation</li> <li>Complete Encryption: All keys and metadata are encrypted, with no plaintext information in stored files</li> <li>Key Hierarchy: Derives purpose-specific keys from the master key for domain separation</li> <li>Metadata Protection: Uses HMAC-based key identifiers to prevent information leakage</li> <li>Emergency Recovery: Supports password reset with secure data erasure when needed</li> </ul>"},{"location":"architecture/#52-securelogger","title":"5.2 SecureLogger","text":"<p>Implements encrypted, tamper-evident logging for security events:</p> <ul> <li>Encrypted Log Entries: Each log entry is individually encrypted and authenticated</li> <li>Corruption Recovery: Self-healing mechanisms to recover from partially corrupted log files</li> <li>Structured Organization: Daily log rotation with separate encryption per file</li> <li>Security Metrics: Aggregates usage patterns and security-relevant statistics</li> </ul>"},{"location":"architecture/#53-securefile","title":"5.3 SecureFile","text":"<p>Provides robust, corruption-resistant file operations:</p> <ul> <li>Atomic Updates: Ensures files are either completely updated or unchanged</li> <li>Concurrency Control: Two-level locking for multi-process/thread safety</li> <li>Automatic Backups: Creates backups of critical files before modification</li> <li>Cross-Platform: Adapts to platform-specific filesystem behaviors</li> </ul>"},{"location":"architecture/#54-secure-data-flow","title":"5.4 Secure Data Flow","text":"<p>The secure storage components work together to protect sensitive data throughout its lifecycle:</p> <ol> <li>Authentication: User password unlocks the KeyStorage via Argon2id KDF</li> <li>Key Protection: All cryptographic keys are protected under the master key</li> <li>Secure Logging: Security events are encrypted and logged with tamper protection</li> <li>Message Persistence: Messages are stored with sender verification and unread tracking</li> <li>Safe Operations: All file operations use atomic updates with backup creation</li> </ol>"},{"location":"architecture/#6-extensibility","title":"6. Extensibility","text":"<p>The architecture is designed for extensibility:</p> <ul> <li>Algorithm Abstraction: New cryptographic algorithms can be added by implementing the abstract base classes</li> <li>Protocol Extensions: The messaging protocol can be extended with new message types</li> <li>UI Customization: The modular UI design allows for components to be replaced or enhanced</li> <li>Crypto Settings Adoption: Peers can adopt compatible settings from each other</li> </ul>"},{"location":"architecture/#7-security-auditing","title":"7. Security Auditing","text":"<p>The system includes comprehensive security logging and metrics:</p> <ul> <li>SecureLogger: Encrypts all security events with tamper detection</li> <li>Event Tracking: Records key exchanges, message transfers, and security settings changes</li> <li>Security Metrics: Tracks algorithm usage, connection statistics, and security levels</li> <li>Corruption Protection: Log files have recovery mechanisms for corruption resistance</li> </ul>"},{"location":"architecture/#8-password-management","title":"8. Password Management","text":"<p>The application includes robust password management features:</p> <ul> <li>Secure Login: Password-based unlocking of the key storage using Argon2id KDF</li> <li>Password Change: Ability to change the storage password</li> <li>Password Reset: Emergency reset capability with complete data erasure</li> <li>Security Strength: Password quality recommendations</li> </ul>"},{"location":"architecture/#9-deployment-architecture","title":"9. Deployment Architecture","text":"<p>The application is designed as a standalone desktop application that can operate in various network environments:</p> <ul> <li>Local Networks: Direct peer connections on LANs</li> <li>Internet: Direct connections over the internet (may require port forwarding)</li> <li>Mixed Environments: Discovery works on local networks while direct connections can span networks</li> </ul> <p>No central servers are required for operation, maintaining the true peer-to-peer nature of the system.</p>"},{"location":"dev-guide/","title":"Development Guide","text":""},{"location":"dev-guide/#project-structure","title":"Project Structure","text":"<pre><code>quantum_resistant_p2p/\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 messaging.py\n\u2502   \u2514\u2500\u2500 logging.py\n\u251c\u2500\u2500 crypto/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 key_exchange.py\n\u2502   \u251c\u2500\u2500 signatures.py\n\u2502   \u251c\u2500\u2500 symmetric.py\n\u2502   \u2514\u2500\u2500 key_storage.py\n\u251c\u2500\u2500 networking/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 p2p_node.py\n\u2502   \u2514\u2500\u2500 discovery.py\n\u251c\u2500\u2500 ui/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 main_window.py\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 utils/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 secure_file.py\n\u2514\u2500\u2500 __init__.py\n</code></pre>"},{"location":"dev-guide/#development-setup","title":"Development Setup","text":"<p>If you want to contribute to the project:</p> <ol> <li>Fork the repository</li> <li>Clone your fork locally:    <pre><code>git clone https://github.com/YOUR_USERNAME/quantum-resistant-p2p.git\ncd quantum-resistant-p2p\n</code></pre></li> <li>Create and activate a virtual environment within the project directory:     <pre><code>python -m venv venv\n# On Windows:\nvenv\\Scripts\\activate\n# On macOS/Linux:\nsource venv/bin/activate\n</code></pre></li> <li>Install the package in development mode:     <pre><code>pip install -e .\n</code></pre></li> <li>Make your changes</li> <li>Submit a pull request</li> </ol>"},{"location":"dev-guide/#coding-guidelines","title":"Coding Guidelines","text":"<ul> <li>Follow PEP 8 style guidelines</li> <li>Use Google-style docstrings</li> <li>Include type hints for all functions and methods</li> <li>Write unit tests for all new functionality</li> </ul>"},{"location":"dokumentace-final/","title":"Dokumentace projektu Quantum-Resistant P2P","text":""},{"location":"dokumentace-final/#uvod-s-popsanou-problematikou","title":"\u00davod s popsanou problematikou","text":"<p>S p\u0159\u00edchodem kvantov\u00fdch po\u010d\u00edta\u010d\u016f bude mnoho sou\u010dasn\u00fdch kryptografick\u00fdch algoritm\u016f, jako jsou RSA a ECC (Elliptic Curve Cryptography), pova\u017eov\u00e1no za nezabezpe\u010den\u00e9. Kvantov\u00e9 po\u010d\u00edta\u010de mohou teoreticky prolomit tyto algoritmy v polynomi\u00e1ln\u00edm \u010dase pomoc\u00ed Shorova algoritmu, co\u017e p\u0159edstavuje z\u00e1va\u017enou hrozbu pro sou\u010dasnou digit\u00e1ln\u00ed bezpe\u010dnost.</p> <p>Projekt Quantum-Resistant P2P \u0159e\u0161\u00ed tento probl\u00e9m implementac\u00ed post-kvantov\u00fdch kryptografick\u00fdch algoritm\u016f pro zabezpe\u010denou peer-to-peer komunikaci. Aplikace pou\u017e\u00edv\u00e1 modern\u00ed kvantov\u011b odoln\u00e9 algoritmy schv\u00e1len\u00e9 organizac\u00ed NIST (National Institute of Standards and Technology), v\u010detn\u011b:</p> <ul> <li>ML-KEM (d\u0159\u00edve Kyber) - pro bezpe\u010dnou v\u00fdm\u011bnu kl\u00ed\u010d\u016f</li> <li>ML-DSA (d\u0159\u00edve Dilithium) - pro digit\u00e1ln\u00ed podpisy</li> <li>SPHINCS+ - jako alternativn\u00ed algoritmus pro digit\u00e1ln\u00ed podpisy zalo\u017een\u00fd na ha\u0161ovac\u00edch funkc\u00edch</li> </ul> <p>Tyto algoritmy jsou navr\u017eeny tak, aby odolaly \u00fatok\u016fm kvantov\u00fdch po\u010d\u00edta\u010d\u016f, zat\u00edmco nab\u00edzej\u00ed podobn\u00e9 nebo lep\u0161\u00ed bezpe\u010dnostn\u00ed vlastnosti ne\u017e sou\u010dasn\u00e9 standardy. Aplikace umo\u017e\u0148uje u\u017eivatel\u016fm komunikovat pomoc\u00ed textov\u00fdch zpr\u00e1v a sd\u00edlet soubory s end-to-end \u0161ifrov\u00e1n\u00edm, kter\u00e9 je zabezpe\u010deno proti sou\u010dasn\u00fdm i budouc\u00edm kvantov\u00fdm hrozb\u00e1m.</p>"},{"location":"dokumentace-final/#vyvojovy-diagram-programu-s-popisem-funkcnosti","title":"V\u00fdvojov\u00fd diagram programu s popisem funk\u010dnosti","text":"<p>Aplikace je postavena na modelu vrstev, kde ka\u017ed\u00e1 vrstva poskytuje specifickou funk\u010dnost a komunikuje s ostatn\u00edmi vrstvami prost\u0159ednictv\u00edm definovan\u00fdch rozhran\u00ed:</p> <p> Aplikace se skl\u00e1d\u00e1 z n\u00e1sleduj\u00edc\u00edch kl\u00ed\u010dov\u00fdch komponent organizovan\u00fdch ve vrstv\u00e1ch:</p>"},{"location":"dokumentace-final/#11-sitova-vrstva","title":"1.1 S\u00ed\u0165ov\u00e1 vrstva","text":"<ul> <li>P2PNode: Zpracov\u00e1v\u00e1 p\u0159\u00edm\u00e9 peer-to-peer spojen\u00ed, p\u0159enos zpr\u00e1v a spr\u00e1vu p\u0159ipojen\u00ed</li> <li>NodeDiscovery: Poskytuje mechanismy pro objevov\u00e1n\u00ed dal\u0161\u00edch peer\u016f v s\u00edti</li> </ul>"},{"location":"dokumentace-final/#12-kryptograficka-vrstva","title":"1.2 Kryptografick\u00e1 vrstva","text":"<ul> <li>Key Exchange: Implementuje post-kvantov\u00e9 algoritmy v\u00fdm\u011bny kl\u00ed\u010d\u016f</li> <li>Symmetric Encryption: Poskytuje autentizovan\u00e9 \u0161ifrov\u00e1n\u00ed</li> <li>Digital Signatures: Implementuje post-kvantov\u00e1 sch\u00e9mata podpis\u016f</li> <li>KeyStorage: Bezpe\u010dn\u011b ukl\u00e1d\u00e1 kryptografick\u00e9 kl\u00ed\u010de</li> </ul>"},{"location":"dokumentace-final/#13-aplikacni-vrstva","title":"1.3 Aplika\u010dn\u00ed vrstva","text":"<ul> <li>SecureMessaging: Koordinuje kryptografick\u00e9 operace pro bezpe\u010dnou komunikaci</li> <li>SecureLogger: Poskytuje \u0161ifrovan\u00e9 protokolov\u00e1n\u00ed ud\u00e1lost\u00ed</li> <li>MessageStore: Ukl\u00e1d\u00e1 a spravuje historii konverzac\u00ed</li> </ul>"},{"location":"dokumentace-final/#14-uzivatelske-rozhrani","title":"1.4 U\u017eivatelsk\u00e9 rozhran\u00ed","text":"<ul> <li>MainWindow: Hlavn\u00ed okno aplikace s menu a stavov\u00fdm \u0159\u00e1dkem</li> <li>MessagingWidget: UI pro konverzace a p\u0159enos soubor\u016f</li> <li>PeerListWidget: UI pro zobrazov\u00e1n\u00ed a interakci s peery</li> <li>Settings Dialogs: Dialogy pro konfiguraci kryptografick\u00fdch nastaven\u00ed</li> <li>Security Dialogs: Prohl\u00ed\u017ee\u010d historie kl\u00ed\u010d\u016f, protokol\u016f a metrik zabezpe\u010den\u00ed</li> </ul>"},{"location":"dokumentace-final/#popis-toku-dat-v-aplikaci","title":"Popis toku dat v aplikaci:","text":"<ol> <li>Inicializace a p\u0159ihl\u00e1\u0161en\u00ed:</li> <li>Aplikace za\u010d\u00edn\u00e1 v <code>__main__.py</code>, kde se inicializuje <code>MainWindow</code></li> <li>U\u017eivatel je vyzv\u00e1n k zad\u00e1n\u00ed hesla p\u0159es <code>LoginDialog</code></li> <li> <p>Heslo odemyk\u00e1 <code>KeyStorage</code>, kter\u00e9 zp\u0159\u00edstupn\u00ed ulo\u017een\u00e9 kryptografick\u00e9 kl\u00ed\u010de</p> </li> <li> <p>Objevov\u00e1n\u00ed peer\u016f:</p> </li> <li><code>NodeDiscovery</code> automaticky vys\u00edl\u00e1 ozn\u00e1men\u00ed do s\u00edt\u011b</li> <li>Jin\u00e9 instance aplikace tato ozn\u00e1men\u00ed zachyt\u00ed a p\u0159idaj\u00ed uzly do seznamu dostupn\u00fdch peer\u016f</li> <li> <p><code>PeerListWidget</code> zobrazuje tyto peery v u\u017eivatelsk\u00e9m rozhran\u00ed</p> </li> <li> <p>Nav\u00e1z\u00e1n\u00ed spojen\u00ed:</p> </li> <li>U\u017eivatel vybere peera a iniciuje spojen\u00ed</li> <li><code>P2PNode</code> vytvo\u0159\u00ed TCP spojen\u00ed s vybran\u00fdm peerem</li> <li> <p><code>SecureMessaging</code> inicializuje v\u00fdm\u011bnu kvantov\u011b odoln\u00fdch kl\u00ed\u010d\u016f:</p> <ul> <li>Vygeneruje do\u010dasn\u00fd p\u00e1r kl\u00ed\u010d\u016f pomoc\u00ed <code>KeyExchangeAlgorithm</code> (ML-KEM)</li> <li>Provede v\u00fdm\u011bnu kl\u00ed\u010d\u016f s peerem</li> <li>Odvod\u00ed symetrick\u00e9 kl\u00ed\u010de pro \u0161ifrov\u00e1n\u00ed</li> </ul> </li> <li> <p>Zabezpe\u010den\u00e1 komunikace:</p> </li> <li>U\u017eivatel nap\u00ed\u0161e zpr\u00e1vu v <code>MessagingWidget</code></li> <li><code>SecureMessaging</code> podep\u00ed\u0161e zpr\u00e1vu pomoc\u00ed <code>SignatureAlgorithm</code> (ML-DSA)</li> <li>Zpr\u00e1va je za\u0161ifrov\u00e1na pomoc\u00ed <code>SymmetricAlgorithm</code> (AES-256-GCM)</li> <li>\u0160ifrovan\u00e1 zpr\u00e1va je posl\u00e1na p\u0159es <code>P2PNode</code> ke vzd\u00e1len\u00e9mu peeru</li> <li>Na stran\u011b p\u0159\u00edjemce je zpr\u00e1va de\u0161ifrov\u00e1na a ov\u011b\u0159ena</li> <li> <p>Text zpr\u00e1vy je zobrazen v <code>MessagingWidget</code></p> </li> <li> <p>P\u0159enos soubor\u016f:</p> </li> <li>Funguje na stejn\u00e9m principu jako textov\u00e9 zpr\u00e1vy</li> <li>Velk\u00e9 soubory jsou rozd\u011bleny na \u010d\u00e1sti (chunky) pro efektivn\u00ed p\u0159enos</li> <li> <p>Po p\u0159ijet\u00ed jsou \u010d\u00e1sti znovu slo\u017eeny do p\u016fvodn\u00edho souboru</p> </li> <li> <p>Bezpe\u010dnostn\u00ed protokolov\u00e1n\u00ed:</p> </li> <li><code>SecureLogger</code> zaznamen\u00e1v\u00e1 v\u0161echny bezpe\u010dnostn\u00ed ud\u00e1losti</li> <li>Z\u00e1znamy jsou \u0161ifrov\u00e1ny a chr\u00e1n\u011bny proti manipulaci</li> <li>U\u017eivatel m\u016f\u017ee prohl\u00ed\u017eet protokoly p\u0159es <code>LogViewerDialog</code></li> </ol>"},{"location":"dokumentace-final/#klicove-aspekty-zabezpeceni","title":"Kl\u00ed\u010dov\u00e9 aspekty zabezpe\u010den\u00ed:","text":"<ul> <li>Dop\u0159edn\u00e1 bezpe\u010dnost (Forward Secrecy): Pro ka\u017edou relaci se generuj\u00ed nov\u00e9 p\u00e1ry kl\u00ed\u010d\u016f</li> <li>Autentizovan\u00e1 \u0161ifra: Pou\u017e\u00edv\u00e1 AEAD (Authenticated Encryption with Associated Data)</li> <li>Post-kvantov\u00e1 odolnost: V\u0161echny kryptografick\u00e9 algoritmy jsou odoln\u00e9 proti kvantov\u00fdm \u00fatok\u016fm</li> <li>Ochrana metadat: Kritick\u00e1 metadata jsou v\u00e1z\u00e1na na \u0161ifrov\u00fd text s ochranou integrity</li> </ul>"},{"location":"dokumentace-final/#popis-instalace","title":"Popis instalace","text":""},{"location":"dokumentace-final/#systemove-pozadavky","title":"Syst\u00e9mov\u00e9 po\u017eadavky","text":"<ul> <li>Python 3.8 nebo vy\u0161\u0161\u00ed</li> <li>Podporovan\u00e9 opera\u010dn\u00ed syst\u00e9my: Windows, macOS, Linux</li> </ul>"},{"location":"dokumentace-final/#instalace-s-virtualnim-prostredim-doporuceno","title":"Instalace s virtu\u00e1ln\u00edm prost\u0159ed\u00edm (doporu\u010deno)","text":"<pre><code># Naklonujte repozit\u00e1\u0159\ngit clone https://github.com/DivinityQQ/quantum-resistant-p2p.git\ncd quantum_resistant_p2p\n\n# Vytvo\u0159te virtu\u00e1ln\u00ed prost\u0159ed\u00ed\npython -m venv venv\n\n# Aktivujte virtu\u00e1ln\u00ed prost\u0159ed\u00ed\n# Na Windows:\nvenv\\Scripts\\activate\n# Na macOS/Linux:\nsource venv/bin/activate\n\n# Instalace projektu\npip install .\n</code></pre>"},{"location":"dokumentace-final/#instalace-v-rezimu-vyvojare","title":"Instalace v re\u017eimu v\u00fdvoj\u00e1\u0159e","text":"<pre><code># S aktivovan\u00fdm virtu\u00e1ln\u00edm prost\u0159ed\u00edm:\npip install -e .\n</code></pre>"},{"location":"dokumentace-final/#popis-spusteni-programu","title":"Popis spu\u0161t\u011bn\u00ed programu","text":""},{"location":"dokumentace-final/#zakladni-spusteni","title":"Z\u00e1kladn\u00ed spu\u0161t\u011bn\u00ed","text":"<pre><code># Ujist\u011bte se, \u017ee je virtu\u00e1ln\u00ed prost\u0159ed\u00ed aktivov\u00e1no\n# (venv) by m\u011blo b\u00fdt viditeln\u00e9 na za\u010d\u00e1tku p\u0159\u00edkazov\u00e9ho \u0159\u00e1dku\n\n# Spu\u0161t\u011bn\u00ed aplikace\npython -m quantum_resistant_p2p\n</code></pre>"},{"location":"dokumentace-final/#navod-k-pouziti","title":"N\u00e1vod k pou\u017eit\u00ed","text":"<ol> <li>Prvn\u00ed spu\u0161t\u011bn\u00ed:</li> <li>P\u0159i prvn\u00edm spu\u0161t\u011bn\u00ed budete vyzv\u00e1ni k vytvo\u0159en\u00ed hesla</li> <li> <p>Toto heslo bude pou\u017eito k zabezpe\u010den\u00ed va\u0161ich kryptografick\u00fdch kl\u00ed\u010d\u016f</p> </li> <li> <p>P\u0159ipojen\u00ed k peer\u016fm:</p> </li> <li>Aplikace automaticky vyhled\u00e1 peery v m\u00edstn\u00ed s\u00edti</li> <li>Pro ru\u010dn\u00ed p\u0159ipojen\u00ed pou\u017eijte menu File &gt; Connect to Peer</li> <li> <p>Zadejte IP adresu a port peeru</p> </li> <li> <p>Ustanoven\u00ed bezpe\u010dn\u00e9ho spojen\u00ed:</p> </li> <li>Vyberte peera ze seznamu</li> <li>Klikn\u011bte na \"Establish Shared Key\" pro vytvo\u0159en\u00ed zabezpe\u010den\u00e9ho kan\u00e1lu</li> <li> <p>Po \u00fasp\u011b\u0161n\u00e9 v\u00fdm\u011bn\u011b kl\u00ed\u010d\u016f se zobraz\u00ed \"Secure Connection Established\"</p> </li> <li> <p>Zas\u00edl\u00e1n\u00ed zpr\u00e1v:</p> </li> <li>Pi\u0161te zpr\u00e1vy do textov\u00e9ho pole ve spodn\u00ed \u010d\u00e1sti okna</li> <li> <p>Stiskn\u011bte Enter nebo klikn\u011bte na \"Send\" pro odesl\u00e1n\u00ed</p> </li> <li> <p>P\u0159enos soubor\u016f:</p> </li> <li>Pou\u017eijte menu File &gt; Send File nebo tla\u010d\u00edtko \"Send File\"</li> <li>Vyberte soubor k odesl\u00e1n\u00ed</li> <li> <p>P\u0159ijat\u00fd soubor m\u016f\u017eete ulo\u017eit kliknut\u00edm prav\u00fdm tla\u010d\u00edtkem na ozn\u00e1men\u00ed o p\u0159ijet\u00ed</p> </li> <li> <p>Nastaven\u00ed kryptografie:</p> </li> <li>V menu Settings &gt; Cryptography Settings m\u016f\u017eete zm\u011bnit pou\u017e\u00edvan\u00e9 algoritmy</li> <li>Pro prohl\u00ed\u017een\u00ed bezpe\u010dnostn\u00edch metrik pou\u017eijte Settings &gt; Security Metrics</li> <li>Historie kl\u00ed\u010d\u016f je dostupn\u00e1 v Settings &gt; Key Exchange History</li> </ol>"},{"location":"dokumentace-final/#priklad-pouziti-pro-overeni-funkcnosti","title":"P\u0159\u00edklad pou\u017eit\u00ed pro ov\u011b\u0159en\u00ed funk\u010dnosti","text":"<p>Pro ov\u011b\u0159en\u00ed funk\u010dnosti aplikace m\u016f\u017eete spustit dva instance na jednom po\u010d\u00edta\u010di:</p> <ol> <li>Otev\u0159ete dva termin\u00e1ly a aktivujte v nich virtu\u00e1ln\u00ed prost\u0159ed\u00ed</li> <li>V prvn\u00edm termin\u00e1lu spus\u0165te:    <pre><code>python -m tests.local_testing server 8000\n</code></pre></li> <li>Ve druh\u00e9m termin\u00e1lu spus\u0165te:    <pre><code>python -m tests.local_testing client 8001 8000\n</code></pre></li> <li>T\u00edm se vytvo\u0159\u00ed dv\u011b instance aplikace, kter\u00e9 se automaticky propoj\u00ed</li> <li>M\u016f\u017eete pozorovat v\u00fdm\u011bnu zpr\u00e1v a ov\u011b\u0159it funk\u010dnost p\u0159enosu soubor\u016f</li> </ol>"},{"location":"dokumentace-final/#pouzite-externi-knihovny-a-jejich-verze","title":"Pou\u017eit\u00e9 extern\u00ed knihovny a jejich verze","text":"<p>Projekt vyu\u017e\u00edv\u00e1 n\u00e1sleduj\u00edc\u00ed extern\u00ed knihovny:</p> <ul> <li>asyncio (\u22653.4.3) - Pro asynchronn\u00ed zpracov\u00e1n\u00ed</li> <li>aiohttp (\u22653.11.14) - Pro HTTP komunikaci</li> <li>qasync (\u22650.27.1) - Pro propojen\u00ed asyncio s Qt</li> <li>cryptography (\u226544.0.2) - Pro kryptografick\u00e9 operace</li> <li>pynacl (\u22651.5.0) - Pro implementaci ChaCha20-Poly1305</li> <li>PyQt5 (\u22655.15.11) - Pro u\u017eivatelsk\u00e9 rozhran\u00ed aplikace</li> <li>pyyaml (\u22656.0.2) - Pro pr\u00e1ci s YAML konfigurac\u00ed</li> <li>python-dotenv (\u22651.0.1) - Pro na\u010d\u00edt\u00e1n\u00ed prom\u011bnn\u00fdch prost\u0159ed\u00ed</li> <li>structlog (\u226525.2.0) - Pro strukturovan\u00e9 protokolov\u00e1n\u00ed</li> </ul> <p>Tyto z\u00e1vislosti jsou definov\u00e1ny v souborech <code>setup.py</code> a <code>requirements.txt</code>.</p>"},{"location":"dokumentace-final/#popis-kodu","title":"Popis k\u00f3du","text":"<p>Projekt je strukturov\u00e1n do n\u011bkolika modul\u016f, kter\u00e9 odpov\u00eddaj\u00ed vrstv\u00e1m architektury:</p>"},{"location":"dokumentace-final/#networking","title":"Networking","text":"<ul> <li>P2PNode (<code>networking/p2p_node.py</code>): Hlavn\u00ed t\u0159\u00edda pro peer-to-peer komunikaci</li> <li><code>start()</code>: Spust\u00ed P2P uzel a za\u010dne naslouchat spojen\u00ed</li> <li><code>connect_to_peer()</code>: P\u0159ipoj\u00ed se k jin\u00e9mu uzlu v s\u00edti</li> <li> <p><code>send_message()</code>: Po\u0161le zpr\u00e1vu p\u0159ipojen\u00e9mu peeru</p> </li> <li> <p>NodeDiscovery (<code>networking/discovery.py</code>): Slu\u017eba pro objevov\u00e1n\u00ed peer\u016f</p> </li> <li><code>start()</code>: Spust\u00ed slu\u017ebu objevov\u00e1n\u00ed uzl\u016f</li> <li><code>_send_announcement()</code>: Vys\u00edl\u00e1 ozn\u00e1men\u00ed o p\u0159\u00edtomnosti uzlu</li> <li><code>get_discovered_nodes()</code>: Z\u00edsk\u00e1 seznam objeven\u00fdch uzl\u016f</li> </ul>"},{"location":"dokumentace-final/#crypto","title":"Crypto","text":"<ul> <li>KeyExchangeAlgorithm (<code>crypto/key_exchange.py</code>): Abstraktn\u00ed t\u0159\u00edda pro algoritmy v\u00fdm\u011bny kl\u00ed\u010d\u016f</li> <li>Konkr\u00e9tn\u00ed implementace: <code>MLKEMKeyExchange</code>, <code>HQCKeyExchange</code>, <code>FrodoKEMKeyExchange</code></li> <li><code>generate_keypair()</code>: Generuje nov\u00fd p\u00e1r kl\u00ed\u010d\u016f</li> <li><code>encapsulate()</code>: Zapouzd\u0159\u00ed sd\u00edlen\u00e9 tajemstv\u00ed pomoc\u00ed ve\u0159ejn\u00e9ho kl\u00ed\u010de p\u0159\u00edjemce</li> <li> <p><code>decapsulate()</code>: Rozbal\u00ed sd\u00edlen\u00e9 tajemstv\u00ed pomoc\u00ed soukrom\u00e9ho kl\u00ed\u010de</p> </li> <li> <p>SymmetricAlgorithm (<code>crypto/symmetric.py</code>): Abstraktn\u00ed t\u0159\u00edda pro symetrick\u00e9 \u0161ifrov\u00e1n\u00ed</p> </li> <li>Konkr\u00e9tn\u00ed implementace: <code>AES256GCM</code>, <code>ChaCha20Poly1305</code></li> <li><code>encrypt()</code>: \u0160ifruje data s podporou p\u0159idru\u017een\u00fdch dat (AEAD)</li> <li> <p><code>decrypt()</code>: De\u0161ifruje data a ov\u011b\u0159uje integritu</p> </li> <li> <p>SignatureAlgorithm (<code>crypto/signatures.py</code>): Abstraktn\u00ed t\u0159\u00edda pro digit\u00e1ln\u00ed podpisy</p> </li> <li>Konkr\u00e9tn\u00ed implementace: <code>MLDSASignature</code>, <code>SPHINCSSignature</code></li> <li><code>sign()</code>: Vytvo\u0159\u00ed podpis zpr\u00e1vy pomoc\u00ed soukrom\u00e9ho kl\u00ed\u010de</li> <li> <p><code>verify()</code>: Ov\u011b\u0159\u00ed podpis pomoc\u00ed ve\u0159ejn\u00e9ho kl\u00ed\u010de</p> </li> <li> <p>KeyStorage (<code>crypto/key_storage.py</code>): Bezpe\u010dn\u00e9 \u00falo\u017ei\u0161t\u011b pro kryptografick\u00e9 kl\u00ed\u010de</p> </li> <li><code>unlock()</code>: Odemkne \u00falo\u017ei\u0161t\u011b pomoc\u00ed hesla</li> <li><code>store_key()</code>: Ulo\u017e\u00ed kl\u00ed\u010d do \u00falo\u017ei\u0161t\u011b</li> <li><code>get_key()</code>: Z\u00edsk\u00e1 kl\u00ed\u010d z \u00falo\u017ei\u0161t\u011b</li> <li><code>change_password()</code>: Zm\u011bn\u00ed heslo pro \u00falo\u017ei\u0161t\u011b</li> </ul>"},{"location":"dokumentace-final/#app","title":"App","text":"<ul> <li>SecureMessaging (<code>app/messaging.py</code>): Koordinuje kryptografick\u00e9 operace pro komunikaci</li> <li><code>initiate_key_exchange()</code>: Zah\u00e1j\u00ed v\u00fdm\u011bnu kl\u00ed\u010d\u016f s peerem</li> <li><code>send_message()</code>: Bezpe\u010dn\u011b ode\u0161le zpr\u00e1vu (podeps\u00e1n\u00ed, \u0161ifrov\u00e1n\u00ed, p\u0159enos)</li> <li> <p><code>send_file()</code>: Bezpe\u010dn\u011b ode\u0161le soubor</p> </li> <li> <p>Message (<code>app/messaging.py</code>): Datov\u00e1 t\u0159\u00edda reprezentuj\u00edc\u00ed zpr\u00e1vu</p> </li> <li><code>to_dict()</code>: P\u0159evede zpr\u00e1vu na slovn\u00edk (v\u010detn\u011b k\u00f3dov\u00e1n\u00ed bin\u00e1rn\u00edch dat)</li> <li> <p><code>from_dict()</code>: Vytvo\u0159\u00ed zpr\u00e1vu ze slovn\u00edku</p> </li> <li> <p>SecureLogger (<code>app/logging.py</code>): Poskytuje zabezpe\u010den\u00e9 protokolov\u00e1n\u00ed</p> </li> <li><code>log_event()</code>: Zaznamen\u00e1 bezpe\u010dnostn\u00ed ud\u00e1lost</li> <li><code>get_events()</code>: Z\u00edsk\u00e1 zaznamenan\u00e9 ud\u00e1losti s filtrov\u00e1n\u00edm</li> <li><code>get_security_metrics()</code>: Poskytuje metriky zabezpe\u010den\u00ed</li> </ul>"},{"location":"dokumentace-final/#ui","title":"UI","text":"<ul> <li>MainWindow (<code>ui/main_window.py</code>): Hlavn\u00ed okno aplikace</li> <li><code>_init_network()</code>: Inicializuje s\u00ed\u0165ov\u00e9 komponenty</li> <li><code>_init_ui()</code>: Inicializuje u\u017eivatelsk\u00e9 rozhran\u00ed</li> <li> <p><code>_start_network()</code>: Asynchronn\u011b spust\u00ed s\u00ed\u0165ov\u00e9 slu\u017eby</p> </li> <li> <p>MessagingWidget (<code>ui/messaging_widget.py</code>): Widget pro zas\u00edl\u00e1n\u00ed zpr\u00e1v</p> </li> <li><code>_on_send_clicked()</code>: Zpracuje po\u017eadavek na odesl\u00e1n\u00ed zpr\u00e1vy</li> <li><code>_send_file()</code>: Zpracuje odesl\u00e1n\u00ed souboru</li> <li> <p><code>handle_message()</code>: Zobraz\u00ed p\u0159ijatou zpr\u00e1vu</p> </li> <li> <p>PeerListWidget (<code>ui/peer_list.py</code>): Widget pro zobrazen\u00ed a spr\u00e1vu peer\u016f</p> </li> <li><code>update_peers()</code>: Aktualizuje seznam peer\u016f</li> <li> <p><code>_on_connect_clicked()</code>: Zpracuje po\u017eadavek na p\u0159ipojen\u00ed k peeru</p> </li> <li> <p>Dialogs: R\u016fzn\u00e9 dialogy pro nastaven\u00ed a zobrazen\u00ed informac\u00ed</p> </li> <li><code>LoginDialog</code>: Dialog pro p\u0159ihl\u00e1\u0161en\u00ed (odemknut\u00ed \u00falo\u017ei\u0161t\u011b kl\u00ed\u010d\u016f)</li> <li><code>SettingsDialog</code>: Dialog pro nastaven\u00ed kryptografick\u00fdch algoritm\u016f</li> <li><code>LogViewerDialog</code>: Dialog pro zobrazen\u00ed bezpe\u010dnostn\u00edch protokol\u016f</li> <li><code>KeyHistoryDialog</code>: Dialog pro zobrazen\u00ed historie v\u00fdm\u011bny kl\u00ed\u010d\u016f</li> </ul>"},{"location":"dokumentace-final/#zaver","title":"Z\u00e1v\u011br","text":"<p>Projekt Quantum-Resistant P2P \u00fasp\u011b\u0161n\u011b dos\u00e1hl stanoven\u00fdch c\u00edl\u016f:</p> <ol> <li> <p>Implementace post-kvantov\u00fdch algoritm\u016f: Aplikace vyu\u017e\u00edv\u00e1 nejmodern\u011bj\u0161\u00ed post-kvantov\u00e9 algoritmy schv\u00e1len\u00e9 NIST pro zaji\u0161t\u011bn\u00ed bezpe\u010dnosti proti budouc\u00edm kvantov\u00fdm \u00fatok\u016fm.</p> </li> <li> <p>U\u017eivatelsky p\u0159\u00edv\u011btiv\u00e9 rozhran\u00ed: Projekt poskytuje intuitivn\u00ed grafick\u00e9 rozhran\u00ed pro snadn\u00e9 pou\u017e\u00edv\u00e1n\u00ed pokro\u010dil\u00fdch kryptografick\u00fdch funkc\u00ed.</p> </li> <li> <p>Bezpe\u010dn\u00e1 komunikace: Implementace zaji\u0161\u0165uje end-to-end \u0161ifrovanou komunikaci s dop\u0159ednou bezpe\u010dnost\u00ed a autentizac\u00ed v\u0161ech zpr\u00e1v.</p> </li> <li> <p>Bezpe\u010dn\u00fd p\u0159enos soubor\u016f: Umo\u017e\u0148uje \u0161ifrovan\u00fd p\u0159enos soubor\u016f libovoln\u00e9 velikosti mezi peery.</p> </li> <li> <p>Transparentnost bezpe\u010dnosti: Nab\u00edz\u00ed podrobn\u00e9 protokolov\u00e1n\u00ed a metriky bezpe\u010dnosti, kter\u00e9 u\u017eivatel\u016fm umo\u017e\u0148uj\u00ed sledovat bezpe\u010dnostn\u00ed vlastnosti komunikace.</p> </li> <li> <p>Flexibilita kryptografick\u00fdch nastaven\u00ed: U\u017eivatel\u00e9 mohou vyb\u00edrat a p\u0159izp\u016fsobovat kryptografick\u00e9 algoritmy podle sv\u00fdch pot\u0159eb a po\u017eadavk\u016f na zabezpe\u010den\u00ed.</p> </li> <li> <p>Multiplatformn\u00ed podpora: Aplikace funguje na r\u016fzn\u00fdch opera\u010dn\u00edch syst\u00e9mech bez zm\u011bny k\u00f3du.</p> </li> </ol> <p>Quantum-Resistant P2P p\u0159edstavuje komplexn\u00ed \u0159e\u0161en\u00ed pro bezpe\u010dnou komunikaci, kter\u00e9 je p\u0159ipraveno na \u00e9ru kvantov\u00fdch po\u010d\u00edta\u010d\u016f. D\u00edky modul\u00e1rn\u00ed architektu\u0159e a pou\u017e\u00edv\u00e1n\u00ed standardizovan\u00fdch algoritm\u016f je aplikace p\u0159ipravena adaptovat se na budouc\u00ed v\u00fdvoj v oblasti post-kvantov\u00e9 kryptografie.</p>"},{"location":"user-guide/","title":"User Guide","text":""},{"location":"user-guide/#installation","title":"Installation","text":""},{"location":"user-guide/#installation-with-virtual-environment-recommended","title":"Installation with Virtual Environment (Recommended)","text":"<p>It's recommended to use a virtual environment to avoid conflicts with other Python packages. Here's how to set up and install the application:</p> <pre><code># First, clone the repository\ngit clone https://github.com/DivinityQQ/quantum-resistant-p2p.git\ncd quantum_resistant_p2p\n\n# Create a virtual environment inside the project directory\npython -m venv venv\n\n# Activate the virtual environment\n# On Windows:\nvenv\\Scripts\\activate\n# On macOS/Linux:\nsource venv/bin/activate\n</code></pre> <p>Your command prompt should now show <code>(venv)</code> at the beginning, indicating the virtual environment is active. All pip commands will now install packages into this isolated environment.</p>"},{"location":"user-guide/#option-1-standard-installation","title":"Option 1: Standard Installation","text":"<pre><code># With the virtual environment activated and while in the quantum_resistant_p2p directory:\npip install .\n</code></pre>"},{"location":"user-guide/#option-2-development-mode-installation","title":"Option 2: Development Mode Installation","text":"<pre><code># With the virtual environment activated and while in the quantum_resistant_p2p directory:\npip install -e .\n</code></pre>"},{"location":"user-guide/#deactivating-the-virtual-environment","title":"Deactivating the Virtual Environment","text":"<p>When you're done using the application, you can deactivate the virtual environment:</p> <pre><code>deactivate\n</code></pre>"},{"location":"user-guide/#running-the-application","title":"Running the Application","text":"<p>Once installed, you can run the application using:</p> <pre><code># Make sure your virtual environment is activated first\n# (You should see (venv) at the beginning of your command prompt)\n\n# From the quantum_resistant_p2p directory:\npython -m quantum_resistant_p2p\n</code></pre>"},{"location":"user-guide/#basic-usage","title":"Basic Usage","text":"<ol> <li> <p>Start the application</p> </li> <li> <p>Login</p> </li> <li>When first starting, you'll be prompted to create a password to secure your keys</li> <li> <p>For subsequent launches, enter the same password</p> </li> <li> <p>Connect to Peers</p> </li> <li>The application will automatically search for peers on the local network</li> <li>Or click \"Add Peer\" to manually enter a peer's address</li> <li> <p>Select a peer from the list and click \"Connect\"</p> </li> <li> <p>Establish Secure Connection</p> </li> <li>After connecting, click \"Establish Shared Key\" to perform a post-quantum key exchange</li> <li> <p>This creates a secure channel protected against both classical and quantum attacks</p> </li> <li> <p>Secure Messaging</p> </li> <li>Type messages in the input field and press Enter or click Send</li> <li> <p>Use \"Send File\" to securely transfer files</p> </li> <li> <p>Security Settings</p> </li> <li>Access \"Crypto Settings\" to customize which algorithms are used</li> <li>View logs and security metrics from the Settings menu</li> </ol>"},{"location":"user-guide/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/#connection-issues","title":"Connection Issues","text":"<p>If you're having trouble connecting to peers:</p> <ol> <li>Ensure both peers are on the same network</li> <li>Check if any firewall is blocking UDP port 8001 (discovery) or TCP port 8000 (communication)</li> <li>Try adding the peer manually with their IP address</li> </ol>"},{"location":"user-guide/#advanced-building-oqs-yourself","title":"Advanced: Building OQS Yourself","text":"<p>If you need to build the OQS library yourself:</p>"},{"location":"user-guide/#windows","title":"Windows","text":"<pre><code>git clone https://github.com/open-quantum-safe/liboqs\ncd liboqs\nmkdir build &amp;&amp; cd build\ncmake .. -DBUILD_SHARED_LIBS=ON -DCMAKE_WINDOWS_EXPORT_ALL_SYMBOLS=TRUE\ncmake --build . --config Release --parallel 8\n# Copy build\\bin\\Release\\oqs.dll to quantum_resistant_p2p\\vendor\\lib\\windows\\\n</code></pre>"},{"location":"user-guide/#macos","title":"macOS","text":"<pre><code>brew install cmake ninja\ngit clone https://github.com/open-quantum-safe/liboqs\ncd liboqs\nmkdir build &amp;&amp; cd build\ncmake .. -DBUILD_SHARED_LIBS=ON -DOQS_BUILD_ONLY_LIB=ON\ncmake --build . --parallel 8\n# Copy build/lib/liboqs.dylib to quantum_resistant_p2p/vendor/lib/macos/\n</code></pre>"},{"location":"user-guide/#linux","title":"Linux","text":"<pre><code>sudo apt install cmake gcc ninja-build libssl-dev\ngit clone https://github.com/open-quantum-safe/liboqs\ncd liboqs\nmkdir build &amp;&amp; cd build\ncmake .. -DBUILD_SHARED_LIBS=ON -DOQS_BUILD_ONLY_LIB=ON\ncmake --build . --parallel 8\n# Copy build/lib/liboqs.so to quantum_resistant_p2p/vendor/lib/linux/\n</code></pre>"},{"location":"api/app/","title":"App Package","text":"<p>The App package provides the application layer for post-quantum secure P2P messaging, including secure messaging functionality and logging.</p>"},{"location":"api/app/#quantum_resistant_p2p.app","title":"<code>quantum_resistant_p2p.app</code>","text":"<p>Application layer for post-quantum secure P2P messaging.</p> <p>This package provides the application logic, messaging, and logging functionality.</p>"},{"location":"api/app/#quantum_resistant_p2p.app-classes","title":"Classes","text":""},{"location":"api/app/#quantum_resistant_p2p.app.SecureMessaging","title":"<code>SecureMessaging(node, key_storage, logger, key_exchange_algorithm=None, symmetric_algorithm=None, signature_algorithm=None)</code>","text":"<p>Secure messaging functionality using post-quantum cryptography.</p> <p>This class provides high-level functionality for secure messaging, including key exchange, encryption, and digital signatures.</p> <p>Initialize secure messaging functionality.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>P2PNode</code> <p>The P2P node for communication</p> required <code>key_storage</code> <code>KeyStorage</code> <p>The key storage for cryptographic keys</p> required <code>logger</code> <code>SecureLogger</code> <p>The secure logger for logging events</p> required <code>key_exchange_algorithm</code> <code>Optional[KeyExchangeAlgorithm]</code> <p>The algorithm to use for key exchange</p> <code>None</code> <code>symmetric_algorithm</code> <code>Optional[SymmetricAlgorithm]</code> <p>The algorithm to use for symmetric encryption</p> <code>None</code> <code>signature_algorithm</code> <code>Optional[SignatureAlgorithm]</code> <p>The algorithm to use for digital signatures</p> <code>None</code> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def __init__(self, \n             node: P2PNode,\n             key_storage: KeyStorage,\n             logger: SecureLogger,\n             key_exchange_algorithm: Optional[KeyExchangeAlgorithm] = None,\n             symmetric_algorithm: Optional[SymmetricAlgorithm] = None,\n             signature_algorithm: Optional[SignatureAlgorithm] = None):\n    \"\"\"Initialize secure messaging functionality.\n\n    Args:\n        node: The P2P node for communication\n        key_storage: The key storage for cryptographic keys\n        logger: The secure logger for logging events\n        key_exchange_algorithm: The algorithm to use for key exchange\n        symmetric_algorithm: The algorithm to use for symmetric encryption\n        signature_algorithm: The algorithm to use for digital signatures\n    \"\"\"\n    self.node = node\n    self.key_storage = key_storage\n    self.secure_logger = logger  # Rename to avoid conflict with global logger\n\n    # Use default algorithms if not specified\n    self.key_exchange = key_exchange_algorithm or MLKEMKeyExchange()\n    self.symmetric = symmetric_algorithm or AES256GCM()\n    self.signature = signature_algorithm or MLDSASignature()\n\n    # Dictionary mapping peer IDs to shared symmetric keys\n    self.shared_keys: Dict[str, bytes] = {}\n\n    # Dictionary mapping peer IDs to original shared secrets (before derivation)\n    self.key_exchange_originals: Dict[str, bytes] = {}\n\n    # Dictionary mapping peer IDs to key exchange states\n    self.key_exchange_states: Dict[str, int] = {}\n\n    # Dictionary mapping message IDs to callbacks for received messages\n    self.message_callbacks: Dict[str, Callable[[Any], None]] = {}\n\n    # List of global message handlers\n    self.global_message_handlers: List[Callable[[Message], None]] = []\n\n    # List of settings change listeners\n    self.settings_change_listeners: List[Callable[[], None]] = []\n\n    # Store peer crypto settings\n    self.peer_crypto_settings: Dict[str, Dict[str, str]] = {}\n\n    # Track processed message IDs to prevent duplicates\n    self.processed_message_ids = set()\n\n    # Register message handlers\n    self.node.register_message_handler(\"key_exchange_init\", self._handle_key_exchange_init)\n    self.node.register_message_handler(\"key_exchange_response\", self._handle_key_exchange_response)\n    self.node.register_message_handler(\"key_exchange_confirm\", self._handle_key_exchange_confirm)\n    self.node.register_message_handler(\"key_exchange_test\", self._handle_key_exchange_test)\n    self.node.register_message_handler(\"secure_message\", self._handle_secure_message)\n    self.node.register_message_handler(\"crypto_settings_update\", self._handle_crypto_settings_update)\n    self.node.register_message_handler(\"crypto_settings_request\", self._handle_crypto_settings_request)\n    self.node.register_message_handler(\"key_exchange_rejected\", self._handle_key_exchange_rejected)\n\n    # Generate or load our keypair\n    self._load_or_generate_keypair()\n\n    # Load saved peer keys\n    # self._load_peer_keys()\n\n    # Log initialization\n    self.secure_logger.log_event(\n        event_type=\"initialization\",\n        message=f\"Secure messaging initialized with {self.key_exchange.name}, \"\n                f\"{self.symmetric.name}, and {self.signature.name}\"\n    )\n\n    # Use the module logger\n    logging.getLogger(__name__).info(\n        f\"Secure messaging initialized with {self.key_exchange.name}, \"\n        f\"{self.symmetric.name}, and {self.signature.name}\"\n    )\n\n    # Register connection event handler to automatically share settings\n    self.node.register_connection_handler(self._handle_new_connection)\n</code></pre>"},{"location":"api/app/#quantum_resistant_p2p.app.SecureMessaging-functions","title":"Functions","text":"<code>register_global_message_handler(handler)</code> \u00b6 <p>Register a handler for all messages.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable[[Message], None]</code> <p>Callback function that takes a Message as parameter</p> required Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def register_global_message_handler(self, handler: Callable[[Message], None]) -&gt; None:\n    \"\"\"Register a handler for all messages.\n\n    Args:\n        handler: Callback function that takes a Message as parameter\n    \"\"\"\n    # Check if this handler is already registered (by its memory address)\n    handler_id = id(handler)\n\n    # Avoid adding the same handler twice\n    if any(id(h) == handler_id for h in self.global_message_handlers):\n        logger.debug(f\"Handler {handler_id} already registered, skipping\")\n        return\n\n    self.global_message_handlers.append(handler)\n    logger.debug(f\"Registered global message handler {handler_id}\")\n</code></pre> <code>register_settings_change_listener(listener)</code> \u00b6 <p>Register a listener for cryptography settings changes.</p> <p>Parameters:</p> Name Type Description Default <code>listener</code> <code>Callable[[], None]</code> <p>Callback function that takes no parameters</p> required Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def register_settings_change_listener(self, listener: Callable[[], None]) -&gt; None:\n    \"\"\"Register a listener for cryptography settings changes.\n\n    Args:\n        listener: Callback function that takes no parameters\n    \"\"\"\n    listener_id = id(listener)\n\n    # Avoid adding the same listener twice\n    if any(id(l) == listener_id for l in self.settings_change_listeners):\n        logger.debug(f\"Settings change listener {listener_id} already registered, skipping\")\n        return\n\n    self.settings_change_listeners.append(listener)\n    logger.debug(f\"Registered crypto settings change listener {listener_id}\")\n</code></pre> <code>is_algorithm_compatible_with_peer(peer_id)</code> \u00b6 <p>Check if our current algorithm is compatible with the peer's algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <code>str</code> <p>The ID of the peer to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if algorithms are compatible, False otherwise</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def is_algorithm_compatible_with_peer(self, peer_id: str) -&gt; bool:\n    \"\"\"Check if our current algorithm is compatible with the peer's algorithm.\n\n    Args:\n        peer_id: The ID of the peer to check\n\n    Returns:\n        True if algorithms are compatible, False otherwise\n    \"\"\"\n    if peer_id not in self.peer_crypto_settings:\n        # If we don't know the peer's settings, assume incompatible\n        return False\n\n    peer_settings = self.peer_crypto_settings[peer_id]\n\n    # Check if the key exchange algorithms match exactly\n    peer_key_exchange = peer_settings.get(\"key_exchange\", \"\")\n    our_key_exchange = self.key_exchange.display_name\n\n    # Must be the same algorithm type for compatibility\n    return peer_key_exchange == our_key_exchange\n</code></pre> <code>send_crypto_settings_to_peer(peer_id)</code> <code>async</code> \u00b6 <p>Send our cryptography settings to a specific peer.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <code>str</code> <p>The ID of the peer to send settings to</p> required Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>async def send_crypto_settings_to_peer(self, peer_id: str) -&gt; None:\n    \"\"\"Send our cryptography settings to a specific peer.\n\n    Args:\n        peer_id: The ID of the peer to send settings to\n    \"\"\"\n    # Create settings info message\n    settings_info = {\n        \"key_exchange\": self.key_exchange.name,\n        \"symmetric\": self.symmetric.name,\n        \"signature\": self.signature.name,\n        \"timestamp\": time.time()\n    }\n\n    # Encode the settings info\n    message_json = json.dumps(settings_info).encode()\n\n    # Send the settings update (without signature)\n    try:\n        await self.node.send_message(\n            peer_id=peer_id,\n            message_type=\"crypto_settings_update\",\n            settings=base64.b64encode(message_json).decode()\n        )\n        logger.debug(f\"Sent crypto settings to {peer_id}\")\n    except Exception as e:\n        logger.error(f\"Failed to send crypto settings to {peer_id}: {e}\")\n</code></pre> <code>request_crypto_settings_from_peer(peer_id)</code> <code>async</code> \u00b6 <p>Request cryptography settings from a specific peer.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <code>str</code> <p>The ID of the peer to request settings from</p> required Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>async def request_crypto_settings_from_peer(self, peer_id: str) -&gt; None:\n    \"\"\"Request cryptography settings from a specific peer.\n\n    Args:\n        peer_id: The ID of the peer to request settings from\n    \"\"\"\n    try:\n        await self.node.send_message(\n            peer_id=peer_id,\n            message_type=\"crypto_settings_request\",\n            timestamp=time.time()\n        )\n        logger.debug(f\"Requested crypto settings from {peer_id}\")\n    except Exception as e:\n        logger.error(f\"Failed to request crypto settings from {peer_id}: {e}\")\n</code></pre> <code>notify_peers_of_settings_change()</code> <code>async</code> \u00b6 <p>Notify all connected peers about cryptography settings changes.</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>async def notify_peers_of_settings_change(self) -&gt; None:\n    \"\"\"Notify all connected peers about cryptography settings changes.\"\"\"\n    peers = self.node.get_peers()\n    if not peers:\n        return\n\n    # Send to all connected peers\n    for peer_id in peers:\n        try:\n            await self.send_crypto_settings_to_peer(peer_id)\n        except Exception as e:\n            logger.error(f\"Failed to notify peer {peer_id} of settings change: {e}\")\n</code></pre> <code>initiate_key_exchange(peer_id)</code> <code>async</code> \u00b6 <p>Initiate an authenticated key exchange with a peer using ephemeral keys.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <code>str</code> <p>The ID of the peer to exchange keys with</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if key exchange initiated successfully, False otherwise</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>async def initiate_key_exchange(self, peer_id: str) -&gt; bool:\n    \"\"\"Initiate an authenticated key exchange with a peer using ephemeral keys.\n\n    Args:\n        peer_id: The ID of the peer to exchange keys with\n\n    Returns:\n        True if key exchange initiated successfully, False otherwise\n    \"\"\"\n    logger.debug(f\"Initiating authenticated key exchange with {peer_id}\")\n\n    # If we already have a key exchange in progress, don't start another\n    if peer_id in self.key_exchange_states and self.key_exchange_states[peer_id] in [\n        KeyExchangeState.INITIATED, KeyExchangeState.RESPONDED, KeyExchangeState.CONFIRMED\n    ]:\n        logger.warning(f\"Key exchange already in progress with {peer_id}\")\n        return False\n\n    # Check for algorithm compatibility before proceeding\n    compatible = self.is_algorithm_compatible_with_peer(peer_id)\n    if not compatible:\n        peer_algo = \"unknown\"\n        if peer_id in self.peer_crypto_settings:\n            peer_algo = self.peer_crypto_settings[peer_id].get(\"key_exchange\", \"unknown\")\n\n        logger.warning(f\"Algorithm incompatibility with peer {peer_id}: \" +\n                      f\"we use {self.key_exchange.display_name}, they use {peer_algo}\")\n\n        # Notify about algorithm mismatch via system message\n        for handler in self.global_message_handlers:\n            try:\n                mismatch_message = Message.system_message(\n                    f\"Cannot perform key exchange: Algorithm incompatibility - we use \" +\n                    f\"{self.key_exchange.display_name}, peer uses {peer_algo}. \" +\n                    f\"Both peers must use the same algorithm type.\"\n                )\n                handler(mismatch_message)\n            except Exception as e:\n                logger.error(f\"Error in algorithm mismatch handler: {e}\")\n\n        return False\n\n    try:\n        # Generate a fresh ephemeral keypair for this exchange\n        public_key, private_key = self._generate_ephemeral_keypair()\n\n        # Store the private key in memory temporarily (only for this exchange)\n        # We'll use a dictionary to map peer_id to ephemeral private keys\n        # This is cleared once the exchange is complete\n        if not hasattr(self, 'ephemeral_private_keys'):\n            self.ephemeral_private_keys = {}\n        self.ephemeral_private_keys[peer_id] = private_key\n\n        # Get our signature keypair for authentication\n        signature_key = self.key_storage.get_key(f\"signature_{self.signature.name}\")\n        if signature_key is None:\n            logger.error(f\"Missing signature keypair for {self.signature.name}\")\n            return False\n\n        # Create a structured message with metadata\n        ke_data = {\n            \"public_key\": base64.b64encode(public_key).decode(),\n            \"algorithm\": self.key_exchange.display_name,\n            \"sender_id\": self.node.node_id,\n            \"recipient_id\": peer_id,\n            \"timestamp\": time.time(),\n            \"message_id\": str(uuid.uuid4())\n        }\n\n        # Serialize the data for signing\n        ke_data_json = json.dumps(ke_data).encode()\n\n        # Sign the key exchange data\n        private_key_sig = signature_key[\"private_key\"]\n        signature = self.signature.sign(private_key_sig, ke_data_json)\n\n        # Generate a message ID for tracking the response\n        message_id = ke_data[\"message_id\"]\n\n        # Create a future for the response\n        future = asyncio.Future()\n\n        # Register a callback for the response\n        def callback(result):\n            if isinstance(result, Exception):\n                # Don't set exception if we already have the shared key\n                if peer_id in self.shared_keys:\n                    future.set_result(True)\n                else:\n                    future.set_exception(result)\n            else:\n                future.set_result(True)\n\n            # Clean up ephemeral private key regardless of result\n            if peer_id in self.ephemeral_private_keys:\n                del self.ephemeral_private_keys[peer_id]\n\n        self.message_callbacks[message_id] = callback\n\n        # Set key exchange state\n        self.key_exchange_states[peer_id] = KeyExchangeState.INITIATED\n\n        # Send the authenticated key exchange initiation\n        success = await self.node.send_message(\n            peer_id=peer_id,\n            message_type=\"key_exchange_init\",\n            message_id=message_id,\n            ke_data=base64.b64encode(ke_data_json).decode(),\n            signature=base64.b64encode(signature).decode(),\n            public_key=base64.b64encode(signature_key[\"public_key\"]).decode()\n        )\n\n        if not success:\n            logger.error(f\"Failed to send key exchange initiation to {peer_id}\")\n            self.key_exchange_states[peer_id] = KeyExchangeState.NONE\n            # Clean up ephemeral private key\n            if peer_id in self.ephemeral_private_keys:\n                del self.ephemeral_private_keys[peer_id]\n            return False\n\n        # Wait for the response with timeout\n        try:\n            await asyncio.wait_for(future, timeout=20.0)\n            return True\n        except asyncio.TimeoutError:\n            # Check if we have a shared key despite the timeout\n            if peer_id in self.shared_keys:\n                logger.warning(f\"Key exchange callback timed out but shared key exists for {peer_id}\")\n                return True\n\n            logger.error(f\"Timeout waiting for key exchange response from {peer_id}\")\n            self.key_exchange_states[peer_id] = KeyExchangeState.NONE\n            # Clean up ephemeral private key\n            if peer_id in self.ephemeral_private_keys:\n                del self.ephemeral_private_keys[peer_id]\n            return False\n\n    except Exception as e:\n        logger.error(f\"Error initiating key exchange with {peer_id}: {e}\")\n        self.key_exchange_states[peer_id] = KeyExchangeState.NONE\n        # Clean up ephemeral private key\n        if hasattr(self, 'ephemeral_private_keys') and peer_id in self.ephemeral_private_keys:\n            del self.ephemeral_private_keys[peer_id]\n        # Check if we have a shared key despite the error\n        if peer_id in self.shared_keys:\n            logger.warning(f\"Key exchange failed with error but shared key exists for {peer_id}\")\n            return True\n        return False\n</code></pre> <code>send_message(peer_id, content, is_file=False, filename=None)</code> <code>async</code> \u00b6 <p>Send a secure message to a peer.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <code>str</code> <p>The ID of the peer to send the message to</p> required <code>content</code> <code>bytes</code> <p>The message content</p> required <code>is_file</code> <code>bool</code> <p>Whether the content is a file</p> <code>False</code> <code>filename</code> <code>Optional[str]</code> <p>The filename, if is_file is True</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if message sent successfully, False otherwise</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>async def send_message(self, peer_id: str, content: bytes, \n                   is_file: bool = False, filename: Optional[str] = None) -&gt; bool:\n    \"\"\"Send a secure message to a peer.\n\n    Args:\n        peer_id: The ID of the peer to send the message to\n        content: The message content\n        is_file: Whether the content is a file\n        filename: The filename, if is_file is True\n\n    Returns:\n        True if message sent successfully, False otherwise\n    \"\"\"\n    logger.debug(f\"Sending message to {peer_id}\")\n\n    # Verify the key exchange is valid\n    if not self.verify_key_exchange_state(peer_id):\n        logger.warning(f\"Key exchange with {peer_id} is not valid or complete\")\n        # Notify about the issue\n        for handler in self.global_message_handlers:\n            try:\n                system_message = Message.system_message(\n                    f\"Cannot send message to {peer_id}: Secure channel not established. Please initiate key exchange.\"\n                )\n                handler(system_message)\n            except Exception as e:\n                logger.error(f\"Error in system message handler: {e}\")\n        return False\n\n    # Make sure we have a shared key\n    if peer_id not in self.shared_keys:\n        logger.info(f\"No shared key with {peer_id}, initiating key exchange\")\n        success = await self.initiate_key_exchange(peer_id)\n        if not success:\n            logger.error(f\"Failed to establish shared key with {peer_id}\")\n            return False\n\n    try:\n        # Get our signature keypair\n        signature_key = self.key_storage.get_key(f\"signature_{self.signature.name}\")\n        if signature_key is None:\n            logger.error(f\"Missing signature keypair for {self.signature.name}\")\n            return False\n\n        # Step 1: Create the message object\n        message = Message(\n            content=content,\n            sender_id=self.node.node_id,\n            recipient_id=peer_id,\n            is_file=is_file,\n            filename=filename,\n            # Include algorithm information in the message\n            key_exchange_algo=self.key_exchange.name,\n            symmetric_algo=self.symmetric.name,\n            signature_algo=self.signature.name\n        )\n\n        # Step 2: Convert to JSON (this is what will be signed)\n        message_json = json.dumps(message.to_dict()).encode()\n\n        # Step 3: Sign the message JSON\n        private_key = signature_key[\"private_key\"]\n        signature = self.signature.sign(private_key, message_json)\n\n        # Step 4: Create signed package (message + signature + public key)\n        signed_package = {\n            \"message\": base64.b64encode(message_json).decode(),\n            \"signature\": base64.b64encode(signature).decode(),\n            \"public_key\": base64.b64encode(signature_key[\"public_key\"]).decode()\n        }\n\n        # Step 5: Serialize the signed package to JSON\n        signed_package_json = json.dumps(signed_package).encode()\n\n        # Step 6: Create AEAD associated data from critical metadata\n        associated_data = json.dumps({\n            \"type\": \"secure_message\",\n            \"message_id\": message.message_id,\n            \"sender_id\": self.node.node_id,\n            \"recipient_id\": peer_id,\n            \"timestamp\": message.timestamp,\n            \"is_file\": is_file,\n        }).encode()\n\n        # Step 7: Encrypt the signed package with AEAD\n        ciphertext = self.symmetric.encrypt(\n            self.shared_keys[peer_id], \n            signed_package_json,\n            associated_data=associated_data\n        )\n\n        # Log the message\n        self.secure_logger.log_event(\n            event_type=\"message_sent\",\n            peer_id=peer_id,\n            message_id=message.message_id,\n            encryption_algorithm=self.symmetric.name,\n            signature_algorithm=self.signature.name,\n            is_file=is_file,\n            size=len(content)\n        )\n\n        # Step 8: Send the encrypted package and associated data\n        success = await self.node.send_message(\n            peer_id=peer_id,\n            message_type=\"secure_message\",\n            ciphertext=base64.b64encode(ciphertext).decode(),\n            associated_data=base64.b64encode(associated_data).decode()\n        )\n\n        if not success:\n            logger.error(f\"Failed to send message to {peer_id}\")\n            return False\n\n        logger.info(f\"Sent secure message to {peer_id}\")\n        return True\n\n    except Exception as e:\n        logger.error(f\"Error sending message to {peer_id}: {e}\")\n        return False\n</code></pre> <code>send_file(peer_id, file_path)</code> <code>async</code> \u00b6 <p>Send a file to a peer using chunked messaging.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <code>str</code> <p>The ID of the peer to send the file to</p> required <code>file_path</code> <code>str</code> <p>The path to the file</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if file sent successfully, False otherwise</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>async def send_file(self, peer_id: str, file_path: str) -&gt; bool:\n    \"\"\"Send a file to a peer using chunked messaging.\n\n    Args:\n        peer_id: The ID of the peer to send the file to\n        file_path: The path to the file\n\n    Returns:\n        True if file sent successfully, False otherwise\n    \"\"\"\n    logger.debug(f\"Sending file {file_path} to {peer_id}\")\n\n    try:\n        # Get file info\n        file_name = os.path.basename(file_path)\n        file_size = os.path.getsize(file_path)\n\n        # Log the transfer\n        self.secure_logger.log_event(\n            event_type=\"message_sent\",\n            peer_id=peer_id,\n            is_file=True,\n            filename=file_name,\n            size=file_size\n        )\n\n        # Read the file\n        with open(file_path, \"rb\") as f:\n            content = f.read()\n\n        # Now send the file data as a secure message\n        # The node's chunking mechanism will handle large files automatically\n        return await self.send_message(peer_id, content, is_file=True, filename=file_name)\n\n    except Exception as e:\n        logger.error(f\"Error sending file {file_path} to {peer_id}: {e}\")\n        return False\n</code></pre> <code>register_message_callback(message_id, callback)</code> \u00b6 <p>Register a callback for a specific message ID.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>str</code> <p>The ID of the message to wait for</p> required <code>callback</code> <code>Callable[[Message], None]</code> <p>The callback function to call when the message is received</p> required Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def register_message_callback(self, message_id: str, \n                           callback: Callable[[Message], None]) -&gt; None:\n    \"\"\"Register a callback for a specific message ID.\n\n    Args:\n        message_id: The ID of the message to wait for\n        callback: The callback function to call when the message is received\n    \"\"\"\n    self.message_callbacks[message_id] = callback\n    logger.debug(f\"Registered callback for message {message_id}\")\n</code></pre> <code>get_peer_crypto_settings(peer_id)</code> \u00b6 <p>Get the cryptography settings of a peer.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <code>str</code> <p>The ID of the peer</p> required <p>Returns:</p> Type Description <code>Optional[Dict[str, str]]</code> <p>Dictionary of peer's cryptography settings, or None if not available</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def get_peer_crypto_settings(self, peer_id: str) -&gt; Optional[Dict[str, str]]:\n    \"\"\"Get the cryptography settings of a peer.\n\n    Args:\n        peer_id: The ID of the peer\n\n    Returns:\n        Dictionary of peer's cryptography settings, or None if not available\n    \"\"\"\n    return self.peer_crypto_settings.get(peer_id)\n</code></pre> <code>set_key_exchange_algorithm(algorithm)</code> \u00b6 <p>Set the key exchange algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>algorithm</code> <code>KeyExchangeAlgorithm</code> <p>The algorithm to use</p> required Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def set_key_exchange_algorithm(self, algorithm: KeyExchangeAlgorithm) -&gt; None:\n    \"\"\"Set the key exchange algorithm.\n\n    Args:\n        algorithm: The algorithm to use\n    \"\"\"\n    # Only take action if the algorithm has actually changed\n    if self.key_exchange.name != algorithm.name:\n        # Store old algorithm name for logging\n        old_algorithm = self.key_exchange.name\n\n        # Update the algorithm\n        self.key_exchange = algorithm\n\n        # Clear all shared keys and key exchange states\n        # This is important - we need to renegotiate with all peers\n        old_peer_ids = list(self.shared_keys.keys())\n        self.shared_keys = {}\n        self.key_exchange_states = {}\n\n        # Log the change\n        logger.info(f\"Changed key exchange algorithm from {old_algorithm} to {self.key_exchange.name}\")\n        self.secure_logger.log_event(\n            event_type=\"crypto_settings_changed\",\n            component=\"key_exchange\",\n            old_algorithm=old_algorithm,\n            new_algorithm=self.key_exchange.name\n        )\n\n        # Notify cryptography settings change listeners\n        self._notify_settings_change()\n\n        # For all connected peers, start key exchange asynchronously\n        for peer_id in old_peer_ids:\n            if peer_id in self.node.get_peers():\n                # Use create_task to start the key exchange asynchronously\n                asyncio.create_task(self.initiate_key_exchange(peer_id))\n                logger.info(f\"Triggered new key exchange with {peer_id} due to algorithm change\")\n\n        # Notify peers about our settings change\n        asyncio.create_task(self.notify_peers_of_settings_change())\n</code></pre> <code>set_symmetric_algorithm(algorithm)</code> \u00b6 <p>Set the symmetric encryption algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>algorithm</code> <code>SymmetricAlgorithm</code> <p>The algorithm to use</p> required Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def set_symmetric_algorithm(self, algorithm: SymmetricAlgorithm) -&gt; None:\n    \"\"\"Set the symmetric encryption algorithm.\n\n    Args:\n        algorithm: The algorithm to use\n    \"\"\"\n    # Only take action if the algorithm has actually changed\n    if self.symmetric.name != algorithm.name:\n        # Store old algorithm name for logging\n        old_algorithm = self.symmetric.name\n\n        # Update the algorithm\n        self.symmetric = algorithm\n\n        # Re-derive keys for all peers with available original shared secrets\n        for peer_id, original_secret in list(self.key_exchange_originals.items()):\n            if peer_id in self.key_exchange_states and self.key_exchange_states[peer_id] == KeyExchangeState.ESTABLISHED:\n                try:\n                    # Derive a new key with the new algorithm's requirements\n                    derived_key = self._derive_symmetric_key(original_secret, peer_id)\n                    self.shared_keys[peer_id] = derived_key\n\n                    # Save the updated key\n                    self._save_peer_key(peer_id, derived_key)\n\n                    logger.info(f\"Re-derived key for peer {peer_id} with new algorithm {self.symmetric.name}\")\n                except Exception as e:\n                    logger.error(f\"Failed to re-derive key for peer {peer_id}: {e}\")\n\n        # Log the change\n        logger.info(f\"Changed symmetric algorithm from {old_algorithm} to {self.symmetric.name}\")\n        self.secure_logger.log_event(\n            event_type=\"crypto_settings_changed\",\n            component=\"symmetric\",\n            old_algorithm=old_algorithm,\n            new_algorithm=self.symmetric.name\n        )\n\n        # Notify cryptography settings change listeners\n        self._notify_settings_change()\n\n        # Notify peers about our settings change\n        asyncio.create_task(self.notify_peers_of_settings_change())\n</code></pre> <code>set_signature_algorithm(algorithm)</code> \u00b6 <p>Set the digital signature algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>algorithm</code> <code>SignatureAlgorithm</code> <p>The algorithm to use</p> required Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def set_signature_algorithm(self, algorithm: SignatureAlgorithm) -&gt; None:\n    \"\"\"Set the digital signature algorithm.\n\n    Args:\n        algorithm: The algorithm to use\n    \"\"\"\n    # Only take action if the algorithm has actually changed\n    if self.signature.name != algorithm.name:\n        # Store old algorithm name for logging\n        old_algorithm = self.signature.name\n\n        # Update the algorithm\n        self.signature = algorithm\n\n        # Generate a keypair if we don't have one\n        signature_key = self.key_storage.get_key(f\"signature_{self.signature.name}\")\n        if signature_key is None:\n            public_key, private_key = self.signature.generate_keypair()\n            signature_key = {\n                \"algorithm\": self.signature.name,\n                \"public_key\": public_key,\n                \"private_key\": private_key\n            }\n            self.key_storage.store_key(f\"signature_{self.signature.name}\", signature_key)\n            logger.info(f\"Generated new signature keypair for {self.signature.name}\")\n\n        # Log the change\n        logger.info(f\"Changed signature algorithm from {old_algorithm} to {self.signature.name}\")\n        self.secure_logger.log_event(\n            event_type=\"crypto_settings_changed\",\n            component=\"signature\",\n            old_algorithm=old_algorithm,\n            new_algorithm=self.signature.name\n        )\n\n        # Notify cryptography settings change listeners\n        self._notify_settings_change()\n\n        # Notify peers about our settings change\n        asyncio.create_task(self.notify_peers_of_settings_change())\n</code></pre> <code>get_security_info()</code> \u00b6 <p>Get information about the current security configuration.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with security information</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def get_security_info(self) -&gt; Dict[str, Any]:\n    \"\"\"Get information about the current security configuration.\n\n    Returns:\n        Dictionary with security information\n    \"\"\"\n    return {\n        \"key_exchange\": {\n            \"algorithm\": self.key_exchange.name,\n            \"security_level\": getattr(self.key_exchange, \"security_level\", 3),\n            \"description\": self.key_exchange.description\n        },\n        \"symmetric\": {\n            \"algorithm\": self.symmetric.name,\n            \"key_size\": self.symmetric.key_size,\n            \"description\": self.symmetric.description\n        },\n        \"signature\": {\n            \"algorithm\": self.signature.name,\n            \"security_level\": getattr(self.signature, \"security_level\", 3),\n            \"description\": self.signature.description\n        },\n        \"peers_with_shared_keys\": len(self.shared_keys)\n    }\n</code></pre> <code>adopt_peer_settings(peer_id)</code> \u00b6 <p>Adopt the cryptography settings of a peer.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <code>str</code> <p>The ID of the peer whose settings to adopt</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if settings were adopted, False otherwise</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def adopt_peer_settings(self, peer_id: str) -&gt; bool:\n    \"\"\"Adopt the cryptography settings of a peer.\n\n    Args:\n        peer_id: The ID of the peer whose settings to adopt\n\n    Returns:\n        True if settings were adopted, False otherwise\n    \"\"\"\n    if peer_id not in self.peer_crypto_settings:\n        logger.error(f\"No settings available for peer {peer_id}\")\n        return False\n\n    peer_settings = self.peer_crypto_settings[peer_id]\n    settings_changed = False\n\n    # Adopt key exchange algorithm if needed\n    key_exchange_algo = peer_settings.get(\"key_exchange\")\n    if key_exchange_algo and key_exchange_algo != self.key_exchange.name:\n        # Map algorithm name to actual algorithm\n        from ..crypto import MLKEMKeyExchange, HQCKeyExchange, FrodoKEMKeyExchange\n\n        if \"ML-KEM\" in key_exchange_algo:\n            # Get the security level from the name\n            if \"Level 1\" in key_exchange_algo:\n                level = 1\n            elif \"Level 3\" in key_exchange_algo:\n                level = 3\n            elif \"Level 5\" in key_exchange_algo:\n                level = 5\n            else:\n                level = 3  # Default\n            algorithm = MLKEMKeyExchange(security_level=level)\n        elif \"HQC\" in key_exchange_algo:\n            # Get the security level from the name\n            if \"Level 1\" in key_exchange_algo:\n                level = 1\n            elif \"Level 3\" in key_exchange_algo:\n                level = 3\n            elif \"Level 5\" in key_exchange_algo:\n                level = 5\n            else:\n                level = 3  # Default\n            algorithm = HQCKeyExchange(security_level=level)\n        elif \"FrodoKEM\" in key_exchange_algo:\n            # Get the security level from the name\n            if \"Level 1\" in key_exchange_algo:\n                level = 1\n            elif \"Level 3\" in key_exchange_algo:\n                level = 3\n            elif \"Level 5\" in key_exchange_algo:\n                level = 5\n            else:\n                level = 3  # Default\n            # Check if it's AES or SHAKE\n            use_aes = \"AES\" in key_exchange_algo\n            algorithm = FrodoKEMKeyExchange(security_level=level, use_aes=use_aes)\n        else:\n            logger.warning(f\"Unknown key exchange algorithm: {key_exchange_algo}\")\n            return False\n\n        self.set_key_exchange_algorithm(algorithm)\n        settings_changed = True\n\n    # Adopt symmetric algorithm if needed\n    symmetric_algo = peer_settings.get(\"symmetric\")\n    if symmetric_algo and symmetric_algo != self.symmetric.name:\n        if symmetric_algo == \"AES-256-GCM\":\n            algorithm = AES256GCM()\n        elif symmetric_algo == \"ChaCha20-Poly1305\":\n            algorithm = ChaCha20Poly1305()\n        else:\n            logger.warning(f\"Unknown symmetric algorithm: {symmetric_algo}\")\n            return False\n\n        self.set_symmetric_algorithm(algorithm)\n        settings_changed = True\n\n    # Adopt signature algorithm if needed\n    signature_algo = peer_settings.get(\"signature\")\n    if signature_algo and signature_algo != self.signature.name:\n        # Map algorithm name to actual algorithm\n        from ..crypto import MLDSASignature, SPHINCSSignature\n\n        if \"ML-DSA\" in signature_algo:\n            # Get the security level from the name\n            if \"Level 2\" in signature_algo:\n                level = 2\n            elif \"Level 3\" in signature_algo:\n                level = 3\n            elif \"Level 5\" in signature_algo:\n                level = 5\n            else:\n                level = 3  # Default\n            algorithm = MLDSASignature(security_level=level)\n        elif \"SPHINCS+\" in signature_algo:\n            # Get the security level from the name\n            if \"Level 1\" in signature_algo:\n                level = 1\n            elif \"Level 3\" in signature_algo:\n                level = 3\n            elif \"Level 5\" in signature_algo:\n                level = 5\n            else:\n                level = 3  # Default\n            algorithm = SPHINCSSignature(security_level=level)\n        else:\n            logger.warning(f\"Unknown signature algorithm: {signature_algo}\")\n            return False\n\n        self.set_signature_algorithm(algorithm)\n        settings_changed = True\n\n    if settings_changed:\n        logger.info(f\"Successfully adopted settings from peer {peer_id}\")\n        return True\n    else:\n        logger.info(f\"No settings changes needed for peer {peer_id}\")\n        return False\n</code></pre> <code>verify_key_exchange_state(peer_id)</code> \u00b6 <p>Verify the key exchange state for a peer.</p> <p>This function checks if a key exchange with a peer is actually valid and properly established, not just assumed from a previous connection.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <code>str</code> <p>The ID of the peer</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the key exchange is valid, False otherwise</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def verify_key_exchange_state(self, peer_id: str) -&gt; bool:\n    \"\"\"Verify the key exchange state for a peer.\n\n    This function checks if a key exchange with a peer is actually valid\n    and properly established, not just assumed from a previous connection.\n\n    Args:\n        peer_id: The ID of the peer\n\n    Returns:\n        True if the key exchange is valid, False otherwise\n    \"\"\"\n    # Check if we have a shared key\n    if peer_id not in self.shared_keys:\n        logger.debug(f\"No shared key exists for peer {peer_id}\")\n        return False\n\n    # Check if the key exchange is in a valid state\n    valid_states = [KeyExchangeState.CONFIRMED, KeyExchangeState.ESTABLISHED]\n    if peer_id not in self.key_exchange_states or self.key_exchange_states[peer_id] not in valid_states:\n        logger.warning(f\"Key exchange with {peer_id} is in an invalid state: \" +\n                      f\"{self.key_exchange_states.get(peer_id, 'NONE')}\")\n        return False\n\n    # Check if the peer is actually connected\n    if peer_id not in self.node.get_peers():\n        logger.warning(f\"Peer {peer_id} has a shared key but is not connected\")\n        return False\n\n    # All checks passed, key exchange is valid\n    return True\n</code></pre>"},{"location":"api/app/#quantum_resistant_p2p.app.Message","title":"<code>Message(content, sender_id, recipient_id=None, message_id=lambda: str(uuid.uuid4())(), timestamp=time.time(), is_file=False, filename=None, signature=None, key_exchange_algo=None, symmetric_algo=None, signature_algo=None, is_system=False)</code>  <code>dataclass</code>","text":"<p>A secure P2P message.</p>"},{"location":"api/app/#quantum_resistant_p2p.app.Message-functions","title":"Functions","text":"<code>to_dict()</code> \u00b6 <p>Convert the message to a dictionary.</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert the message to a dictionary.\"\"\"\n    result = asdict(self)\n    # Convert bytes to base64\n    if isinstance(result['content'], bytes):\n        import base64\n        result['content'] = base64.b64encode(result['content']).decode('utf-8')\n    if result['signature'] is not None:\n        result['signature'] = base64.b64encode(result['signature']).decode('utf-8')\n    return result\n</code></pre> <code>from_dict(data)</code> <code>classmethod</code> \u00b6 <p>Create a message from a dictionary.</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict[str, Any]) -&gt; 'Message':\n    \"\"\"Create a message from a dictionary.\"\"\"\n    # Convert base64 to bytes\n    if 'content' in data and isinstance(data['content'], str):\n        import base64\n        data['content'] = base64.b64decode(data['content'].encode('utf-8'))\n    if 'signature' in data and isinstance(data['signature'], str):\n        data['signature'] = base64.b64decode(data['signature'].encode('utf-8'))\n    return cls(**data)\n</code></pre> <code>system_message(content)</code> <code>classmethod</code> \u00b6 <p>Create a system message.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The message content</p> required <p>Returns:</p> Type Description <code>Message</code> <p>A new system message</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>@classmethod\ndef system_message(cls, content: str) -&gt; 'Message':\n    \"\"\"Create a system message.\n\n    Args:\n        content: The message content\n\n    Returns:\n        A new system message\n    \"\"\"\n    return cls(\n        content=content.encode('utf-8'),\n        sender_id=\"SYSTEM\",\n        is_system=True\n    )\n</code></pre>"},{"location":"api/app/#quantum_resistant_p2p.app.MessageStore","title":"<code>MessageStore()</code>","text":"<p>Store for secure messages to provide persistence and unread count tracking.</p> <p>Initialize a new message store.</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize a new message store.\"\"\"\n    # Maps peer_id -&gt; list of Message objects\n    self.messages = {}\n    # Maps peer_id -&gt; count of unread messages\n    self.unread_counts = {}\n    # Maps peer_id -&gt; timestamp of last message\n    self.last_activity = {}\n    # Current node ID to identify local messages\n    self.current_node_id = None\n</code></pre>"},{"location":"api/app/#quantum_resistant_p2p.app.MessageStore-functions","title":"Functions","text":"<code>add_message(message, mark_as_read=False)</code> \u00b6 <p>Add a message to the store.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <p>The message to store</p> required <code>mark_as_read</code> <p>Whether to mark the message as read immediately</p> <code>False</code> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def add_message(self, message, mark_as_read=False):\n    \"\"\"Add a message to the store.\n\n    Args:\n        message: The message to store\n        mark_as_read: Whether to mark the message as read immediately\n    \"\"\"\n    # Determine the conversation peer_id based on message direction\n    store_peer_id = None\n\n    if hasattr(message, 'recipient_id') and message.recipient_id:\n        if message.sender_id == self.current_node_id:\n            # Outgoing message - use recipient_id as the conversation key\n            store_peer_id = message.recipient_id\n        elif message.recipient_id == self.current_node_id:\n            # Incoming direct message - use sender_id as the conversation key\n            store_peer_id = message.sender_id\n\n    if store_peer_id is None:\n        # Fallback to sender_id if direction can't be determined\n        store_peer_id = message.sender_id\n\n        # Skip system messages that aren't part of a conversation\n        if message.is_system:\n            return\n\n    # Initialize data structures for this peer if needed\n    if store_peer_id not in self.messages:\n        self.messages[store_peer_id] = []\n        self.unread_counts[store_peer_id] = 0\n\n    # Add the message\n    self.messages[store_peer_id].append(message)\n\n    # Update last activity timestamp\n    self.last_activity[store_peer_id] = message.timestamp\n\n    # Increment unread count if not marked as read\n    if not mark_as_read:\n        self.unread_counts[store_peer_id] = self.unread_counts.get(store_peer_id, 0) + 1\n</code></pre> <code>get_messages(peer_id)</code> \u00b6 <p>Get all messages for a peer.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <p>The ID of the peer</p> required <p>Returns:</p> Type Description <p>List of Message objects</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def get_messages(self, peer_id):\n    \"\"\"Get all messages for a peer.\n\n    Args:\n        peer_id: The ID of the peer\n\n    Returns:\n        List of Message objects\n    \"\"\"\n    return self.messages.get(peer_id, [])\n</code></pre> <code>mark_all_read(peer_id)</code> \u00b6 <p>Mark all messages from a peer as read.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <p>The ID of the peer</p> required Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def mark_all_read(self, peer_id):\n    \"\"\"Mark all messages from a peer as read.\n\n    Args:\n        peer_id: The ID of the peer\n    \"\"\"\n    self.unread_counts[peer_id] = 0\n</code></pre> <code>get_unread_count(peer_id)</code> \u00b6 <p>Get the number of unread messages from a peer.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <p>The ID of the peer</p> required <p>Returns:</p> Type Description <p>The number of unread messages</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def get_unread_count(self, peer_id):\n    \"\"\"Get the number of unread messages from a peer.\n\n    Args:\n        peer_id: The ID of the peer\n\n    Returns:\n        The number of unread messages\n    \"\"\"\n    return self.unread_counts.get(peer_id, 0)\n</code></pre> <code>has_unread_messages(peer_id)</code> \u00b6 <p>Check if a peer has any unread messages.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <p>The ID of the peer</p> required <p>Returns:</p> Type Description <p>True if there are unread messages, False otherwise</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def has_unread_messages(self, peer_id):\n    \"\"\"Check if a peer has any unread messages.\n\n    Args:\n        peer_id: The ID of the peer\n\n    Returns:\n        True if there are unread messages, False otherwise\n    \"\"\"\n    return self.get_unread_count(peer_id) &gt; 0\n</code></pre> <code>set_current_node_id(node_id)</code> \u00b6 <p>Set the current node ID for determining message direction.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <p>The ID of the current node</p> required Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def set_current_node_id(self, node_id):\n    \"\"\"Set the current node ID for determining message direction.\n\n    Args:\n        node_id: The ID of the current node\n    \"\"\"\n    self.current_node_id = node_id\n</code></pre>"},{"location":"api/app/#quantum_resistant_p2p.app.SecureLogger","title":"<code>SecureLogger(log_path=None, encryption_key=None)</code>","text":"<p>Secure logging for cryptographic operations with improved reliability.</p> <p>This class provides functionality to securely log cryptographic operations including key exchanges, message transfers, and security-related events, with enhanced safeguards against file corruption.</p> <p>Initialize a new secure logger.</p> <p>Parameters:</p> Name Type Description Default <code>log_path</code> <code>Optional[str]</code> <p>Path to the log directory. If None, uses      ~/.quantum_resistant_p2p/logs/</p> <code>None</code> <code>encryption_key</code> <code>Optional[bytes]</code> <p>Encryption key to use. Must be provided for proper operation.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no encryption key is provided</p> Source code in <code>quantum_resistant_p2p\\app\\logging.py</code> <pre><code>def __init__(self, log_path: Optional[str] = None, encryption_key: Optional[bytes] = None):\n    \"\"\"Initialize a new secure logger.\n\n    Args:\n        log_path: Path to the log directory. If None, uses\n                 ~/.quantum_resistant_p2p/logs/\n        encryption_key: Encryption key to use. Must be provided for proper operation.\n\n    Raises:\n        ValueError: If no encryption key is provided\n    \"\"\"\n    if encryption_key is None:\n        raise ValueError(\"Encryption key must be provided to SecureLogger\")\n\n    if log_path is None:\n        # Use default path in user's home directory\n        home_dir = Path.home()\n        log_dir = home_dir / \".quantum_resistant_p2p\" / \"logs\"\n        log_dir.mkdir(exist_ok=True, parents=True)\n        self.log_path = log_dir\n    else:\n        self.log_path = Path(log_path)\n        # Make sure directory exists\n        self.log_path.mkdir(exist_ok=True, parents=True)\n\n    # Store the provided encryption key\n    self.encryption_key = encryption_key\n\n    # Create a single cipher instance for consistency\n    self.cipher = AES256GCM()\n\n    # Create a lock for thread safety\n    self.lock = threading.RLock()\n\n    # Compile regex for valid log filenames (YYYY-MM-DD.log)\n    self.log_filename_pattern = re.compile(r'^\\d{4}-\\d{2}-\\d{2}\\.log$')\n\n    # Track if we're already inside an error handler to prevent recursion\n    self._in_error_handler = False\n\n    logger.info(f\"Secure logger initialized at {self.log_path}\")\n</code></pre>"},{"location":"api/app/#quantum_resistant_p2p.app.SecureLogger-functions","title":"Functions","text":"<code>log_event(event_type, **kwargs)</code> \u00b6 <p>Log a security-related event.</p> <p>Parameters:</p> Name Type Description Default <code>event_type</code> <code>str</code> <p>The type of event</p> required <code>**kwargs</code> <p>Additional event data</p> <code>{}</code> Source code in <code>quantum_resistant_p2p\\app\\logging.py</code> <pre><code>def log_event(self, event_type: str, **kwargs) -&gt; None:\n    \"\"\"Log a security-related event.\n\n    Args:\n        event_type: The type of event\n        **kwargs: Additional event data\n    \"\"\"\n    # Use a lock to ensure thread safety\n    with self.lock:\n        try:\n            # Create the log entry\n            entry = {\n                \"timestamp\": time.time(),\n                \"type\": event_type,\n                **kwargs\n            }\n\n            # Get the current date for the log file name\n            date_str = datetime.datetime.now().strftime(\"%Y-%m-%d\")\n            log_file_path = self.log_path / f\"{date_str}.log\"\n\n            # Create a SecureFile instance for this log file\n            log_file = SecureFile(log_file_path)\n\n            # Encrypt the log entry\n            entry_json = json.dumps(entry).encode()\n            encrypted_entry = self.cipher.encrypt(self.encryption_key, entry_json)\n\n            # Create the complete record (length + encrypted data)\n            length = len(encrypted_entry).to_bytes(4, byteorder=\"big\")\n            record = length + encrypted_entry\n\n            # Write to the log file\n            success = log_file.append_bytes(record)\n\n            if success:\n                logger.debug(f\"Logged {event_type} event\")\n            else:\n                self._safe_error(f\"Failed to write {event_type} event to log\")\n\n        except Exception as e:\n            self._safe_error(f\"Failed to log event: {e}\")\n</code></pre> <code>get_events(start_time=None, end_time=None, event_type=None, limit=None)</code> \u00b6 <p>Get events from the log.</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>Optional[float]</code> <p>Only include events after this timestamp</p> <code>None</code> <code>end_time</code> <code>Optional[float]</code> <p>Only include events before this timestamp</p> <code>None</code> <code>event_type</code> <code>Optional[str]</code> <p>Only include events of this type</p> <code>None</code> <code>limit</code> <code>Optional[int]</code> <p>Maximum number of events to return</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of log entries</p> Source code in <code>quantum_resistant_p2p\\app\\logging.py</code> <pre><code>def get_events(self, start_time: Optional[float] = None, \n               end_time: Optional[float] = None,\n               event_type: Optional[str] = None,\n               limit: Optional[int] = None) -&gt; List[Dict[str, Any]]:\n    \"\"\"Get events from the log.\n\n    Args:\n        start_time: Only include events after this timestamp\n        end_time: Only include events before this timestamp\n        event_type: Only include events of this type\n        limit: Maximum number of events to return\n\n    Returns:\n        List of log entries\n    \"\"\"\n    events = []\n    error_count = 0\n    MAX_ERRORS = 5  # Stop after this many consecutive errors per file\n    ENTRY_SIZE_LIMIT = 100_000  # Reasonable max size for an entry (100KB)\n\n    # Get all log files that match our date pattern\n    try:\n        # Filter to only include correctly formatted log files (YYYY-MM-DD.log)\n        log_files = []\n        for file in self.log_path.glob(\"*.log\"):\n            if self.log_filename_pattern.match(file.name):\n                log_files.append(file)\n        log_files.sort()  # Sort by date\n    except Exception as e:\n        self._safe_error(f\"Error listing log files: {e}\")\n        return []\n\n    # Determine date range if timestamps are provided\n    if start_time is not None:\n        start_date = datetime.datetime.fromtimestamp(start_time).strftime(\"%Y-%m-%d\")\n        log_files = [f for f in log_files if f.name &gt;= f\"{start_date}.log\"]\n\n    if end_time is not None:\n        end_date = datetime.datetime.fromtimestamp(end_time).strftime(\"%Y-%m-%d\")\n        log_files = [f for f in log_files if f.name &lt;= f\"{end_date}.log\"]\n\n    # Process each log file\n    for log_file_path in log_files:\n        try:\n            if not log_file_path.exists() or not log_file_path.is_file():\n                continue\n\n            # Skip empty files\n            if log_file_path.stat().st_size == 0:\n                continue\n\n            # Use SecureFile to read the entire file at once\n            log_file = SecureFile(log_file_path)\n            file_data = log_file.read_bytes()\n\n            if not file_data:\n                continue\n\n            # Reset error count for each file\n            error_count = 0\n            position = 0\n\n            while position &lt; len(file_data):\n                # Check if we've reached the limit\n                if limit is not None and len(events) &gt;= limit:\n                    break\n\n                # Try to read length of encrypted entry\n                if position + 4 &gt; len(file_data):\n                    break  # End of file\n\n                try:\n                    length = int.from_bytes(file_data[position:position + 4], byteorder=\"big\")\n\n                    # Sanity check - make sure length is reasonable\n                    if length &lt;= 0 or length &gt; ENTRY_SIZE_LIMIT:\n                        self._safe_error(f\"Invalid entry length in {log_file_path.name}: {length}\")\n\n                        # Try to recover from corruption\n                        success, new_position = self._recover_from_corruption(file_data, position)\n                        if success:\n                            # Recovery found a valid entry, continue processing\n                            position = new_position\n                            continue\n                        else:\n                            # Could not recover, skip this file\n                            break\n\n                    # Ensure we have enough data\n                    if position + 4 + length &gt; len(file_data):\n                        self._safe_error(f\"Incomplete entry in {log_file_path.name}\")\n                        break\n\n                    # Read the encrypted entry\n                    encrypted_entry = file_data[position + 4:position + 4 + length]\n\n                    # Reset error count on successful read\n                    error_count = 0\n\n                    # Decrypt the entry\n                    entry_json = self.cipher.decrypt(self.encryption_key, encrypted_entry)\n                    entry = json.loads(entry_json.decode())\n\n                    # Filter by timestamp and event type\n                    if start_time is not None and entry[\"timestamp\"] &lt; start_time:\n                        position += 4 + length\n                        continue\n                    if end_time is not None and entry[\"timestamp\"] &gt; end_time:\n                        position += 4 + length\n                        continue\n                    if event_type is not None and entry[\"type\"] != event_type:\n                        position += 4 + length\n                        continue\n\n                    events.append(entry)\n\n                    # Move to next entry\n                    position += 4 + length\n\n                except Exception as e:\n                    error_count += 1\n                    self._safe_error(f\"Failed to process log entry in {log_file_path.name} at position {position}: {e}\")\n\n                    # Try to recover from corruption\n                    success, new_position = self._recover_from_corruption(file_data, position)\n                    if success:\n                        # Recovery worked, reset error count\n                        error_count = 0\n                        position = new_position\n                        continue\n                    else:\n                        # Move ahead a byte and try again\n                        position += 1\n\n                    # Stop trying if we hit too many errors in a row\n                    if error_count &gt;= MAX_ERRORS:\n                        self._safe_error(f\"Too many consecutive errors ({MAX_ERRORS}) in {log_file_path.name}, stopping log processing\")\n                        break\n\n        except Exception as e:\n            self._safe_error(f\"Error reading log file {log_file_path}: {e}\")\n\n    # Sort events by timestamp\n    events.sort(key=lambda e: e[\"timestamp\"])\n\n    return events\n</code></pre> <code>get_event_summary(start_time=None, end_time=None)</code> \u00b6 <p>Get a summary of events by type.</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>Optional[float]</code> <p>Only include events after this timestamp</p> <code>None</code> <code>end_time</code> <code>Optional[float]</code> <p>Only include events before this timestamp</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>Dictionary mapping event types to counts</p> Source code in <code>quantum_resistant_p2p\\app\\logging.py</code> <pre><code>def get_event_summary(self, start_time: Optional[float] = None,\n                      end_time: Optional[float] = None) -&gt; Dict[str, int]:\n    \"\"\"Get a summary of events by type.\n\n    Args:\n        start_time: Only include events after this timestamp\n        end_time: Only include events before this timestamp\n\n    Returns:\n        Dictionary mapping event types to counts\n    \"\"\"\n    # Get events with a reasonable limit to avoid issues with corrupted files\n    events = self.get_events(start_time, end_time, limit=1000)\n\n    summary = {}\n    for event in events:\n        event_type = event[\"type\"]\n        if event_type not in summary:\n            summary[event_type] = 0\n        summary[event_type] += 1\n\n    return summary\n</code></pre> <code>get_security_metrics()</code> \u00b6 <p>Get security metrics based on the logs.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary of security metrics</p> Source code in <code>quantum_resistant_p2p\\app\\logging.py</code> <pre><code>def get_security_metrics(self) -&gt; Dict[str, Any]:\n    \"\"\"Get security metrics based on the logs.\n\n    Returns:\n        Dictionary of security metrics\n    \"\"\"\n    # Get events with a reasonable limit to avoid issues with corrupted files\n    events = self.get_events(limit=1000)\n\n    # Calculate metrics\n    metrics = {\n        \"total_events\": len(events),\n        \"key_exchanges\": 0,\n        \"messages_sent\": 0,\n        \"messages_received\": 0,\n        \"files_transferred\": 0,\n        \"total_bytes_transferred\": 0,\n        \"algorithms_used\": {},\n        \"first_event_time\": None,\n        \"last_event_time\": None\n    }\n\n    for event in events:\n        event_type = event[\"type\"]\n\n        # Update time range\n        if metrics[\"first_event_time\"] is None or event[\"timestamp\"] &lt; metrics[\"first_event_time\"]:\n            metrics[\"first_event_time\"] = event[\"timestamp\"]\n        if metrics[\"last_event_time\"] is None or event[\"timestamp\"] &gt; metrics[\"last_event_time\"]:\n            metrics[\"last_event_time\"] = event[\"timestamp\"]\n\n        # Update event counts\n        if event_type == \"key_exchange\":\n            metrics[\"key_exchanges\"] += 1\n        elif event_type == \"message_sent\":\n            metrics[\"messages_sent\"] += 1\n            if event.get(\"is_file\", False):\n                metrics[\"files_transferred\"] += 1\n            metrics[\"total_bytes_transferred\"] += event.get(\"size\", 0)\n        elif event_type == \"message_received\":\n            metrics[\"messages_received\"] += 1\n            if event.get(\"is_file\", False):\n                metrics[\"files_transferred\"] += 1\n            metrics[\"total_bytes_transferred\"] += event.get(\"size\", 0)\n\n        # Track algorithms used\n        for key in [\"encryption_algorithm\", \"signature_algorithm\", \"algorithm\"]:\n            if key in event:\n                algorithm = event[key]\n                if algorithm not in metrics[\"algorithms_used\"]:\n                    metrics[\"algorithms_used\"][algorithm] = 0\n                metrics[\"algorithms_used\"][algorithm] += 1\n\n    return metrics\n</code></pre> <code>clear_logs()</code> \u00b6 <p>Clear all logs.</p> <p>This is a destructive operation and should be used with caution.</p> Source code in <code>quantum_resistant_p2p\\app\\logging.py</code> <pre><code>def clear_logs(self) -&gt; None:\n    \"\"\"Clear all logs.\n\n    This is a destructive operation and should be used with caution.\n    \"\"\"\n    # Use a lock to ensure thread safety\n    with self.lock:\n        # Only clear files that match our date pattern\n        for log_file_path in self.log_path.glob(\"*.log\"):\n            if self.log_filename_pattern.match(log_file_path.name):\n                try:\n                    os.remove(log_file_path)\n                    logger.debug(f\"Removed log file {log_file_path}\")\n                except Exception as e:\n                    self._safe_error(f\"Failed to remove log file {log_file_path}: {e}\")\n\n        logger.info(\"Cleared all logs\")\n</code></pre>"},{"location":"api/app/logging/","title":"Secure Logging Module","text":"<p>Secure logging for cryptographic operations using unified file protection. This module provides functionality to securely log cryptographic operations including key exchanges, message transfers, and security-related events.</p>"},{"location":"api/app/logging/#quantum_resistant_p2p.app.logging","title":"<code>quantum_resistant_p2p.app.logging</code>","text":"<p>Secure logging for cryptographic operations using unified file protection.</p>"},{"location":"api/app/logging/#quantum_resistant_p2p.app.logging-classes","title":"Classes","text":""},{"location":"api/app/logging/#quantum_resistant_p2p.app.logging.SecureLogger","title":"<code>SecureLogger(log_path=None, encryption_key=None)</code>","text":"<p>Secure logging for cryptographic operations with improved reliability.</p> <p>This class provides functionality to securely log cryptographic operations including key exchanges, message transfers, and security-related events, with enhanced safeguards against file corruption.</p> <p>Initialize a new secure logger.</p> <p>Parameters:</p> Name Type Description Default <code>log_path</code> <code>Optional[str]</code> <p>Path to the log directory. If None, uses      ~/.quantum_resistant_p2p/logs/</p> <code>None</code> <code>encryption_key</code> <code>Optional[bytes]</code> <p>Encryption key to use. Must be provided for proper operation.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no encryption key is provided</p> Source code in <code>quantum_resistant_p2p\\app\\logging.py</code> <pre><code>def __init__(self, log_path: Optional[str] = None, encryption_key: Optional[bytes] = None):\n    \"\"\"Initialize a new secure logger.\n\n    Args:\n        log_path: Path to the log directory. If None, uses\n                 ~/.quantum_resistant_p2p/logs/\n        encryption_key: Encryption key to use. Must be provided for proper operation.\n\n    Raises:\n        ValueError: If no encryption key is provided\n    \"\"\"\n    if encryption_key is None:\n        raise ValueError(\"Encryption key must be provided to SecureLogger\")\n\n    if log_path is None:\n        # Use default path in user's home directory\n        home_dir = Path.home()\n        log_dir = home_dir / \".quantum_resistant_p2p\" / \"logs\"\n        log_dir.mkdir(exist_ok=True, parents=True)\n        self.log_path = log_dir\n    else:\n        self.log_path = Path(log_path)\n        # Make sure directory exists\n        self.log_path.mkdir(exist_ok=True, parents=True)\n\n    # Store the provided encryption key\n    self.encryption_key = encryption_key\n\n    # Create a single cipher instance for consistency\n    self.cipher = AES256GCM()\n\n    # Create a lock for thread safety\n    self.lock = threading.RLock()\n\n    # Compile regex for valid log filenames (YYYY-MM-DD.log)\n    self.log_filename_pattern = re.compile(r'^\\d{4}-\\d{2}-\\d{2}\\.log$')\n\n    # Track if we're already inside an error handler to prevent recursion\n    self._in_error_handler = False\n\n    logger.info(f\"Secure logger initialized at {self.log_path}\")\n</code></pre>"},{"location":"api/app/logging/#quantum_resistant_p2p.app.logging.SecureLogger-functions","title":"Functions","text":"<code>log_event(event_type, **kwargs)</code> \u00b6 <p>Log a security-related event.</p> <p>Parameters:</p> Name Type Description Default <code>event_type</code> <code>str</code> <p>The type of event</p> required <code>**kwargs</code> <p>Additional event data</p> <code>{}</code> Source code in <code>quantum_resistant_p2p\\app\\logging.py</code> <pre><code>def log_event(self, event_type: str, **kwargs) -&gt; None:\n    \"\"\"Log a security-related event.\n\n    Args:\n        event_type: The type of event\n        **kwargs: Additional event data\n    \"\"\"\n    # Use a lock to ensure thread safety\n    with self.lock:\n        try:\n            # Create the log entry\n            entry = {\n                \"timestamp\": time.time(),\n                \"type\": event_type,\n                **kwargs\n            }\n\n            # Get the current date for the log file name\n            date_str = datetime.datetime.now().strftime(\"%Y-%m-%d\")\n            log_file_path = self.log_path / f\"{date_str}.log\"\n\n            # Create a SecureFile instance for this log file\n            log_file = SecureFile(log_file_path)\n\n            # Encrypt the log entry\n            entry_json = json.dumps(entry).encode()\n            encrypted_entry = self.cipher.encrypt(self.encryption_key, entry_json)\n\n            # Create the complete record (length + encrypted data)\n            length = len(encrypted_entry).to_bytes(4, byteorder=\"big\")\n            record = length + encrypted_entry\n\n            # Write to the log file\n            success = log_file.append_bytes(record)\n\n            if success:\n                logger.debug(f\"Logged {event_type} event\")\n            else:\n                self._safe_error(f\"Failed to write {event_type} event to log\")\n\n        except Exception as e:\n            self._safe_error(f\"Failed to log event: {e}\")\n</code></pre> <code>get_events(start_time=None, end_time=None, event_type=None, limit=None)</code> \u00b6 <p>Get events from the log.</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>Optional[float]</code> <p>Only include events after this timestamp</p> <code>None</code> <code>end_time</code> <code>Optional[float]</code> <p>Only include events before this timestamp</p> <code>None</code> <code>event_type</code> <code>Optional[str]</code> <p>Only include events of this type</p> <code>None</code> <code>limit</code> <code>Optional[int]</code> <p>Maximum number of events to return</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of log entries</p> Source code in <code>quantum_resistant_p2p\\app\\logging.py</code> <pre><code>def get_events(self, start_time: Optional[float] = None, \n               end_time: Optional[float] = None,\n               event_type: Optional[str] = None,\n               limit: Optional[int] = None) -&gt; List[Dict[str, Any]]:\n    \"\"\"Get events from the log.\n\n    Args:\n        start_time: Only include events after this timestamp\n        end_time: Only include events before this timestamp\n        event_type: Only include events of this type\n        limit: Maximum number of events to return\n\n    Returns:\n        List of log entries\n    \"\"\"\n    events = []\n    error_count = 0\n    MAX_ERRORS = 5  # Stop after this many consecutive errors per file\n    ENTRY_SIZE_LIMIT = 100_000  # Reasonable max size for an entry (100KB)\n\n    # Get all log files that match our date pattern\n    try:\n        # Filter to only include correctly formatted log files (YYYY-MM-DD.log)\n        log_files = []\n        for file in self.log_path.glob(\"*.log\"):\n            if self.log_filename_pattern.match(file.name):\n                log_files.append(file)\n        log_files.sort()  # Sort by date\n    except Exception as e:\n        self._safe_error(f\"Error listing log files: {e}\")\n        return []\n\n    # Determine date range if timestamps are provided\n    if start_time is not None:\n        start_date = datetime.datetime.fromtimestamp(start_time).strftime(\"%Y-%m-%d\")\n        log_files = [f for f in log_files if f.name &gt;= f\"{start_date}.log\"]\n\n    if end_time is not None:\n        end_date = datetime.datetime.fromtimestamp(end_time).strftime(\"%Y-%m-%d\")\n        log_files = [f for f in log_files if f.name &lt;= f\"{end_date}.log\"]\n\n    # Process each log file\n    for log_file_path in log_files:\n        try:\n            if not log_file_path.exists() or not log_file_path.is_file():\n                continue\n\n            # Skip empty files\n            if log_file_path.stat().st_size == 0:\n                continue\n\n            # Use SecureFile to read the entire file at once\n            log_file = SecureFile(log_file_path)\n            file_data = log_file.read_bytes()\n\n            if not file_data:\n                continue\n\n            # Reset error count for each file\n            error_count = 0\n            position = 0\n\n            while position &lt; len(file_data):\n                # Check if we've reached the limit\n                if limit is not None and len(events) &gt;= limit:\n                    break\n\n                # Try to read length of encrypted entry\n                if position + 4 &gt; len(file_data):\n                    break  # End of file\n\n                try:\n                    length = int.from_bytes(file_data[position:position + 4], byteorder=\"big\")\n\n                    # Sanity check - make sure length is reasonable\n                    if length &lt;= 0 or length &gt; ENTRY_SIZE_LIMIT:\n                        self._safe_error(f\"Invalid entry length in {log_file_path.name}: {length}\")\n\n                        # Try to recover from corruption\n                        success, new_position = self._recover_from_corruption(file_data, position)\n                        if success:\n                            # Recovery found a valid entry, continue processing\n                            position = new_position\n                            continue\n                        else:\n                            # Could not recover, skip this file\n                            break\n\n                    # Ensure we have enough data\n                    if position + 4 + length &gt; len(file_data):\n                        self._safe_error(f\"Incomplete entry in {log_file_path.name}\")\n                        break\n\n                    # Read the encrypted entry\n                    encrypted_entry = file_data[position + 4:position + 4 + length]\n\n                    # Reset error count on successful read\n                    error_count = 0\n\n                    # Decrypt the entry\n                    entry_json = self.cipher.decrypt(self.encryption_key, encrypted_entry)\n                    entry = json.loads(entry_json.decode())\n\n                    # Filter by timestamp and event type\n                    if start_time is not None and entry[\"timestamp\"] &lt; start_time:\n                        position += 4 + length\n                        continue\n                    if end_time is not None and entry[\"timestamp\"] &gt; end_time:\n                        position += 4 + length\n                        continue\n                    if event_type is not None and entry[\"type\"] != event_type:\n                        position += 4 + length\n                        continue\n\n                    events.append(entry)\n\n                    # Move to next entry\n                    position += 4 + length\n\n                except Exception as e:\n                    error_count += 1\n                    self._safe_error(f\"Failed to process log entry in {log_file_path.name} at position {position}: {e}\")\n\n                    # Try to recover from corruption\n                    success, new_position = self._recover_from_corruption(file_data, position)\n                    if success:\n                        # Recovery worked, reset error count\n                        error_count = 0\n                        position = new_position\n                        continue\n                    else:\n                        # Move ahead a byte and try again\n                        position += 1\n\n                    # Stop trying if we hit too many errors in a row\n                    if error_count &gt;= MAX_ERRORS:\n                        self._safe_error(f\"Too many consecutive errors ({MAX_ERRORS}) in {log_file_path.name}, stopping log processing\")\n                        break\n\n        except Exception as e:\n            self._safe_error(f\"Error reading log file {log_file_path}: {e}\")\n\n    # Sort events by timestamp\n    events.sort(key=lambda e: e[\"timestamp\"])\n\n    return events\n</code></pre> <code>get_event_summary(start_time=None, end_time=None)</code> \u00b6 <p>Get a summary of events by type.</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>Optional[float]</code> <p>Only include events after this timestamp</p> <code>None</code> <code>end_time</code> <code>Optional[float]</code> <p>Only include events before this timestamp</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>Dictionary mapping event types to counts</p> Source code in <code>quantum_resistant_p2p\\app\\logging.py</code> <pre><code>def get_event_summary(self, start_time: Optional[float] = None,\n                      end_time: Optional[float] = None) -&gt; Dict[str, int]:\n    \"\"\"Get a summary of events by type.\n\n    Args:\n        start_time: Only include events after this timestamp\n        end_time: Only include events before this timestamp\n\n    Returns:\n        Dictionary mapping event types to counts\n    \"\"\"\n    # Get events with a reasonable limit to avoid issues with corrupted files\n    events = self.get_events(start_time, end_time, limit=1000)\n\n    summary = {}\n    for event in events:\n        event_type = event[\"type\"]\n        if event_type not in summary:\n            summary[event_type] = 0\n        summary[event_type] += 1\n\n    return summary\n</code></pre> <code>get_security_metrics()</code> \u00b6 <p>Get security metrics based on the logs.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary of security metrics</p> Source code in <code>quantum_resistant_p2p\\app\\logging.py</code> <pre><code>def get_security_metrics(self) -&gt; Dict[str, Any]:\n    \"\"\"Get security metrics based on the logs.\n\n    Returns:\n        Dictionary of security metrics\n    \"\"\"\n    # Get events with a reasonable limit to avoid issues with corrupted files\n    events = self.get_events(limit=1000)\n\n    # Calculate metrics\n    metrics = {\n        \"total_events\": len(events),\n        \"key_exchanges\": 0,\n        \"messages_sent\": 0,\n        \"messages_received\": 0,\n        \"files_transferred\": 0,\n        \"total_bytes_transferred\": 0,\n        \"algorithms_used\": {},\n        \"first_event_time\": None,\n        \"last_event_time\": None\n    }\n\n    for event in events:\n        event_type = event[\"type\"]\n\n        # Update time range\n        if metrics[\"first_event_time\"] is None or event[\"timestamp\"] &lt; metrics[\"first_event_time\"]:\n            metrics[\"first_event_time\"] = event[\"timestamp\"]\n        if metrics[\"last_event_time\"] is None or event[\"timestamp\"] &gt; metrics[\"last_event_time\"]:\n            metrics[\"last_event_time\"] = event[\"timestamp\"]\n\n        # Update event counts\n        if event_type == \"key_exchange\":\n            metrics[\"key_exchanges\"] += 1\n        elif event_type == \"message_sent\":\n            metrics[\"messages_sent\"] += 1\n            if event.get(\"is_file\", False):\n                metrics[\"files_transferred\"] += 1\n            metrics[\"total_bytes_transferred\"] += event.get(\"size\", 0)\n        elif event_type == \"message_received\":\n            metrics[\"messages_received\"] += 1\n            if event.get(\"is_file\", False):\n                metrics[\"files_transferred\"] += 1\n            metrics[\"total_bytes_transferred\"] += event.get(\"size\", 0)\n\n        # Track algorithms used\n        for key in [\"encryption_algorithm\", \"signature_algorithm\", \"algorithm\"]:\n            if key in event:\n                algorithm = event[key]\n                if algorithm not in metrics[\"algorithms_used\"]:\n                    metrics[\"algorithms_used\"][algorithm] = 0\n                metrics[\"algorithms_used\"][algorithm] += 1\n\n    return metrics\n</code></pre> <code>clear_logs()</code> \u00b6 <p>Clear all logs.</p> <p>This is a destructive operation and should be used with caution.</p> Source code in <code>quantum_resistant_p2p\\app\\logging.py</code> <pre><code>def clear_logs(self) -&gt; None:\n    \"\"\"Clear all logs.\n\n    This is a destructive operation and should be used with caution.\n    \"\"\"\n    # Use a lock to ensure thread safety\n    with self.lock:\n        # Only clear files that match our date pattern\n        for log_file_path in self.log_path.glob(\"*.log\"):\n            if self.log_filename_pattern.match(log_file_path.name):\n                try:\n                    os.remove(log_file_path)\n                    logger.debug(f\"Removed log file {log_file_path}\")\n                except Exception as e:\n                    self._safe_error(f\"Failed to remove log file {log_file_path}: {e}\")\n\n        logger.info(\"Cleared all logs\")\n</code></pre>"},{"location":"api/app/messaging/","title":"Messaging Module","text":"<p>Secure messaging functionality for the P2P application. This module provides high-level functionality for secure messaging, including key exchange, encryption, and digital signatures.</p>"},{"location":"api/app/messaging/#quantum_resistant_p2p.app.messaging","title":"<code>quantum_resistant_p2p.app.messaging</code>","text":"<p>Secure messaging functionality for the P2P application.</p>"},{"location":"api/app/messaging/#quantum_resistant_p2p.app.messaging-classes","title":"Classes","text":""},{"location":"api/app/messaging/#quantum_resistant_p2p.app.messaging.Message","title":"<code>Message(content, sender_id, recipient_id=None, message_id=lambda: str(uuid.uuid4())(), timestamp=time.time(), is_file=False, filename=None, signature=None, key_exchange_algo=None, symmetric_algo=None, signature_algo=None, is_system=False)</code>  <code>dataclass</code>","text":"<p>A secure P2P message.</p>"},{"location":"api/app/messaging/#quantum_resistant_p2p.app.messaging.Message-functions","title":"Functions","text":"<code>to_dict()</code> \u00b6 <p>Convert the message to a dictionary.</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert the message to a dictionary.\"\"\"\n    result = asdict(self)\n    # Convert bytes to base64\n    if isinstance(result['content'], bytes):\n        import base64\n        result['content'] = base64.b64encode(result['content']).decode('utf-8')\n    if result['signature'] is not None:\n        result['signature'] = base64.b64encode(result['signature']).decode('utf-8')\n    return result\n</code></pre> <code>from_dict(data)</code> <code>classmethod</code> \u00b6 <p>Create a message from a dictionary.</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict[str, Any]) -&gt; 'Message':\n    \"\"\"Create a message from a dictionary.\"\"\"\n    # Convert base64 to bytes\n    if 'content' in data and isinstance(data['content'], str):\n        import base64\n        data['content'] = base64.b64decode(data['content'].encode('utf-8'))\n    if 'signature' in data and isinstance(data['signature'], str):\n        data['signature'] = base64.b64decode(data['signature'].encode('utf-8'))\n    return cls(**data)\n</code></pre> <code>system_message(content)</code> <code>classmethod</code> \u00b6 <p>Create a system message.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The message content</p> required <p>Returns:</p> Type Description <code>Message</code> <p>A new system message</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>@classmethod\ndef system_message(cls, content: str) -&gt; 'Message':\n    \"\"\"Create a system message.\n\n    Args:\n        content: The message content\n\n    Returns:\n        A new system message\n    \"\"\"\n    return cls(\n        content=content.encode('utf-8'),\n        sender_id=\"SYSTEM\",\n        is_system=True\n    )\n</code></pre>"},{"location":"api/app/messaging/#quantum_resistant_p2p.app.messaging.KeyExchangeState","title":"<code>KeyExchangeState</code>","text":"<p>State of a key exchange with a peer.</p>"},{"location":"api/app/messaging/#quantum_resistant_p2p.app.messaging.SecureMessaging","title":"<code>SecureMessaging(node, key_storage, logger, key_exchange_algorithm=None, symmetric_algorithm=None, signature_algorithm=None)</code>","text":"<p>Secure messaging functionality using post-quantum cryptography.</p> <p>This class provides high-level functionality for secure messaging, including key exchange, encryption, and digital signatures.</p> <p>Initialize secure messaging functionality.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>P2PNode</code> <p>The P2P node for communication</p> required <code>key_storage</code> <code>KeyStorage</code> <p>The key storage for cryptographic keys</p> required <code>logger</code> <code>SecureLogger</code> <p>The secure logger for logging events</p> required <code>key_exchange_algorithm</code> <code>Optional[KeyExchangeAlgorithm]</code> <p>The algorithm to use for key exchange</p> <code>None</code> <code>symmetric_algorithm</code> <code>Optional[SymmetricAlgorithm]</code> <p>The algorithm to use for symmetric encryption</p> <code>None</code> <code>signature_algorithm</code> <code>Optional[SignatureAlgorithm]</code> <p>The algorithm to use for digital signatures</p> <code>None</code> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def __init__(self, \n             node: P2PNode,\n             key_storage: KeyStorage,\n             logger: SecureLogger,\n             key_exchange_algorithm: Optional[KeyExchangeAlgorithm] = None,\n             symmetric_algorithm: Optional[SymmetricAlgorithm] = None,\n             signature_algorithm: Optional[SignatureAlgorithm] = None):\n    \"\"\"Initialize secure messaging functionality.\n\n    Args:\n        node: The P2P node for communication\n        key_storage: The key storage for cryptographic keys\n        logger: The secure logger for logging events\n        key_exchange_algorithm: The algorithm to use for key exchange\n        symmetric_algorithm: The algorithm to use for symmetric encryption\n        signature_algorithm: The algorithm to use for digital signatures\n    \"\"\"\n    self.node = node\n    self.key_storage = key_storage\n    self.secure_logger = logger  # Rename to avoid conflict with global logger\n\n    # Use default algorithms if not specified\n    self.key_exchange = key_exchange_algorithm or MLKEMKeyExchange()\n    self.symmetric = symmetric_algorithm or AES256GCM()\n    self.signature = signature_algorithm or MLDSASignature()\n\n    # Dictionary mapping peer IDs to shared symmetric keys\n    self.shared_keys: Dict[str, bytes] = {}\n\n    # Dictionary mapping peer IDs to original shared secrets (before derivation)\n    self.key_exchange_originals: Dict[str, bytes] = {}\n\n    # Dictionary mapping peer IDs to key exchange states\n    self.key_exchange_states: Dict[str, int] = {}\n\n    # Dictionary mapping message IDs to callbacks for received messages\n    self.message_callbacks: Dict[str, Callable[[Any], None]] = {}\n\n    # List of global message handlers\n    self.global_message_handlers: List[Callable[[Message], None]] = []\n\n    # List of settings change listeners\n    self.settings_change_listeners: List[Callable[[], None]] = []\n\n    # Store peer crypto settings\n    self.peer_crypto_settings: Dict[str, Dict[str, str]] = {}\n\n    # Track processed message IDs to prevent duplicates\n    self.processed_message_ids = set()\n\n    # Register message handlers\n    self.node.register_message_handler(\"key_exchange_init\", self._handle_key_exchange_init)\n    self.node.register_message_handler(\"key_exchange_response\", self._handle_key_exchange_response)\n    self.node.register_message_handler(\"key_exchange_confirm\", self._handle_key_exchange_confirm)\n    self.node.register_message_handler(\"key_exchange_test\", self._handle_key_exchange_test)\n    self.node.register_message_handler(\"secure_message\", self._handle_secure_message)\n    self.node.register_message_handler(\"crypto_settings_update\", self._handle_crypto_settings_update)\n    self.node.register_message_handler(\"crypto_settings_request\", self._handle_crypto_settings_request)\n    self.node.register_message_handler(\"key_exchange_rejected\", self._handle_key_exchange_rejected)\n\n    # Generate or load our keypair\n    self._load_or_generate_keypair()\n\n    # Load saved peer keys\n    # self._load_peer_keys()\n\n    # Log initialization\n    self.secure_logger.log_event(\n        event_type=\"initialization\",\n        message=f\"Secure messaging initialized with {self.key_exchange.name}, \"\n                f\"{self.symmetric.name}, and {self.signature.name}\"\n    )\n\n    # Use the module logger\n    logging.getLogger(__name__).info(\n        f\"Secure messaging initialized with {self.key_exchange.name}, \"\n        f\"{self.symmetric.name}, and {self.signature.name}\"\n    )\n\n    # Register connection event handler to automatically share settings\n    self.node.register_connection_handler(self._handle_new_connection)\n</code></pre>"},{"location":"api/app/messaging/#quantum_resistant_p2p.app.messaging.SecureMessaging-functions","title":"Functions","text":"<code>register_global_message_handler(handler)</code> \u00b6 <p>Register a handler for all messages.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable[[Message], None]</code> <p>Callback function that takes a Message as parameter</p> required Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def register_global_message_handler(self, handler: Callable[[Message], None]) -&gt; None:\n    \"\"\"Register a handler for all messages.\n\n    Args:\n        handler: Callback function that takes a Message as parameter\n    \"\"\"\n    # Check if this handler is already registered (by its memory address)\n    handler_id = id(handler)\n\n    # Avoid adding the same handler twice\n    if any(id(h) == handler_id for h in self.global_message_handlers):\n        logger.debug(f\"Handler {handler_id} already registered, skipping\")\n        return\n\n    self.global_message_handlers.append(handler)\n    logger.debug(f\"Registered global message handler {handler_id}\")\n</code></pre> <code>register_settings_change_listener(listener)</code> \u00b6 <p>Register a listener for cryptography settings changes.</p> <p>Parameters:</p> Name Type Description Default <code>listener</code> <code>Callable[[], None]</code> <p>Callback function that takes no parameters</p> required Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def register_settings_change_listener(self, listener: Callable[[], None]) -&gt; None:\n    \"\"\"Register a listener for cryptography settings changes.\n\n    Args:\n        listener: Callback function that takes no parameters\n    \"\"\"\n    listener_id = id(listener)\n\n    # Avoid adding the same listener twice\n    if any(id(l) == listener_id for l in self.settings_change_listeners):\n        logger.debug(f\"Settings change listener {listener_id} already registered, skipping\")\n        return\n\n    self.settings_change_listeners.append(listener)\n    logger.debug(f\"Registered crypto settings change listener {listener_id}\")\n</code></pre> <code>is_algorithm_compatible_with_peer(peer_id)</code> \u00b6 <p>Check if our current algorithm is compatible with the peer's algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <code>str</code> <p>The ID of the peer to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if algorithms are compatible, False otherwise</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def is_algorithm_compatible_with_peer(self, peer_id: str) -&gt; bool:\n    \"\"\"Check if our current algorithm is compatible with the peer's algorithm.\n\n    Args:\n        peer_id: The ID of the peer to check\n\n    Returns:\n        True if algorithms are compatible, False otherwise\n    \"\"\"\n    if peer_id not in self.peer_crypto_settings:\n        # If we don't know the peer's settings, assume incompatible\n        return False\n\n    peer_settings = self.peer_crypto_settings[peer_id]\n\n    # Check if the key exchange algorithms match exactly\n    peer_key_exchange = peer_settings.get(\"key_exchange\", \"\")\n    our_key_exchange = self.key_exchange.display_name\n\n    # Must be the same algorithm type for compatibility\n    return peer_key_exchange == our_key_exchange\n</code></pre> <code>send_crypto_settings_to_peer(peer_id)</code> <code>async</code> \u00b6 <p>Send our cryptography settings to a specific peer.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <code>str</code> <p>The ID of the peer to send settings to</p> required Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>async def send_crypto_settings_to_peer(self, peer_id: str) -&gt; None:\n    \"\"\"Send our cryptography settings to a specific peer.\n\n    Args:\n        peer_id: The ID of the peer to send settings to\n    \"\"\"\n    # Create settings info message\n    settings_info = {\n        \"key_exchange\": self.key_exchange.name,\n        \"symmetric\": self.symmetric.name,\n        \"signature\": self.signature.name,\n        \"timestamp\": time.time()\n    }\n\n    # Encode the settings info\n    message_json = json.dumps(settings_info).encode()\n\n    # Send the settings update (without signature)\n    try:\n        await self.node.send_message(\n            peer_id=peer_id,\n            message_type=\"crypto_settings_update\",\n            settings=base64.b64encode(message_json).decode()\n        )\n        logger.debug(f\"Sent crypto settings to {peer_id}\")\n    except Exception as e:\n        logger.error(f\"Failed to send crypto settings to {peer_id}: {e}\")\n</code></pre> <code>request_crypto_settings_from_peer(peer_id)</code> <code>async</code> \u00b6 <p>Request cryptography settings from a specific peer.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <code>str</code> <p>The ID of the peer to request settings from</p> required Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>async def request_crypto_settings_from_peer(self, peer_id: str) -&gt; None:\n    \"\"\"Request cryptography settings from a specific peer.\n\n    Args:\n        peer_id: The ID of the peer to request settings from\n    \"\"\"\n    try:\n        await self.node.send_message(\n            peer_id=peer_id,\n            message_type=\"crypto_settings_request\",\n            timestamp=time.time()\n        )\n        logger.debug(f\"Requested crypto settings from {peer_id}\")\n    except Exception as e:\n        logger.error(f\"Failed to request crypto settings from {peer_id}: {e}\")\n</code></pre> <code>notify_peers_of_settings_change()</code> <code>async</code> \u00b6 <p>Notify all connected peers about cryptography settings changes.</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>async def notify_peers_of_settings_change(self) -&gt; None:\n    \"\"\"Notify all connected peers about cryptography settings changes.\"\"\"\n    peers = self.node.get_peers()\n    if not peers:\n        return\n\n    # Send to all connected peers\n    for peer_id in peers:\n        try:\n            await self.send_crypto_settings_to_peer(peer_id)\n        except Exception as e:\n            logger.error(f\"Failed to notify peer {peer_id} of settings change: {e}\")\n</code></pre> <code>initiate_key_exchange(peer_id)</code> <code>async</code> \u00b6 <p>Initiate an authenticated key exchange with a peer using ephemeral keys.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <code>str</code> <p>The ID of the peer to exchange keys with</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if key exchange initiated successfully, False otherwise</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>async def initiate_key_exchange(self, peer_id: str) -&gt; bool:\n    \"\"\"Initiate an authenticated key exchange with a peer using ephemeral keys.\n\n    Args:\n        peer_id: The ID of the peer to exchange keys with\n\n    Returns:\n        True if key exchange initiated successfully, False otherwise\n    \"\"\"\n    logger.debug(f\"Initiating authenticated key exchange with {peer_id}\")\n\n    # If we already have a key exchange in progress, don't start another\n    if peer_id in self.key_exchange_states and self.key_exchange_states[peer_id] in [\n        KeyExchangeState.INITIATED, KeyExchangeState.RESPONDED, KeyExchangeState.CONFIRMED\n    ]:\n        logger.warning(f\"Key exchange already in progress with {peer_id}\")\n        return False\n\n    # Check for algorithm compatibility before proceeding\n    compatible = self.is_algorithm_compatible_with_peer(peer_id)\n    if not compatible:\n        peer_algo = \"unknown\"\n        if peer_id in self.peer_crypto_settings:\n            peer_algo = self.peer_crypto_settings[peer_id].get(\"key_exchange\", \"unknown\")\n\n        logger.warning(f\"Algorithm incompatibility with peer {peer_id}: \" +\n                      f\"we use {self.key_exchange.display_name}, they use {peer_algo}\")\n\n        # Notify about algorithm mismatch via system message\n        for handler in self.global_message_handlers:\n            try:\n                mismatch_message = Message.system_message(\n                    f\"Cannot perform key exchange: Algorithm incompatibility - we use \" +\n                    f\"{self.key_exchange.display_name}, peer uses {peer_algo}. \" +\n                    f\"Both peers must use the same algorithm type.\"\n                )\n                handler(mismatch_message)\n            except Exception as e:\n                logger.error(f\"Error in algorithm mismatch handler: {e}\")\n\n        return False\n\n    try:\n        # Generate a fresh ephemeral keypair for this exchange\n        public_key, private_key = self._generate_ephemeral_keypair()\n\n        # Store the private key in memory temporarily (only for this exchange)\n        # We'll use a dictionary to map peer_id to ephemeral private keys\n        # This is cleared once the exchange is complete\n        if not hasattr(self, 'ephemeral_private_keys'):\n            self.ephemeral_private_keys = {}\n        self.ephemeral_private_keys[peer_id] = private_key\n\n        # Get our signature keypair for authentication\n        signature_key = self.key_storage.get_key(f\"signature_{self.signature.name}\")\n        if signature_key is None:\n            logger.error(f\"Missing signature keypair for {self.signature.name}\")\n            return False\n\n        # Create a structured message with metadata\n        ke_data = {\n            \"public_key\": base64.b64encode(public_key).decode(),\n            \"algorithm\": self.key_exchange.display_name,\n            \"sender_id\": self.node.node_id,\n            \"recipient_id\": peer_id,\n            \"timestamp\": time.time(),\n            \"message_id\": str(uuid.uuid4())\n        }\n\n        # Serialize the data for signing\n        ke_data_json = json.dumps(ke_data).encode()\n\n        # Sign the key exchange data\n        private_key_sig = signature_key[\"private_key\"]\n        signature = self.signature.sign(private_key_sig, ke_data_json)\n\n        # Generate a message ID for tracking the response\n        message_id = ke_data[\"message_id\"]\n\n        # Create a future for the response\n        future = asyncio.Future()\n\n        # Register a callback for the response\n        def callback(result):\n            if isinstance(result, Exception):\n                # Don't set exception if we already have the shared key\n                if peer_id in self.shared_keys:\n                    future.set_result(True)\n                else:\n                    future.set_exception(result)\n            else:\n                future.set_result(True)\n\n            # Clean up ephemeral private key regardless of result\n            if peer_id in self.ephemeral_private_keys:\n                del self.ephemeral_private_keys[peer_id]\n\n        self.message_callbacks[message_id] = callback\n\n        # Set key exchange state\n        self.key_exchange_states[peer_id] = KeyExchangeState.INITIATED\n\n        # Send the authenticated key exchange initiation\n        success = await self.node.send_message(\n            peer_id=peer_id,\n            message_type=\"key_exchange_init\",\n            message_id=message_id,\n            ke_data=base64.b64encode(ke_data_json).decode(),\n            signature=base64.b64encode(signature).decode(),\n            public_key=base64.b64encode(signature_key[\"public_key\"]).decode()\n        )\n\n        if not success:\n            logger.error(f\"Failed to send key exchange initiation to {peer_id}\")\n            self.key_exchange_states[peer_id] = KeyExchangeState.NONE\n            # Clean up ephemeral private key\n            if peer_id in self.ephemeral_private_keys:\n                del self.ephemeral_private_keys[peer_id]\n            return False\n\n        # Wait for the response with timeout\n        try:\n            await asyncio.wait_for(future, timeout=20.0)\n            return True\n        except asyncio.TimeoutError:\n            # Check if we have a shared key despite the timeout\n            if peer_id in self.shared_keys:\n                logger.warning(f\"Key exchange callback timed out but shared key exists for {peer_id}\")\n                return True\n\n            logger.error(f\"Timeout waiting for key exchange response from {peer_id}\")\n            self.key_exchange_states[peer_id] = KeyExchangeState.NONE\n            # Clean up ephemeral private key\n            if peer_id in self.ephemeral_private_keys:\n                del self.ephemeral_private_keys[peer_id]\n            return False\n\n    except Exception as e:\n        logger.error(f\"Error initiating key exchange with {peer_id}: {e}\")\n        self.key_exchange_states[peer_id] = KeyExchangeState.NONE\n        # Clean up ephemeral private key\n        if hasattr(self, 'ephemeral_private_keys') and peer_id in self.ephemeral_private_keys:\n            del self.ephemeral_private_keys[peer_id]\n        # Check if we have a shared key despite the error\n        if peer_id in self.shared_keys:\n            logger.warning(f\"Key exchange failed with error but shared key exists for {peer_id}\")\n            return True\n        return False\n</code></pre> <code>send_message(peer_id, content, is_file=False, filename=None)</code> <code>async</code> \u00b6 <p>Send a secure message to a peer.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <code>str</code> <p>The ID of the peer to send the message to</p> required <code>content</code> <code>bytes</code> <p>The message content</p> required <code>is_file</code> <code>bool</code> <p>Whether the content is a file</p> <code>False</code> <code>filename</code> <code>Optional[str]</code> <p>The filename, if is_file is True</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if message sent successfully, False otherwise</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>async def send_message(self, peer_id: str, content: bytes, \n                   is_file: bool = False, filename: Optional[str] = None) -&gt; bool:\n    \"\"\"Send a secure message to a peer.\n\n    Args:\n        peer_id: The ID of the peer to send the message to\n        content: The message content\n        is_file: Whether the content is a file\n        filename: The filename, if is_file is True\n\n    Returns:\n        True if message sent successfully, False otherwise\n    \"\"\"\n    logger.debug(f\"Sending message to {peer_id}\")\n\n    # Verify the key exchange is valid\n    if not self.verify_key_exchange_state(peer_id):\n        logger.warning(f\"Key exchange with {peer_id} is not valid or complete\")\n        # Notify about the issue\n        for handler in self.global_message_handlers:\n            try:\n                system_message = Message.system_message(\n                    f\"Cannot send message to {peer_id}: Secure channel not established. Please initiate key exchange.\"\n                )\n                handler(system_message)\n            except Exception as e:\n                logger.error(f\"Error in system message handler: {e}\")\n        return False\n\n    # Make sure we have a shared key\n    if peer_id not in self.shared_keys:\n        logger.info(f\"No shared key with {peer_id}, initiating key exchange\")\n        success = await self.initiate_key_exchange(peer_id)\n        if not success:\n            logger.error(f\"Failed to establish shared key with {peer_id}\")\n            return False\n\n    try:\n        # Get our signature keypair\n        signature_key = self.key_storage.get_key(f\"signature_{self.signature.name}\")\n        if signature_key is None:\n            logger.error(f\"Missing signature keypair for {self.signature.name}\")\n            return False\n\n        # Step 1: Create the message object\n        message = Message(\n            content=content,\n            sender_id=self.node.node_id,\n            recipient_id=peer_id,\n            is_file=is_file,\n            filename=filename,\n            # Include algorithm information in the message\n            key_exchange_algo=self.key_exchange.name,\n            symmetric_algo=self.symmetric.name,\n            signature_algo=self.signature.name\n        )\n\n        # Step 2: Convert to JSON (this is what will be signed)\n        message_json = json.dumps(message.to_dict()).encode()\n\n        # Step 3: Sign the message JSON\n        private_key = signature_key[\"private_key\"]\n        signature = self.signature.sign(private_key, message_json)\n\n        # Step 4: Create signed package (message + signature + public key)\n        signed_package = {\n            \"message\": base64.b64encode(message_json).decode(),\n            \"signature\": base64.b64encode(signature).decode(),\n            \"public_key\": base64.b64encode(signature_key[\"public_key\"]).decode()\n        }\n\n        # Step 5: Serialize the signed package to JSON\n        signed_package_json = json.dumps(signed_package).encode()\n\n        # Step 6: Create AEAD associated data from critical metadata\n        associated_data = json.dumps({\n            \"type\": \"secure_message\",\n            \"message_id\": message.message_id,\n            \"sender_id\": self.node.node_id,\n            \"recipient_id\": peer_id,\n            \"timestamp\": message.timestamp,\n            \"is_file\": is_file,\n        }).encode()\n\n        # Step 7: Encrypt the signed package with AEAD\n        ciphertext = self.symmetric.encrypt(\n            self.shared_keys[peer_id], \n            signed_package_json,\n            associated_data=associated_data\n        )\n\n        # Log the message\n        self.secure_logger.log_event(\n            event_type=\"message_sent\",\n            peer_id=peer_id,\n            message_id=message.message_id,\n            encryption_algorithm=self.symmetric.name,\n            signature_algorithm=self.signature.name,\n            is_file=is_file,\n            size=len(content)\n        )\n\n        # Step 8: Send the encrypted package and associated data\n        success = await self.node.send_message(\n            peer_id=peer_id,\n            message_type=\"secure_message\",\n            ciphertext=base64.b64encode(ciphertext).decode(),\n            associated_data=base64.b64encode(associated_data).decode()\n        )\n\n        if not success:\n            logger.error(f\"Failed to send message to {peer_id}\")\n            return False\n\n        logger.info(f\"Sent secure message to {peer_id}\")\n        return True\n\n    except Exception as e:\n        logger.error(f\"Error sending message to {peer_id}: {e}\")\n        return False\n</code></pre> <code>send_file(peer_id, file_path)</code> <code>async</code> \u00b6 <p>Send a file to a peer using chunked messaging.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <code>str</code> <p>The ID of the peer to send the file to</p> required <code>file_path</code> <code>str</code> <p>The path to the file</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if file sent successfully, False otherwise</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>async def send_file(self, peer_id: str, file_path: str) -&gt; bool:\n    \"\"\"Send a file to a peer using chunked messaging.\n\n    Args:\n        peer_id: The ID of the peer to send the file to\n        file_path: The path to the file\n\n    Returns:\n        True if file sent successfully, False otherwise\n    \"\"\"\n    logger.debug(f\"Sending file {file_path} to {peer_id}\")\n\n    try:\n        # Get file info\n        file_name = os.path.basename(file_path)\n        file_size = os.path.getsize(file_path)\n\n        # Log the transfer\n        self.secure_logger.log_event(\n            event_type=\"message_sent\",\n            peer_id=peer_id,\n            is_file=True,\n            filename=file_name,\n            size=file_size\n        )\n\n        # Read the file\n        with open(file_path, \"rb\") as f:\n            content = f.read()\n\n        # Now send the file data as a secure message\n        # The node's chunking mechanism will handle large files automatically\n        return await self.send_message(peer_id, content, is_file=True, filename=file_name)\n\n    except Exception as e:\n        logger.error(f\"Error sending file {file_path} to {peer_id}: {e}\")\n        return False\n</code></pre> <code>register_message_callback(message_id, callback)</code> \u00b6 <p>Register a callback for a specific message ID.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>str</code> <p>The ID of the message to wait for</p> required <code>callback</code> <code>Callable[[Message], None]</code> <p>The callback function to call when the message is received</p> required Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def register_message_callback(self, message_id: str, \n                           callback: Callable[[Message], None]) -&gt; None:\n    \"\"\"Register a callback for a specific message ID.\n\n    Args:\n        message_id: The ID of the message to wait for\n        callback: The callback function to call when the message is received\n    \"\"\"\n    self.message_callbacks[message_id] = callback\n    logger.debug(f\"Registered callback for message {message_id}\")\n</code></pre> <code>get_peer_crypto_settings(peer_id)</code> \u00b6 <p>Get the cryptography settings of a peer.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <code>str</code> <p>The ID of the peer</p> required <p>Returns:</p> Type Description <code>Optional[Dict[str, str]]</code> <p>Dictionary of peer's cryptography settings, or None if not available</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def get_peer_crypto_settings(self, peer_id: str) -&gt; Optional[Dict[str, str]]:\n    \"\"\"Get the cryptography settings of a peer.\n\n    Args:\n        peer_id: The ID of the peer\n\n    Returns:\n        Dictionary of peer's cryptography settings, or None if not available\n    \"\"\"\n    return self.peer_crypto_settings.get(peer_id)\n</code></pre> <code>set_key_exchange_algorithm(algorithm)</code> \u00b6 <p>Set the key exchange algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>algorithm</code> <code>KeyExchangeAlgorithm</code> <p>The algorithm to use</p> required Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def set_key_exchange_algorithm(self, algorithm: KeyExchangeAlgorithm) -&gt; None:\n    \"\"\"Set the key exchange algorithm.\n\n    Args:\n        algorithm: The algorithm to use\n    \"\"\"\n    # Only take action if the algorithm has actually changed\n    if self.key_exchange.name != algorithm.name:\n        # Store old algorithm name for logging\n        old_algorithm = self.key_exchange.name\n\n        # Update the algorithm\n        self.key_exchange = algorithm\n\n        # Clear all shared keys and key exchange states\n        # This is important - we need to renegotiate with all peers\n        old_peer_ids = list(self.shared_keys.keys())\n        self.shared_keys = {}\n        self.key_exchange_states = {}\n\n        # Log the change\n        logger.info(f\"Changed key exchange algorithm from {old_algorithm} to {self.key_exchange.name}\")\n        self.secure_logger.log_event(\n            event_type=\"crypto_settings_changed\",\n            component=\"key_exchange\",\n            old_algorithm=old_algorithm,\n            new_algorithm=self.key_exchange.name\n        )\n\n        # Notify cryptography settings change listeners\n        self._notify_settings_change()\n\n        # For all connected peers, start key exchange asynchronously\n        for peer_id in old_peer_ids:\n            if peer_id in self.node.get_peers():\n                # Use create_task to start the key exchange asynchronously\n                asyncio.create_task(self.initiate_key_exchange(peer_id))\n                logger.info(f\"Triggered new key exchange with {peer_id} due to algorithm change\")\n\n        # Notify peers about our settings change\n        asyncio.create_task(self.notify_peers_of_settings_change())\n</code></pre> <code>set_symmetric_algorithm(algorithm)</code> \u00b6 <p>Set the symmetric encryption algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>algorithm</code> <code>SymmetricAlgorithm</code> <p>The algorithm to use</p> required Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def set_symmetric_algorithm(self, algorithm: SymmetricAlgorithm) -&gt; None:\n    \"\"\"Set the symmetric encryption algorithm.\n\n    Args:\n        algorithm: The algorithm to use\n    \"\"\"\n    # Only take action if the algorithm has actually changed\n    if self.symmetric.name != algorithm.name:\n        # Store old algorithm name for logging\n        old_algorithm = self.symmetric.name\n\n        # Update the algorithm\n        self.symmetric = algorithm\n\n        # Re-derive keys for all peers with available original shared secrets\n        for peer_id, original_secret in list(self.key_exchange_originals.items()):\n            if peer_id in self.key_exchange_states and self.key_exchange_states[peer_id] == KeyExchangeState.ESTABLISHED:\n                try:\n                    # Derive a new key with the new algorithm's requirements\n                    derived_key = self._derive_symmetric_key(original_secret, peer_id)\n                    self.shared_keys[peer_id] = derived_key\n\n                    # Save the updated key\n                    self._save_peer_key(peer_id, derived_key)\n\n                    logger.info(f\"Re-derived key for peer {peer_id} with new algorithm {self.symmetric.name}\")\n                except Exception as e:\n                    logger.error(f\"Failed to re-derive key for peer {peer_id}: {e}\")\n\n        # Log the change\n        logger.info(f\"Changed symmetric algorithm from {old_algorithm} to {self.symmetric.name}\")\n        self.secure_logger.log_event(\n            event_type=\"crypto_settings_changed\",\n            component=\"symmetric\",\n            old_algorithm=old_algorithm,\n            new_algorithm=self.symmetric.name\n        )\n\n        # Notify cryptography settings change listeners\n        self._notify_settings_change()\n\n        # Notify peers about our settings change\n        asyncio.create_task(self.notify_peers_of_settings_change())\n</code></pre> <code>set_signature_algorithm(algorithm)</code> \u00b6 <p>Set the digital signature algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>algorithm</code> <code>SignatureAlgorithm</code> <p>The algorithm to use</p> required Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def set_signature_algorithm(self, algorithm: SignatureAlgorithm) -&gt; None:\n    \"\"\"Set the digital signature algorithm.\n\n    Args:\n        algorithm: The algorithm to use\n    \"\"\"\n    # Only take action if the algorithm has actually changed\n    if self.signature.name != algorithm.name:\n        # Store old algorithm name for logging\n        old_algorithm = self.signature.name\n\n        # Update the algorithm\n        self.signature = algorithm\n\n        # Generate a keypair if we don't have one\n        signature_key = self.key_storage.get_key(f\"signature_{self.signature.name}\")\n        if signature_key is None:\n            public_key, private_key = self.signature.generate_keypair()\n            signature_key = {\n                \"algorithm\": self.signature.name,\n                \"public_key\": public_key,\n                \"private_key\": private_key\n            }\n            self.key_storage.store_key(f\"signature_{self.signature.name}\", signature_key)\n            logger.info(f\"Generated new signature keypair for {self.signature.name}\")\n\n        # Log the change\n        logger.info(f\"Changed signature algorithm from {old_algorithm} to {self.signature.name}\")\n        self.secure_logger.log_event(\n            event_type=\"crypto_settings_changed\",\n            component=\"signature\",\n            old_algorithm=old_algorithm,\n            new_algorithm=self.signature.name\n        )\n\n        # Notify cryptography settings change listeners\n        self._notify_settings_change()\n\n        # Notify peers about our settings change\n        asyncio.create_task(self.notify_peers_of_settings_change())\n</code></pre> <code>get_security_info()</code> \u00b6 <p>Get information about the current security configuration.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with security information</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def get_security_info(self) -&gt; Dict[str, Any]:\n    \"\"\"Get information about the current security configuration.\n\n    Returns:\n        Dictionary with security information\n    \"\"\"\n    return {\n        \"key_exchange\": {\n            \"algorithm\": self.key_exchange.name,\n            \"security_level\": getattr(self.key_exchange, \"security_level\", 3),\n            \"description\": self.key_exchange.description\n        },\n        \"symmetric\": {\n            \"algorithm\": self.symmetric.name,\n            \"key_size\": self.symmetric.key_size,\n            \"description\": self.symmetric.description\n        },\n        \"signature\": {\n            \"algorithm\": self.signature.name,\n            \"security_level\": getattr(self.signature, \"security_level\", 3),\n            \"description\": self.signature.description\n        },\n        \"peers_with_shared_keys\": len(self.shared_keys)\n    }\n</code></pre> <code>adopt_peer_settings(peer_id)</code> \u00b6 <p>Adopt the cryptography settings of a peer.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <code>str</code> <p>The ID of the peer whose settings to adopt</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if settings were adopted, False otherwise</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def adopt_peer_settings(self, peer_id: str) -&gt; bool:\n    \"\"\"Adopt the cryptography settings of a peer.\n\n    Args:\n        peer_id: The ID of the peer whose settings to adopt\n\n    Returns:\n        True if settings were adopted, False otherwise\n    \"\"\"\n    if peer_id not in self.peer_crypto_settings:\n        logger.error(f\"No settings available for peer {peer_id}\")\n        return False\n\n    peer_settings = self.peer_crypto_settings[peer_id]\n    settings_changed = False\n\n    # Adopt key exchange algorithm if needed\n    key_exchange_algo = peer_settings.get(\"key_exchange\")\n    if key_exchange_algo and key_exchange_algo != self.key_exchange.name:\n        # Map algorithm name to actual algorithm\n        from ..crypto import MLKEMKeyExchange, HQCKeyExchange, FrodoKEMKeyExchange\n\n        if \"ML-KEM\" in key_exchange_algo:\n            # Get the security level from the name\n            if \"Level 1\" in key_exchange_algo:\n                level = 1\n            elif \"Level 3\" in key_exchange_algo:\n                level = 3\n            elif \"Level 5\" in key_exchange_algo:\n                level = 5\n            else:\n                level = 3  # Default\n            algorithm = MLKEMKeyExchange(security_level=level)\n        elif \"HQC\" in key_exchange_algo:\n            # Get the security level from the name\n            if \"Level 1\" in key_exchange_algo:\n                level = 1\n            elif \"Level 3\" in key_exchange_algo:\n                level = 3\n            elif \"Level 5\" in key_exchange_algo:\n                level = 5\n            else:\n                level = 3  # Default\n            algorithm = HQCKeyExchange(security_level=level)\n        elif \"FrodoKEM\" in key_exchange_algo:\n            # Get the security level from the name\n            if \"Level 1\" in key_exchange_algo:\n                level = 1\n            elif \"Level 3\" in key_exchange_algo:\n                level = 3\n            elif \"Level 5\" in key_exchange_algo:\n                level = 5\n            else:\n                level = 3  # Default\n            # Check if it's AES or SHAKE\n            use_aes = \"AES\" in key_exchange_algo\n            algorithm = FrodoKEMKeyExchange(security_level=level, use_aes=use_aes)\n        else:\n            logger.warning(f\"Unknown key exchange algorithm: {key_exchange_algo}\")\n            return False\n\n        self.set_key_exchange_algorithm(algorithm)\n        settings_changed = True\n\n    # Adopt symmetric algorithm if needed\n    symmetric_algo = peer_settings.get(\"symmetric\")\n    if symmetric_algo and symmetric_algo != self.symmetric.name:\n        if symmetric_algo == \"AES-256-GCM\":\n            algorithm = AES256GCM()\n        elif symmetric_algo == \"ChaCha20-Poly1305\":\n            algorithm = ChaCha20Poly1305()\n        else:\n            logger.warning(f\"Unknown symmetric algorithm: {symmetric_algo}\")\n            return False\n\n        self.set_symmetric_algorithm(algorithm)\n        settings_changed = True\n\n    # Adopt signature algorithm if needed\n    signature_algo = peer_settings.get(\"signature\")\n    if signature_algo and signature_algo != self.signature.name:\n        # Map algorithm name to actual algorithm\n        from ..crypto import MLDSASignature, SPHINCSSignature\n\n        if \"ML-DSA\" in signature_algo:\n            # Get the security level from the name\n            if \"Level 2\" in signature_algo:\n                level = 2\n            elif \"Level 3\" in signature_algo:\n                level = 3\n            elif \"Level 5\" in signature_algo:\n                level = 5\n            else:\n                level = 3  # Default\n            algorithm = MLDSASignature(security_level=level)\n        elif \"SPHINCS+\" in signature_algo:\n            # Get the security level from the name\n            if \"Level 1\" in signature_algo:\n                level = 1\n            elif \"Level 3\" in signature_algo:\n                level = 3\n            elif \"Level 5\" in signature_algo:\n                level = 5\n            else:\n                level = 3  # Default\n            algorithm = SPHINCSSignature(security_level=level)\n        else:\n            logger.warning(f\"Unknown signature algorithm: {signature_algo}\")\n            return False\n\n        self.set_signature_algorithm(algorithm)\n        settings_changed = True\n\n    if settings_changed:\n        logger.info(f\"Successfully adopted settings from peer {peer_id}\")\n        return True\n    else:\n        logger.info(f\"No settings changes needed for peer {peer_id}\")\n        return False\n</code></pre> <code>verify_key_exchange_state(peer_id)</code> \u00b6 <p>Verify the key exchange state for a peer.</p> <p>This function checks if a key exchange with a peer is actually valid and properly established, not just assumed from a previous connection.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <code>str</code> <p>The ID of the peer</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the key exchange is valid, False otherwise</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def verify_key_exchange_state(self, peer_id: str) -&gt; bool:\n    \"\"\"Verify the key exchange state for a peer.\n\n    This function checks if a key exchange with a peer is actually valid\n    and properly established, not just assumed from a previous connection.\n\n    Args:\n        peer_id: The ID of the peer\n\n    Returns:\n        True if the key exchange is valid, False otherwise\n    \"\"\"\n    # Check if we have a shared key\n    if peer_id not in self.shared_keys:\n        logger.debug(f\"No shared key exists for peer {peer_id}\")\n        return False\n\n    # Check if the key exchange is in a valid state\n    valid_states = [KeyExchangeState.CONFIRMED, KeyExchangeState.ESTABLISHED]\n    if peer_id not in self.key_exchange_states or self.key_exchange_states[peer_id] not in valid_states:\n        logger.warning(f\"Key exchange with {peer_id} is in an invalid state: \" +\n                      f\"{self.key_exchange_states.get(peer_id, 'NONE')}\")\n        return False\n\n    # Check if the peer is actually connected\n    if peer_id not in self.node.get_peers():\n        logger.warning(f\"Peer {peer_id} has a shared key but is not connected\")\n        return False\n\n    # All checks passed, key exchange is valid\n    return True\n</code></pre>"},{"location":"api/app/messaging/#quantum_resistant_p2p.app.messaging.MessageStore","title":"<code>MessageStore()</code>","text":"<p>Store for secure messages to provide persistence and unread count tracking.</p> <p>Initialize a new message store.</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize a new message store.\"\"\"\n    # Maps peer_id -&gt; list of Message objects\n    self.messages = {}\n    # Maps peer_id -&gt; count of unread messages\n    self.unread_counts = {}\n    # Maps peer_id -&gt; timestamp of last message\n    self.last_activity = {}\n    # Current node ID to identify local messages\n    self.current_node_id = None\n</code></pre>"},{"location":"api/app/messaging/#quantum_resistant_p2p.app.messaging.MessageStore-functions","title":"Functions","text":"<code>add_message(message, mark_as_read=False)</code> \u00b6 <p>Add a message to the store.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <p>The message to store</p> required <code>mark_as_read</code> <p>Whether to mark the message as read immediately</p> <code>False</code> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def add_message(self, message, mark_as_read=False):\n    \"\"\"Add a message to the store.\n\n    Args:\n        message: The message to store\n        mark_as_read: Whether to mark the message as read immediately\n    \"\"\"\n    # Determine the conversation peer_id based on message direction\n    store_peer_id = None\n\n    if hasattr(message, 'recipient_id') and message.recipient_id:\n        if message.sender_id == self.current_node_id:\n            # Outgoing message - use recipient_id as the conversation key\n            store_peer_id = message.recipient_id\n        elif message.recipient_id == self.current_node_id:\n            # Incoming direct message - use sender_id as the conversation key\n            store_peer_id = message.sender_id\n\n    if store_peer_id is None:\n        # Fallback to sender_id if direction can't be determined\n        store_peer_id = message.sender_id\n\n        # Skip system messages that aren't part of a conversation\n        if message.is_system:\n            return\n\n    # Initialize data structures for this peer if needed\n    if store_peer_id not in self.messages:\n        self.messages[store_peer_id] = []\n        self.unread_counts[store_peer_id] = 0\n\n    # Add the message\n    self.messages[store_peer_id].append(message)\n\n    # Update last activity timestamp\n    self.last_activity[store_peer_id] = message.timestamp\n\n    # Increment unread count if not marked as read\n    if not mark_as_read:\n        self.unread_counts[store_peer_id] = self.unread_counts.get(store_peer_id, 0) + 1\n</code></pre> <code>get_messages(peer_id)</code> \u00b6 <p>Get all messages for a peer.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <p>The ID of the peer</p> required <p>Returns:</p> Type Description <p>List of Message objects</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def get_messages(self, peer_id):\n    \"\"\"Get all messages for a peer.\n\n    Args:\n        peer_id: The ID of the peer\n\n    Returns:\n        List of Message objects\n    \"\"\"\n    return self.messages.get(peer_id, [])\n</code></pre> <code>mark_all_read(peer_id)</code> \u00b6 <p>Mark all messages from a peer as read.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <p>The ID of the peer</p> required Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def mark_all_read(self, peer_id):\n    \"\"\"Mark all messages from a peer as read.\n\n    Args:\n        peer_id: The ID of the peer\n    \"\"\"\n    self.unread_counts[peer_id] = 0\n</code></pre> <code>get_unread_count(peer_id)</code> \u00b6 <p>Get the number of unread messages from a peer.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <p>The ID of the peer</p> required <p>Returns:</p> Type Description <p>The number of unread messages</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def get_unread_count(self, peer_id):\n    \"\"\"Get the number of unread messages from a peer.\n\n    Args:\n        peer_id: The ID of the peer\n\n    Returns:\n        The number of unread messages\n    \"\"\"\n    return self.unread_counts.get(peer_id, 0)\n</code></pre> <code>has_unread_messages(peer_id)</code> \u00b6 <p>Check if a peer has any unread messages.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <p>The ID of the peer</p> required <p>Returns:</p> Type Description <p>True if there are unread messages, False otherwise</p> Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def has_unread_messages(self, peer_id):\n    \"\"\"Check if a peer has any unread messages.\n\n    Args:\n        peer_id: The ID of the peer\n\n    Returns:\n        True if there are unread messages, False otherwise\n    \"\"\"\n    return self.get_unread_count(peer_id) &gt; 0\n</code></pre> <code>set_current_node_id(node_id)</code> \u00b6 <p>Set the current node ID for determining message direction.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <p>The ID of the current node</p> required Source code in <code>quantum_resistant_p2p\\app\\messaging.py</code> <pre><code>def set_current_node_id(self, node_id):\n    \"\"\"Set the current node ID for determining message direction.\n\n    Args:\n        node_id: The ID of the current node\n    \"\"\"\n    self.current_node_id = node_id\n</code></pre>"},{"location":"api/crypto/","title":"Crypto Package","text":"<p>Cryptographic layer for post-quantum and symmetric cryptography. This package provides implementations of post-quantum key exchange algorithms, symmetric encryption, digital signatures, and secure key storage.</p>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto","title":"<code>quantum_resistant_p2p.crypto</code>","text":"<p>Cryptographic layer for post-quantum and symmetric cryptography.</p> <p>This package provides implementations of post-quantum key exchange algorithms, symmetric encryption, digital signatures, and secure key storage.</p>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto-classes","title":"Classes","text":""},{"location":"api/crypto/#quantum_resistant_p2p.crypto.KeyExchangeAlgorithm","title":"<code>KeyExchangeAlgorithm</code>","text":"<p>               Bases: <code>CryptoAlgorithm</code></p> <p>Abstract base class for key exchange algorithms.</p>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.KeyExchangeAlgorithm-functions","title":"Functions","text":"<code>generate_keypair()</code> <code>abstractmethod</code> \u00b6 <p>Generate a new keypair.</p> <p>Returns:</p> Type Description <code>Tuple[bytes, bytes]</code> <p>Tuple of (public_key, private_key)</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>@abc.abstractmethod\ndef generate_keypair(self) -&gt; Tuple[bytes, bytes]:\n    \"\"\"Generate a new keypair.\n\n    Returns:\n        Tuple of (public_key, private_key)\n    \"\"\"\n    pass\n</code></pre> <code>encapsulate(public_key)</code> <code>abstractmethod</code> \u00b6 <p>Encapsulate a shared secret using the recipient's public key.</p> <p>Parameters:</p> Name Type Description Default <code>public_key</code> <code>bytes</code> <p>The recipient's public key</p> required <p>Returns:</p> Type Description <code>Tuple[bytes, bytes]</code> <p>Tuple of (ciphertext, shared_secret)</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>@abc.abstractmethod\ndef encapsulate(self, public_key: bytes) -&gt; Tuple[bytes, bytes]:\n    \"\"\"Encapsulate a shared secret using the recipient's public key.\n\n    Args:\n        public_key: The recipient's public key\n\n    Returns:\n        Tuple of (ciphertext, shared_secret)\n    \"\"\"\n    pass\n</code></pre> <code>decapsulate(private_key, ciphertext)</code> <code>abstractmethod</code> \u00b6 <p>Decapsulate a shared secret using the recipient's private key.</p> <p>Parameters:</p> Name Type Description Default <code>private_key</code> <code>bytes</code> <p>The recipient's private key</p> required <code>ciphertext</code> <code>bytes</code> <p>The ciphertext from the sender</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The shared secret</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>@abc.abstractmethod\ndef decapsulate(self, private_key: bytes, ciphertext: bytes) -&gt; bytes:\n    \"\"\"Decapsulate a shared secret using the recipient's private key.\n\n    Args:\n        private_key: The recipient's private key\n        ciphertext: The ciphertext from the sender\n\n    Returns:\n        The shared secret\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.MLKEMKeyExchange","title":"<code>MLKEMKeyExchange(security_level=3)</code>","text":"<p>               Bases: <code>KeyExchangeAlgorithm</code></p> <p>ML-KEM (previously CRYSTALS-Kyber) key exchange algorithm.</p> <p>ML-KEM is a post-quantum key encapsulation mechanism (KEM) based on the hardness of solving the learning-with-errors (LWE) problem over module lattices.</p> <p>Initialize ML-KEM with the specified security level.</p> <p>Parameters:</p> Name Type Description Default <code>security_level</code> <code>int</code> <p>Security level (1, 3, or 5)</p> <code>3</code> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>def __init__(self, security_level: int = 3):\n    \"\"\"Initialize ML-KEM with the specified security level.\n\n    Args:\n        security_level: Security level (1, 3, or 5)\n    \"\"\"\n    self.security_level = security_level\n    self.kem = None\n    self.variant = None\n\n    # Map security levels to ML-KEM variants\n    ml_kem_variants = {\n        1: \"ML-KEM-512\",\n        3: \"ML-KEM-768\",\n        5: \"ML-KEM-1024\"\n    }\n\n    # Also check for older Kyber names as a fallback\n    kyber_variants = {\n        1: \"Kyber512\",\n        3: \"Kyber768\",\n        5: \"Kyber1024\"\n    }\n\n    if security_level not in ml_kem_variants:\n        raise ValueError(f\"Invalid security level: {security_level}. Must be 1, 3, or 5.\")\n\n    # Determine available enabled KEM mechanisms\n    self.enabled_kems = oqs.get_enabled_kem_mechanisms()\n\n    # Try to find an available implementation\n    if ml_kem_variants[security_level] in self.enabled_kems:\n        self.variant = ml_kem_variants[security_level]\n    elif kyber_variants[security_level] in self.enabled_kems:\n        # Use older Kyber implementation if available\n        self.variant = kyber_variants[security_level]\n    else:\n        raise ValueError(f\"No ML-KEM or Kyber variant found for security level {security_level}\")\n\n    # Create the KEM instance\n    self.kem = oqs.KeyEncapsulation(self.variant)\n    logger.info(f\"Successfully initialized ML-KEM variant {self.variant}\")\n\n    logger.info(f\"Initialized ML-KEM key exchange with security level {security_level}\")\n</code></pre>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.MLKEMKeyExchange-attributes","title":"Attributes","text":"<code>name</code> <code>property</code> \u00b6 <p>Get the internal name of the algorithm.</p> <code>display_name</code> <code>property</code> \u00b6 <p>Get the user-friendly name for display.</p> <code>description</code> <code>property</code> \u00b6 <p>Get a description of the algorithm.</p>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.MLKEMKeyExchange-functions","title":"Functions","text":"<code>generate_keypair()</code> \u00b6 <p>Generate a new ML-KEM keypair.</p> <p>Returns:</p> Type Description <code>Tuple[bytes, bytes]</code> <p>Tuple of (public_key, private_key)</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>def generate_keypair(self) -&gt; Tuple[bytes, bytes]:\n    \"\"\"Generate a new ML-KEM keypair.\n\n    Returns:\n        Tuple of (public_key, private_key)\n    \"\"\"\n    try:\n        # Use actual OQS implementation\n        public_key = self.kem.generate_keypair()\n        private_key = self.kem.export_secret_key()\n\n        logger.debug(f\"Generated ML-KEM keypair: public key {len(public_key)} bytes, \"\n                  f\"private key {len(private_key)} bytes\")\n\n        return public_key, private_key\n    except Exception as e:\n        logger.error(f\"Error generating ML-KEM keypair: {e}\")\n        raise\n</code></pre> <code>encapsulate(public_key)</code> \u00b6 <p>Encapsulate a shared secret using the recipient's public key.</p> <p>Parameters:</p> Name Type Description Default <code>public_key</code> <code>bytes</code> <p>The recipient's public key</p> required <p>Returns:</p> Type Description <code>Tuple[bytes, bytes]</code> <p>Tuple of (ciphertext, shared_secret)</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>def encapsulate(self, public_key: bytes) -&gt; Tuple[bytes, bytes]:\n    \"\"\"Encapsulate a shared secret using the recipient's public key.\n\n    Args:\n        public_key: The recipient's public key\n\n    Returns:\n        Tuple of (ciphertext, shared_secret)\n    \"\"\"\n    try:\n        # Create a new instance for encapsulation\n        encap_kem = oqs.KeyEncapsulation(self.variant)\n        ciphertext, shared_secret = encap_kem.encap_secret(public_key)\n\n        logger.debug(f\"ML-KEM encapsulation: ciphertext {len(ciphertext)} bytes, \"\n                  f\"shared secret {len(shared_secret)} bytes\")\n\n        return ciphertext, shared_secret\n    except Exception as e:\n        logger.error(f\"Error during ML-KEM encapsulation: {e}\")\n        raise\n</code></pre> <code>decapsulate(private_key, ciphertext)</code> \u00b6 <p>Decapsulate a shared secret using the recipient's private key.</p> <p>Parameters:</p> Name Type Description Default <code>private_key</code> <code>bytes</code> <p>The recipient's private key</p> required <code>ciphertext</code> <code>bytes</code> <p>The ciphertext from the sender</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The shared secret</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>def decapsulate(self, private_key: bytes, ciphertext: bytes) -&gt; bytes:\n    \"\"\"Decapsulate a shared secret using the recipient's private key.\n\n    Args:\n        private_key: The recipient's private key\n        ciphertext: The ciphertext from the sender\n\n    Returns:\n        The shared secret\n    \"\"\"\n    try:\n        # Create a new KEM instance with the private key for decapsulation\n        decap_kem = oqs.KeyEncapsulation(self.variant, private_key)\n        shared_secret = decap_kem.decap_secret(ciphertext)\n\n        logger.debug(f\"ML-KEM decapsulation: shared secret {len(shared_secret)} bytes\")\n\n        return shared_secret\n    except Exception as e:\n        logger.error(f\"Error during ML-KEM decapsulation: {e}\")\n        raise\n</code></pre>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.HQCKeyExchange","title":"<code>HQCKeyExchange(security_level=3)</code>","text":"<p>               Bases: <code>KeyExchangeAlgorithm</code></p> <p>HQC (Hamming Quasi-Cyclic) key exchange algorithm.</p> <p>HQC is a code-based post-quantum key encapsulation mechanism (KEM) based on the hardness of decoding problems in quasi-cyclic codes.</p> <p>Initialize HQC with the specified security level.</p> <p>Parameters:</p> Name Type Description Default <code>security_level</code> <code>int</code> <p>Security level (1 for 128-bit, 3 for 192-bit, 5 for 256-bit)</p> <code>3</code> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>def __init__(self, security_level: int = 3):\n    \"\"\"Initialize HQC with the specified security level.\n\n    Args:\n        security_level: Security level (1 for 128-bit, 3 for 192-bit, 5 for 256-bit)\n    \"\"\"\n    self.security_level = security_level\n    self.kem = None\n    self.variant = None\n\n    # Map security levels to HQC variants\n    hqc_variants = {\n        1: \"HQC-128\",\n        3: \"HQC-192\",\n        5: \"HQC-256\"\n    }\n\n    if security_level not in hqc_variants:\n        raise ValueError(f\"Invalid security level: {security_level}. Must be 1, 3, or 5.\")\n\n    # Determine available enabled KEM mechanisms\n    self.enabled_kems = oqs.get_enabled_kem_mechanisms()\n\n    # Try to find an available implementation\n    if hqc_variants[security_level] in self.enabled_kems:\n        self.variant = hqc_variants[security_level]\n    else:\n        raise ValueError(f\"No HQC variant found for security level {security_level}\")\n\n    # Create the KEM instance\n    self.kem = oqs.KeyEncapsulation(self.variant)\n    logger.info(f\"Successfully initialized HQC variant {self.variant}\")\n\n    logger.info(f\"Initialized HQC key exchange with security level {security_level}\")\n</code></pre>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.HQCKeyExchange-attributes","title":"Attributes","text":"<code>name</code> <code>property</code> \u00b6 <p>Get the internal name of the algorithm.</p> <code>display_name</code> <code>property</code> \u00b6 <p>Get the user-friendly name for display.</p> <code>description</code> <code>property</code> \u00b6 <p>Get a description of the algorithm.</p>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.HQCKeyExchange-functions","title":"Functions","text":"<code>generate_keypair()</code> \u00b6 <p>Generate a new HQC keypair.</p> <p>Returns:</p> Type Description <code>Tuple[bytes, bytes]</code> <p>Tuple of (public_key, private_key)</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>def generate_keypair(self) -&gt; Tuple[bytes, bytes]:\n    \"\"\"Generate a new HQC keypair.\n\n    Returns:\n        Tuple of (public_key, private_key)\n    \"\"\"\n    try:\n        # Use actual OQS implementation\n        public_key = self.kem.generate_keypair()\n        private_key = self.kem.export_secret_key()\n\n        logger.debug(f\"Generated HQC keypair: public key {len(public_key)} bytes, \"\n                  f\"private key {len(private_key)} bytes\")\n\n        return public_key, private_key\n    except Exception as e:\n        logger.error(f\"Error generating HQC keypair: {e}\")\n        raise\n</code></pre> <code>encapsulate(public_key)</code> \u00b6 <p>Encapsulate a shared secret using the recipient's public key.</p> <p>Parameters:</p> Name Type Description Default <code>public_key</code> <code>bytes</code> <p>The recipient's public key</p> required <p>Returns:</p> Type Description <code>Tuple[bytes, bytes]</code> <p>Tuple of (ciphertext, shared_secret)</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>def encapsulate(self, public_key: bytes) -&gt; Tuple[bytes, bytes]:\n    \"\"\"Encapsulate a shared secret using the recipient's public key.\n\n    Args:\n        public_key: The recipient's public key\n\n    Returns:\n        Tuple of (ciphertext, shared_secret)\n    \"\"\"\n    try:\n        # Create a new instance for encapsulation\n        encap_kem = oqs.KeyEncapsulation(self.variant)\n        ciphertext, shared_secret = encap_kem.encap_secret(public_key)\n\n        logger.debug(f\"HQC encapsulation: ciphertext {len(ciphertext)} bytes, \"\n                  f\"shared secret {len(shared_secret)} bytes\")\n\n        return ciphertext, shared_secret\n    except Exception as e:\n        logger.error(f\"Error during HQC encapsulation: {e}\")\n        raise\n</code></pre> <code>decapsulate(private_key, ciphertext)</code> \u00b6 <p>Decapsulate a shared secret using the recipient's private key.</p> <p>Parameters:</p> Name Type Description Default <code>private_key</code> <code>bytes</code> <p>The recipient's private key</p> required <code>ciphertext</code> <code>bytes</code> <p>The ciphertext from the sender</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The shared secret</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>def decapsulate(self, private_key: bytes, ciphertext: bytes) -&gt; bytes:\n    \"\"\"Decapsulate a shared secret using the recipient's private key.\n\n    Args:\n        private_key: The recipient's private key\n        ciphertext: The ciphertext from the sender\n\n    Returns:\n        The shared secret\n    \"\"\"\n    try:\n        # Create a new KEM instance with the private key for decapsulation\n        decap_kem = oqs.KeyEncapsulation(self.variant, private_key)\n        shared_secret = decap_kem.decap_secret(ciphertext)\n\n        logger.debug(f\"HQC decapsulation: shared secret {len(shared_secret)} bytes\")\n\n        return shared_secret\n    except Exception as e:\n        logger.error(f\"Error during HQC decapsulation: {e}\")\n        raise\n</code></pre>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.FrodoKEMKeyExchange","title":"<code>FrodoKEMKeyExchange(security_level=3, use_aes=True)</code>","text":"<p>               Bases: <code>KeyExchangeAlgorithm</code></p> <p>FrodoKEM key exchange algorithm.</p> <p>FrodoKEM is a lattice-based key encapsulation mechanism (KEM) based on the standard Learning With Errors problem without any additional structure.</p> <p>Initialize FrodoKEM with the specified security level.</p> <p>Parameters:</p> Name Type Description Default <code>security_level</code> <code>int</code> <p>Security level (1 for 640, 3 for 976, 5 for 1344)</p> <code>3</code> <code>use_aes</code> <code>bool</code> <p>Whether to use AES (True) or SHAKE (False) for randomness</p> <code>True</code> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>def __init__(self, security_level: int = 3, use_aes: bool = True):\n    \"\"\"Initialize FrodoKEM with the specified security level.\n\n    Args:\n        security_level: Security level (1 for 640, 3 for 976, 5 for 1344)\n        use_aes: Whether to use AES (True) or SHAKE (False) for randomness\n    \"\"\"\n    self.security_level = security_level\n    self.use_aes = use_aes\n    self.kem = None\n    self.variant = None\n\n    # Map security levels to FrodoKEM variants\n    if use_aes:\n        frodo_variants = {\n            1: \"FrodoKEM-640-AES\",\n            3: \"FrodoKEM-976-AES\",\n            5: \"FrodoKEM-1344-AES\"\n        }\n    else:\n        frodo_variants = {\n            1: \"FrodoKEM-640-SHAKE\",\n            3: \"FrodoKEM-976-SHAKE\",\n            5: \"FrodoKEM-1344-SHAKE\"\n        }\n\n    if security_level not in frodo_variants:\n        raise ValueError(f\"Invalid security level: {security_level}. Must be 1, 3, or 5.\")\n\n    # Determine available enabled KEM mechanisms\n    self.enabled_kems = oqs.get_enabled_kem_mechanisms()\n\n    # Try to find an available implementation\n    if frodo_variants[security_level] in self.enabled_kems:\n        self.variant = frodo_variants[security_level]\n    else:\n        # Try the other variant (AES vs SHAKE) if available\n        alt_variant = frodo_variants[security_level].replace('-AES', '-SHAKE') if use_aes else frodo_variants[security_level].replace('-SHAKE', '-AES')\n        if alt_variant in self.enabled_kems:\n            self.variant = alt_variant\n            logger.info(f\"Using alternative FrodoKEM variant: {alt_variant}\")\n        else:\n            raise ValueError(f\"No FrodoKEM variant found for security level {security_level}\")\n\n    # Create the KEM instance\n    self.kem = oqs.KeyEncapsulation(self.variant)\n    logger.info(f\"Successfully initialized FrodoKEM variant {self.variant}\")\n\n    logger.info(f\"Initialized FrodoKEM key exchange with security level {security_level}\")\n</code></pre>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.FrodoKEMKeyExchange-attributes","title":"Attributes","text":"<code>name</code> <code>property</code> \u00b6 <p>Get the internal name of the algorithm.</p> <code>display_name</code> <code>property</code> \u00b6 <p>Get the user-friendly name for display.</p> <code>description</code> <code>property</code> \u00b6 <p>Get a description of the algorithm.</p>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.FrodoKEMKeyExchange-functions","title":"Functions","text":"<code>generate_keypair()</code> \u00b6 <p>Generate a new FrodoKEM keypair.</p> <p>Returns:</p> Type Description <code>Tuple[bytes, bytes]</code> <p>Tuple of (public_key, private_key)</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>def generate_keypair(self) -&gt; Tuple[bytes, bytes]:\n    \"\"\"Generate a new FrodoKEM keypair.\n\n    Returns:\n        Tuple of (public_key, private_key)\n    \"\"\"\n    try:\n        # Use actual OQS implementation\n        public_key = self.kem.generate_keypair()\n        private_key = self.kem.export_secret_key()\n\n        logger.debug(f\"Generated FrodoKEM keypair: public key {len(public_key)} bytes, \"\n                  f\"private key {len(private_key)} bytes\")\n\n        return public_key, private_key\n    except Exception as e:\n        logger.error(f\"Error generating FrodoKEM keypair: {e}\")\n        raise\n</code></pre> <code>encapsulate(public_key)</code> \u00b6 <p>Encapsulate a shared secret using the recipient's public key.</p> <p>Parameters:</p> Name Type Description Default <code>public_key</code> <code>bytes</code> <p>The recipient's public key</p> required <p>Returns:</p> Type Description <code>Tuple[bytes, bytes]</code> <p>Tuple of (ciphertext, shared_secret)</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>def encapsulate(self, public_key: bytes) -&gt; Tuple[bytes, bytes]:\n    \"\"\"Encapsulate a shared secret using the recipient's public key.\n\n    Args:\n        public_key: The recipient's public key\n\n    Returns:\n        Tuple of (ciphertext, shared_secret)\n    \"\"\"\n    try:\n        # Create a new instance for encapsulation\n        encap_kem = oqs.KeyEncapsulation(self.variant)\n        ciphertext, shared_secret = encap_kem.encap_secret(public_key)\n\n        logger.debug(f\"FrodoKEM encapsulation: ciphertext {len(ciphertext)} bytes, \"\n                  f\"shared secret {len(shared_secret)} bytes\")\n\n        return ciphertext, shared_secret\n    except Exception as e:\n        logger.error(f\"Error during FrodoKEM encapsulation: {e}\")\n        raise\n</code></pre> <code>decapsulate(private_key, ciphertext)</code> \u00b6 <p>Decapsulate a shared secret using the recipient's private key.</p> <p>Parameters:</p> Name Type Description Default <code>private_key</code> <code>bytes</code> <p>The recipient's private key</p> required <code>ciphertext</code> <code>bytes</code> <p>The ciphertext from the sender</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The shared secret</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>def decapsulate(self, private_key: bytes, ciphertext: bytes) -&gt; bytes:\n    \"\"\"Decapsulate a shared secret using the recipient's private key.\n\n    Args:\n        private_key: The recipient's private key\n        ciphertext: The ciphertext from the sender\n\n    Returns:\n        The shared secret\n    \"\"\"\n    try:\n        # Create a new KEM instance with the private key for decapsulation\n        decap_kem = oqs.KeyEncapsulation(self.variant, private_key)\n        shared_secret = decap_kem.decap_secret(ciphertext)\n\n        logger.debug(f\"FrodoKEM decapsulation: shared secret {len(shared_secret)} bytes\")\n\n        return shared_secret\n    except Exception as e:\n        logger.error(f\"Error during FrodoKEM decapsulation: {e}\")\n        raise\n</code></pre>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.SymmetricAlgorithm","title":"<code>SymmetricAlgorithm</code>","text":"<p>               Bases: <code>CryptoAlgorithm</code></p> <p>Abstract base class for symmetric encryption algorithms.</p>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.SymmetricAlgorithm-attributes","title":"Attributes","text":"<code>key_size</code> <code>abstractmethod</code> <code>property</code> \u00b6 <p>Get the key size in bytes.</p>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.SymmetricAlgorithm-functions","title":"Functions","text":"<code>generate_key()</code> <code>abstractmethod</code> \u00b6 <p>Generate a new random key.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>A new key as bytes</p> Source code in <code>quantum_resistant_p2p\\crypto\\symmetric.py</code> <pre><code>@abc.abstractmethod\ndef generate_key(self) -&gt; bytes:\n    \"\"\"Generate a new random key.\n\n    Returns:\n        A new key as bytes\n    \"\"\"\n    pass\n</code></pre> <code>encrypt(key, plaintext, associated_data=None)</code> <code>abstractmethod</code> \u00b6 <p>Encrypt data using the given key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes</code> <p>The encryption key</p> required <code>plaintext</code> <code>bytes</code> <p>The data to encrypt</p> required <code>associated_data</code> <code>Optional[bytes]</code> <p>Optional additional authenticated data</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The encrypted data (including nonce/IV)</p> Source code in <code>quantum_resistant_p2p\\crypto\\symmetric.py</code> <pre><code>@abc.abstractmethod\ndef encrypt(self, key: bytes, plaintext: bytes, associated_data: Optional[bytes] = None) -&gt; bytes:\n    \"\"\"Encrypt data using the given key.\n\n    Args:\n        key: The encryption key\n        plaintext: The data to encrypt\n        associated_data: Optional additional authenticated data\n\n    Returns:\n        The encrypted data (including nonce/IV)\n    \"\"\"\n    pass\n</code></pre> <code>decrypt(key, ciphertext, associated_data=None)</code> <code>abstractmethod</code> \u00b6 <p>Decrypt data using the given key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes</code> <p>The encryption key</p> required <code>ciphertext</code> <code>bytes</code> <p>The data to decrypt (including nonce/IV)</p> required <code>associated_data</code> <code>Optional[bytes]</code> <p>Optional additional authenticated data</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The decrypted data</p> Source code in <code>quantum_resistant_p2p\\crypto\\symmetric.py</code> <pre><code>@abc.abstractmethod\ndef decrypt(self, key: bytes, ciphertext: bytes, associated_data: Optional[bytes] = None) -&gt; bytes:\n    \"\"\"Decrypt data using the given key.\n\n    Args:\n        key: The encryption key\n        ciphertext: The data to decrypt (including nonce/IV)\n        associated_data: Optional additional authenticated data\n\n    Returns:\n        The decrypted data\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.AES256GCM","title":"<code>AES256GCM</code>","text":"<p>               Bases: <code>SymmetricAlgorithm</code></p> <p>AES-256 in GCM mode for authenticated encryption.</p>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.AES256GCM-attributes","title":"Attributes","text":"<code>name</code> <code>property</code> \u00b6 <p>Get the name of the algorithm.</p> <code>description</code> <code>property</code> \u00b6 <p>Get a description of the algorithm.</p> <code>key_size</code> <code>property</code> \u00b6 <p>Get the key size in bytes.</p>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.AES256GCM-functions","title":"Functions","text":"<code>generate_key()</code> \u00b6 <p>Generate a new random AES-256 key.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>A new 256-bit (32-byte) key</p> Source code in <code>quantum_resistant_p2p\\crypto\\symmetric.py</code> <pre><code>def generate_key(self) -&gt; bytes:\n    \"\"\"Generate a new random AES-256 key.\n\n    Returns:\n        A new 256-bit (32-byte) key\n    \"\"\"\n    key = os.urandom(self.key_size)\n    logger.debug(f\"Generated new AES-256 key ({self.key_size} bytes)\")\n    return key\n</code></pre> <code>encrypt(key, plaintext, associated_data=None)</code> \u00b6 <p>Encrypt data using AES-256-GCM.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes</code> <p>The 256-bit AES key</p> required <code>plaintext</code> <code>bytes</code> <p>The data to encrypt</p> required <code>associated_data</code> <code>Optional[bytes]</code> <p>Optional additional authenticated data</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes</code> <p>Nonce + ciphertext + tag</p> Source code in <code>quantum_resistant_p2p\\crypto\\symmetric.py</code> <pre><code>def encrypt(self, key: bytes, plaintext: bytes, associated_data: Optional[bytes] = None) -&gt; bytes:\n    \"\"\"Encrypt data using AES-256-GCM.\n\n    Args:\n        key: The 256-bit AES key\n        plaintext: The data to encrypt\n        associated_data: Optional additional authenticated data\n\n    Returns:\n        Nonce + ciphertext + tag\n    \"\"\"\n    if len(key) != self.key_size:\n        raise ValueError(f\"Key must be {self.key_size} bytes, got {len(key)}\")\n\n    # Generate a random 96-bit (12-byte) nonce\n    nonce = os.urandom(12)\n\n    # Create the AES-GCM cipher\n    aesgcm = AESGCM(key)\n\n    # Encrypt the data\n    ciphertext = aesgcm.encrypt(nonce, plaintext, associated_data)\n\n    # Return nonce + ciphertext (including tag)\n    result = nonce + ciphertext\n\n    logger.debug(f\"AES-256-GCM encryption: {len(plaintext)} bytes plaintext -&gt; \"\n               f\"{len(result)} bytes ciphertext (includes {len(nonce)} bytes nonce)\")\n\n    return result\n</code></pre> <code>decrypt(key, ciphertext, associated_data=None)</code> \u00b6 <p>Decrypt data using AES-256-GCM.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes</code> <p>The 256-bit AES key</p> required <code>ciphertext</code> <code>bytes</code> <p>Nonce + ciphertext + tag</p> required <code>associated_data</code> <code>Optional[bytes]</code> <p>Optional additional authenticated data</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The decrypted data</p> Source code in <code>quantum_resistant_p2p\\crypto\\symmetric.py</code> <pre><code>def decrypt(self, key: bytes, ciphertext: bytes, associated_data: Optional[bytes] = None) -&gt; bytes:\n    \"\"\"Decrypt data using AES-256-GCM.\n\n    Args:\n        key: The 256-bit AES key\n        ciphertext: Nonce + ciphertext + tag\n        associated_data: Optional additional authenticated data\n\n    Returns:\n        The decrypted data\n    \"\"\"\n    if len(key) != self.key_size:\n        raise ValueError(f\"Key must be {self.key_size} bytes, got {len(key)}\")\n\n    if len(ciphertext) &lt; 12:  # Nonce is 12 bytes\n        raise ValueError(f\"Ciphertext too short: {len(ciphertext)} bytes, need at least 12 bytes for nonce\")\n\n    # Extract the nonce (first 12 bytes)\n    nonce = ciphertext[:12]\n    # Extract the actual ciphertext (including tag)\n    actual_ciphertext = ciphertext[12:]\n\n    # Create the AES-GCM cipher\n    aesgcm = AESGCM(key)\n\n    # Decrypt the data\n    try:\n        plaintext = aesgcm.decrypt(nonce, actual_ciphertext, associated_data)\n\n        logger.debug(f\"AES-256-GCM decryption: {len(ciphertext)} bytes ciphertext -&gt; \"\n                   f\"{len(plaintext)} bytes plaintext\")\n\n        return plaintext\n    except Exception as e:\n        logger.error(f\"AES-256-GCM decryption failed: {e}\")\n        raise ValueError(\"Authentication failed or decryption error\") from e\n</code></pre>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.ChaCha20Poly1305","title":"<code>ChaCha20Poly1305</code>","text":"<p>               Bases: <code>SymmetricAlgorithm</code></p> <p>ChaCha20-Poly1305 for authenticated encryption.</p>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.ChaCha20Poly1305-attributes","title":"Attributes","text":"<code>name</code> <code>property</code> \u00b6 <p>Get the name of the algorithm.</p> <code>description</code> <code>property</code> \u00b6 <p>Get a description of the algorithm.</p> <code>key_size</code> <code>property</code> \u00b6 <p>Get the key size in bytes.</p>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.ChaCha20Poly1305-functions","title":"Functions","text":"<code>generate_key()</code> \u00b6 <p>Generate a new random ChaCha20 key.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>A new 256-bit (32-byte) key</p> Source code in <code>quantum_resistant_p2p\\crypto\\symmetric.py</code> <pre><code>def generate_key(self) -&gt; bytes:\n    \"\"\"Generate a new random ChaCha20 key.\n\n    Returns:\n        A new 256-bit (32-byte) key\n    \"\"\"\n    key = os.urandom(self.key_size)\n    logger.debug(f\"Generated new ChaCha20 key ({self.key_size} bytes)\")\n    return key\n</code></pre> <code>encrypt(key, plaintext, associated_data=None)</code> \u00b6 <p>Encrypt data using ChaCha20-Poly1305.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes</code> <p>The 256-bit ChaCha20 key</p> required <code>plaintext</code> <code>bytes</code> <p>The data to encrypt</p> required <code>associated_data</code> <code>Optional[bytes]</code> <p>Optional additional authenticated data</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes</code> <p>Nonce + ciphertext + tag</p> Source code in <code>quantum_resistant_p2p\\crypto\\symmetric.py</code> <pre><code>def encrypt(self, key: bytes, plaintext: bytes, associated_data: Optional[bytes] = None) -&gt; bytes:\n    \"\"\"Encrypt data using ChaCha20-Poly1305.\n\n    Args:\n        key: The 256-bit ChaCha20 key\n        plaintext: The data to encrypt\n        associated_data: Optional additional authenticated data\n\n    Returns:\n        Nonce + ciphertext + tag\n    \"\"\"\n    if len(key) != self.key_size:\n        raise ValueError(f\"Key must be {self.key_size} bytes, got {len(key)}\")\n\n    # Generate a random 96-bit (12-byte) nonce\n    nonce = os.urandom(12)\n\n    # Create the ChaCha20-Poly1305 cipher\n    chacha = ChaCha20Poly1305Cipher(key)\n\n    # Encrypt the data\n    ciphertext = chacha.encrypt(nonce, plaintext, associated_data)\n\n    # Return nonce + ciphertext (including tag)\n    result = nonce + ciphertext\n\n    logger.debug(f\"ChaCha20-Poly1305 encryption: {len(plaintext)} bytes plaintext -&gt; \"\n               f\"{len(result)} bytes ciphertext (includes {len(nonce)} bytes nonce)\")\n\n    return result\n</code></pre> <code>decrypt(key, ciphertext, associated_data=None)</code> \u00b6 <p>Decrypt data using ChaCha20-Poly1305.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes</code> <p>The 256-bit ChaCha20 key</p> required <code>ciphertext</code> <code>bytes</code> <p>Nonce + ciphertext + tag</p> required <code>associated_data</code> <code>Optional[bytes]</code> <p>Optional additional authenticated data</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The decrypted data</p> Source code in <code>quantum_resistant_p2p\\crypto\\symmetric.py</code> <pre><code>def decrypt(self, key: bytes, ciphertext: bytes, associated_data: Optional[bytes] = None) -&gt; bytes:\n    \"\"\"Decrypt data using ChaCha20-Poly1305.\n\n    Args:\n        key: The 256-bit ChaCha20 key\n        ciphertext: Nonce + ciphertext + tag\n        associated_data: Optional additional authenticated data\n\n    Returns:\n        The decrypted data\n    \"\"\"\n    if len(key) != self.key_size:\n        raise ValueError(f\"Key must be {self.key_size} bytes, got {len(key)}\")\n\n    if len(ciphertext) &lt; 12:  # Nonce is 12 bytes\n        raise ValueError(f\"Ciphertext too short: {len(ciphertext)} bytes, need at least 12 bytes for nonce\")\n\n    # Extract the nonce (first 12 bytes)\n    nonce = ciphertext[:12]\n    # Extract the actual ciphertext (including tag)\n    actual_ciphertext = ciphertext[12:]\n\n    # Create the ChaCha20-Poly1305 cipher\n    chacha = ChaCha20Poly1305Cipher(key)\n\n    # Decrypt the data\n    try:\n        plaintext = chacha.decrypt(nonce, actual_ciphertext, associated_data)\n\n        logger.debug(f\"ChaCha20-Poly1305 decryption: {len(ciphertext)} bytes ciphertext -&gt; \"\n                   f\"{len(plaintext)} bytes plaintext\")\n\n        return plaintext\n    except Exception as e:\n        logger.error(f\"ChaCha20-Poly1305 decryption failed: {e}\")\n        raise ValueError(\"Authentication failed or decryption error\") from e\n</code></pre>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.SignatureAlgorithm","title":"<code>SignatureAlgorithm</code>","text":"<p>               Bases: <code>CryptoAlgorithm</code></p> <p>Abstract base class for digital signature algorithms.</p>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.SignatureAlgorithm-functions","title":"Functions","text":"<code>generate_keypair()</code> <code>abstractmethod</code> \u00b6 <p>Generate a new keypair.</p> <p>Returns:</p> Type Description <code>Tuple[bytes, bytes]</code> <p>Tuple of (public_key, private_key)</p> Source code in <code>quantum_resistant_p2p\\crypto\\signatures.py</code> <pre><code>@abc.abstractmethod\ndef generate_keypair(self) -&gt; Tuple[bytes, bytes]:\n    \"\"\"Generate a new keypair.\n\n    Returns:\n        Tuple of (public_key, private_key)\n    \"\"\"\n    pass\n</code></pre> <code>sign(private_key, message)</code> <code>abstractmethod</code> \u00b6 <p>Sign a message using the private key.</p> <p>Parameters:</p> Name Type Description Default <code>private_key</code> <code>bytes</code> <p>The private key for signing</p> required <code>message</code> <code>bytes</code> <p>The message to sign</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The signature</p> Source code in <code>quantum_resistant_p2p\\crypto\\signatures.py</code> <pre><code>@abc.abstractmethod\ndef sign(self, private_key: bytes, message: bytes) -&gt; bytes:\n    \"\"\"Sign a message using the private key.\n\n    Args:\n        private_key: The private key for signing\n        message: The message to sign\n\n    Returns:\n        The signature\n    \"\"\"\n    pass\n</code></pre> <code>verify(public_key, message, signature)</code> <code>abstractmethod</code> \u00b6 <p>Verify a signature using the public key.</p> <p>Parameters:</p> Name Type Description Default <code>public_key</code> <code>bytes</code> <p>The public key for verification</p> required <code>message</code> <code>bytes</code> <p>The message that was signed</p> required <code>signature</code> <code>bytes</code> <p>The signature to verify</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the signature is valid, False otherwise</p> Source code in <code>quantum_resistant_p2p\\crypto\\signatures.py</code> <pre><code>@abc.abstractmethod\ndef verify(self, public_key: bytes, message: bytes, signature: bytes) -&gt; bool:\n    \"\"\"Verify a signature using the public key.\n\n    Args:\n        public_key: The public key for verification\n        message: The message that was signed\n        signature: The signature to verify\n\n    Returns:\n        True if the signature is valid, False otherwise\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.MLDSASignature","title":"<code>MLDSASignature(security_level=3)</code>","text":"<p>               Bases: <code>SignatureAlgorithm</code></p> <p>ML-DSA (previously CRYSTALS-Dilithium) digital signature algorithm.</p> <p>ML-DSA is a post-quantum signature scheme based on the hardness of lattice problems.</p> <p>Initialize ML-DSA with the specified security level.</p> <p>Parameters:</p> Name Type Description Default <code>security_level</code> <code>int</code> <p>Security level (2, 3, or 5)</p> <code>3</code> Source code in <code>quantum_resistant_p2p\\crypto\\signatures.py</code> <pre><code>def __init__(self, security_level: int = 3):\n    \"\"\"Initialize ML-DSA with the specified security level.\n\n    Args:\n        security_level: Security level (2, 3, or 5)\n    \"\"\"\n    self.security_level = security_level\n    self.signer = None\n    self.variant = None\n\n    # Map security levels to ML-DSA variants\n    ml_dsa_variants = {\n        2: \"ML-DSA-44\",\n        3: \"ML-DSA-65\",\n        5: \"ML-DSA-87\"\n    }\n\n    # Also check older Dilithium names as fallback\n    dilithium_variants = {\n        2: \"Dilithium2\",\n        3: \"Dilithium3\",\n        5: \"Dilithium5\"\n    }\n\n    if security_level not in ml_dsa_variants:\n        raise ValueError(f\"Invalid security level: {security_level}. Must be 2, 3, or 5.\")\n\n    # Get enabled signature mechanisms\n    self.enabled_sigs = oqs.get_enabled_sig_mechanisms()\n\n    # Try to find an available variant\n    if ml_dsa_variants[security_level] in self.enabled_sigs:\n        self.variant = ml_dsa_variants[security_level]\n    elif dilithium_variants[security_level] in self.enabled_sigs:\n        # Use older Dilithium implementation if available\n        self.variant = dilithium_variants[security_level]\n    else:\n        raise ValueError(f\"No ML-DSA or Dilithium variant found for security level {security_level}\")\n\n    # Create the Signature instance\n    self.signer = oqs.Signature(self.variant)\n    logger.info(f\"Successfully initialized ML-DSA variant {self.variant}\")\n\n    logger.info(f\"Initialized ML-DSA signature with security level {security_level}\")\n</code></pre>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.MLDSASignature-attributes","title":"Attributes","text":"<code>name</code> <code>property</code> \u00b6 <p>Get the internal name of the algorithm.</p> <code>display_name</code> <code>property</code> \u00b6 <p>Get the user-friendly name for display.</p> <code>description</code> <code>property</code> \u00b6 <p>Get a description of the algorithm.</p>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.MLDSASignature-functions","title":"Functions","text":"<code>generate_keypair()</code> \u00b6 <p>Generate a new ML-DSA keypair.</p> <p>Returns:</p> Type Description <code>Tuple[bytes, bytes]</code> <p>Tuple of (public_key, private_key)</p> Source code in <code>quantum_resistant_p2p\\crypto\\signatures.py</code> <pre><code>def generate_keypair(self) -&gt; Tuple[bytes, bytes]:\n    \"\"\"Generate a new ML-DSA keypair.\n\n    Returns:\n        Tuple of (public_key, private_key)\n    \"\"\"\n    try:\n        # Use actual OQS implementation\n        public_key = self.signer.generate_keypair()\n        private_key = self.signer.export_secret_key()\n\n        logger.debug(f\"Generated ML-DSA keypair: public key {len(public_key)} bytes, \"\n                   f\"private key {len(private_key)} bytes\")\n\n        return public_key, private_key\n    except Exception as e:\n        logger.error(f\"Error generating ML-DSA keypair: {e}\")\n        raise\n</code></pre> <code>sign(private_key, message)</code> \u00b6 <p>Sign a message using ML-DSA.</p> <p>Parameters:</p> Name Type Description Default <code>private_key</code> <code>bytes</code> <p>The private key for signing</p> required <code>message</code> <code>bytes</code> <p>The message to sign</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The signature</p> Source code in <code>quantum_resistant_p2p\\crypto\\signatures.py</code> <pre><code>def sign(self, private_key: bytes, message: bytes) -&gt; bytes:\n    \"\"\"Sign a message using ML-DSA.\n\n    Args:\n        private_key: The private key for signing\n        message: The message to sign\n\n    Returns:\n        The signature\n    \"\"\"\n    try:\n        # Create a new signer with the private key\n        signer = oqs.Signature(self.variant, private_key)\n        signature = signer.sign(message)\n\n        logger.debug(f\"Created ML-DSA signature: {len(signature)} bytes\")\n\n        return signature\n    except Exception as e:\n        logger.error(f\"Error signing with ML-DSA: {e}\")\n        raise\n</code></pre> <code>verify(public_key, message, signature)</code> \u00b6 <p>Verify a ML-DSA signature.</p> <p>Parameters:</p> Name Type Description Default <code>public_key</code> <code>bytes</code> <p>The public key for verification</p> required <code>message</code> <code>bytes</code> <p>The message that was signed</p> required <code>signature</code> <code>bytes</code> <p>The signature to verify</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the signature is valid, False otherwise</p> Source code in <code>quantum_resistant_p2p\\crypto\\signatures.py</code> <pre><code>def verify(self, public_key: bytes, message: bytes, signature: bytes) -&gt; bool:\n    \"\"\"Verify a ML-DSA signature.\n\n    Args:\n        public_key: The public key for verification\n        message: The message that was signed\n        signature: The signature to verify\n\n    Returns:\n        True if the signature is valid, False otherwise\n    \"\"\"\n    try:\n        # Create a new verifier\n        verifier = oqs.Signature(self.variant)\n        result = verifier.verify(message, signature, public_key)\n\n        logger.debug(f\"ML-DSA signature verification: {'success' if result else 'failure'}\")\n\n        return result\n    except Exception as e:\n        logger.error(f\"Error verifying ML-DSA signature: {e}\")\n        return False\n</code></pre>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.SPHINCSSignature","title":"<code>SPHINCSSignature(security_level=3)</code>","text":"<p>               Bases: <code>SignatureAlgorithm</code></p> <p>SPHINCS+ digital signature algorithm.</p> <p>SPHINCS+ is a stateless hash-based signature scheme.</p> <p>Initialize SPHINCS+ with the specified security level.</p> <p>Parameters:</p> Name Type Description Default <code>security_level</code> <code>int</code> <p>Security level (1, 3, or 5)</p> <code>3</code> Source code in <code>quantum_resistant_p2p\\crypto\\signatures.py</code> <pre><code>def __init__(self, security_level: int = 3):\n    \"\"\"Initialize SPHINCS+ with the specified security level.\n\n    Args:\n        security_level: Security level (1, 3, or 5)\n    \"\"\"\n    self.security_level = security_level\n    self.signer = None\n    self.variant = None\n\n    # Map security levels to SPHINCS+ variants\n    sphincs_variants = {\n        1: [\"SPHINCS+-SHA2-128f-simple\"],\n        3: [\"SPHINCS+-SHA2-192f-simple\"],\n        5: [\"SPHINCS+-SHA2-256f-simple\"]\n    }\n\n    if security_level not in sphincs_variants:\n        raise ValueError(f\"Invalid security level: {security_level}. Must be 1, 3, or 5.\")\n\n    # Get enabled signature mechanisms\n    self.enabled_sigs = oqs.get_enabled_sig_mechanisms()\n\n    # Try to find an available variant\n    variant_found = False\n    for variant in sphincs_variants[security_level]:\n        if variant in self.enabled_sigs:\n            self.variant = variant\n            variant_found = True\n            break\n\n    if not variant_found:\n        raise ValueError(f\"No SPHINCS+ variant found for security level {security_level}\")\n\n    # Create the Signature instance\n    self.signer = oqs.Signature(self.variant)\n    logger.info(f\"Successfully initialized SPHINCS+ variant {self.variant}\")\n\n    logger.info(f\"Initialized SPHINCS+ signature with security level {security_level}\")\n</code></pre>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.SPHINCSSignature-attributes","title":"Attributes","text":"<code>name</code> <code>property</code> \u00b6 <p>Get the internal name of the algorithm.</p> <code>display_name</code> <code>property</code> \u00b6 <p>Get the user-friendly name for display.</p> <code>description</code> <code>property</code> \u00b6 <p>Get a description of the algorithm.</p>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.SPHINCSSignature-functions","title":"Functions","text":"<code>generate_keypair()</code> \u00b6 <p>Generate a new SPHINCS+ keypair.</p> <p>Returns:</p> Type Description <code>Tuple[bytes, bytes]</code> <p>Tuple of (public_key, private_key)</p> Source code in <code>quantum_resistant_p2p\\crypto\\signatures.py</code> <pre><code>def generate_keypair(self) -&gt; Tuple[bytes, bytes]:\n    \"\"\"Generate a new SPHINCS+ keypair.\n\n    Returns:\n        Tuple of (public_key, private_key)\n    \"\"\"\n    try:\n        # Use actual OQS implementation\n        public_key = self.signer.generate_keypair()\n        private_key = self.signer.export_secret_key()\n\n        logger.debug(f\"Generated SPHINCS+ keypair: public key {len(public_key)} bytes, \"\n                   f\"private key {len(private_key)} bytes\")\n\n        return public_key, private_key\n    except Exception as e:\n        logger.error(f\"Error generating SPHINCS+ keypair: {e}\")\n        raise\n</code></pre> <code>sign(private_key, message)</code> \u00b6 <p>Sign a message using SPHINCS+.</p> <p>Parameters:</p> Name Type Description Default <code>private_key</code> <code>bytes</code> <p>The private key for signing</p> required <code>message</code> <code>bytes</code> <p>The message to sign</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The signature</p> Source code in <code>quantum_resistant_p2p\\crypto\\signatures.py</code> <pre><code>def sign(self, private_key: bytes, message: bytes) -&gt; bytes:\n    \"\"\"Sign a message using SPHINCS+.\n\n    Args:\n        private_key: The private key for signing\n        message: The message to sign\n\n    Returns:\n        The signature\n    \"\"\"\n    try:\n        # Create a new signer with the private key\n        signer = oqs.Signature(self.variant, private_key)\n        signature = signer.sign(message)\n\n        logger.debug(f\"Created SPHINCS+ signature: {len(signature)} bytes\")\n\n        return signature\n    except Exception as e:\n        logger.error(f\"Error signing with SPHINCS+: {e}\")\n        raise\n</code></pre> <code>verify(public_key, message, signature)</code> \u00b6 <p>Verify a SPHINCS+ signature.</p> <p>Parameters:</p> Name Type Description Default <code>public_key</code> <code>bytes</code> <p>The public key for verification</p> required <code>message</code> <code>bytes</code> <p>The message that was signed</p> required <code>signature</code> <code>bytes</code> <p>The signature to verify</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the signature is valid, False otherwise</p> Source code in <code>quantum_resistant_p2p\\crypto\\signatures.py</code> <pre><code>def verify(self, public_key: bytes, message: bytes, signature: bytes) -&gt; bool:\n    \"\"\"Verify a SPHINCS+ signature.\n\n    Args:\n        public_key: The public key for verification\n        message: The message that was signed\n        signature: The signature to verify\n\n    Returns:\n        True if the signature is valid, False otherwise\n    \"\"\"\n    try:\n        # Create a new verifier\n        verifier = oqs.Signature(self.variant)\n        result = verifier.verify(message, signature, public_key)\n\n        logger.debug(f\"SPHINCS+ signature verification: {'success' if result else 'failure'}\")\n\n        return result\n    except Exception as e:\n        logger.error(f\"Error verifying SPHINCS+ signature: {e}\")\n        return False\n</code></pre>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.KeyStorage","title":"<code>KeyStorage(storage_path=None)</code>","text":"<p>Secure storage for cryptographic keys with full metadata encryption.</p> <p>This class provides complete encryption of all data and metadata, with no information leakage in the stored file. It uses Argon2id for key derivation and AES-GCM for encryption.</p> <p>Initialize a new key storage instance.</p> <p>Parameters:</p> Name Type Description Default <code>storage_path</code> <code>Optional[str]</code> <p>Path to the key storage file. If None, uses          ~/.quantum_resistant_p2p/keys.json.</p> <code>None</code> Source code in <code>quantum_resistant_p2p\\crypto\\key_storage.py</code> <pre><code>def __init__(self, storage_path: Optional[str] = None):\n    \"\"\"Initialize a new key storage instance.\n\n    Args:\n        storage_path: Path to the key storage file. If None, uses\n                     ~/.quantum_resistant_p2p/keys.json.\n    \"\"\"\n    if storage_path is None:\n        # Use default path in user's home directory\n        home_dir = Path.home()\n        storage_dir = home_dir / \".quantum_resistant_p2p\"\n        storage_dir.mkdir(exist_ok=True, parents=True)\n        self.storage_path = storage_dir / \"keys.json\"\n    else:\n        self.storage_path = Path(storage_path)\n        # Make sure parent directory exists\n        self.storage_path.parent.mkdir(exist_ok=True, parents=True)\n\n    # In-memory key storage\n    self.keys: Dict[str, Dict[str, Any]] = {}\n\n    # Cryptographic keys - all None until unlocked\n    self.master_key: Optional[bytes] = None\n    self.salt: Optional[bytes] = None\n    self.hmac_key: Optional[bytes] = None\n\n    # Create the secure file handler\n    self.secure_file = SecureFile(self.storage_path)\n\n    logger.info(f\"Key storage initialized at {self.storage_path}\")\n</code></pre>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.KeyStorage-functions","title":"Functions","text":"<code>unlock(password)</code> \u00b6 <p>Unlock the key storage with the given password.</p> <p>Parameters:</p> Name Type Description Default <code>password</code> <code>str</code> <p>The user's password</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if unlock successful, False otherwise</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_storage.py</code> <pre><code>def unlock(self, password: str) -&gt; bool:\n    \"\"\"Unlock the key storage with the given password.\n\n    Args:\n        password: The user's password\n\n    Returns:\n        True if unlock successful, False otherwise\n    \"\"\"\n    try:\n        # Read the storage file using SecureFile\n        data = self.secure_file.read_json()\n\n        if data is None:\n            # First time use, create a new storage file\n            self.salt = os.urandom(16)\n            self.master_key, _ = self._derive_key(password, self.salt)\n            self._derive_encryption_keys()\n            return self._save_storage()\n\n        # Check format version\n        format_version = data.get('format_version', 0)\n        if format_version != self.FORMAT_VERSION:\n            logger.error(f\"Unsupported storage format version: {format_version}\")\n            return False\n\n        if 'salt' not in data:\n            logger.error(\"Invalid key storage file, missing salt\")\n            return False\n\n        # Derive the master key from the password\n        salt = base64.b64decode(data['salt'])\n        derived_key, _ = self._derive_key(password, salt)\n\n        # Verify the password using the test value\n        if 'test_nonce' in data and 'test_ciphertext' in data:\n            try:\n                nonce = base64.b64decode(data['test_nonce'])\n                ciphertext = base64.b64decode(data['test_ciphertext'])\n\n                aesgcm = AESGCM(derived_key)\n                plaintext = aesgcm.decrypt(nonce, ciphertext, None)\n\n                if plaintext.decode() != \"test_value\":\n                    logger.error(\"Password verification failed\")\n                    return False\n            except Exception as e:\n                logger.error(f\"Failed to decrypt test value, wrong password? {e}\")\n                return False\n        else:\n            logger.error(\"Invalid key storage file, missing verification data\")\n            return False\n\n        # Password verified, set the keys\n        self.master_key = derived_key\n        self.salt = salt\n        self._derive_encryption_keys()\n\n        # Load the encrypted keys\n        if 'keys' not in data:\n            logger.warning(\"No keys found in storage\")\n            return True\n\n        aesgcm = AESGCM(self.master_key)\n\n        for entry_id, encrypted_key_data in data['keys'].items():\n            try:\n                # Decrypt the key data\n                nonce = base64.b64decode(encrypted_key_data['nonce'])\n                ciphertext = base64.b64decode(encrypted_key_data['ciphertext'])\n\n                key_data_json = aesgcm.decrypt(nonce, ciphertext, None)\n                key_data = json.loads(key_data_json.decode())\n\n                # Extract the original key_id from the decrypted data\n                if '__key_id' not in key_data:\n                    logger.error(f\"Missing key_id in entry {entry_id}, skipping\")\n                    continue\n\n                key_id = key_data.pop('__key_id')  # Remove the special marker\n                self.keys[key_id] = key_data\n\n            except Exception as e:\n                logger.error(f\"Failed to decrypt key {entry_id}: {e}\")\n\n        logger.info(f\"Unlocked key storage with {len(self.keys)} keys\")\n        return True\n\n    except Exception as e:\n        logger.error(f\"Failed to unlock key storage: {e}\")\n        return False\n</code></pre> <code>derive_purpose_key(purpose)</code> \u00b6 <p>Derive a special-purpose key from the master key.</p> <p>Parameters:</p> Name Type Description Default <code>purpose</code> <code>str</code> <p>A string identifier for the key's purpose</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>A derived key for the specified purpose</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_storage.py</code> <pre><code>def derive_purpose_key(self, purpose: str) -&gt; bytes:\n    \"\"\"Derive a special-purpose key from the master key.\n\n    Args:\n        purpose: A string identifier for the key's purpose\n\n    Returns:\n        A derived key for the specified purpose\n    \"\"\"\n    if self.master_key is None:\n        logger.error(\"Cannot derive purpose key, storage not unlocked\")\n        return None\n\n    # Derive a purpose-specific key using HMAC\n    purpose_key = hmac.new(\n        key=self.master_key,\n        msg=purpose.encode(),\n        digestmod=hashlib.sha256\n    ).digest()\n\n    logger.debug(f\"Derived purpose key for: {purpose}\")\n    return purpose_key\n</code></pre> <code>get_or_create_persistent_key(purpose, key_size=32)</code> \u00b6 <p>Get or create a persistent purpose-specific key that survives password changes.</p> <p>Unlike <code>derive_purpose_key</code> which derives a key from the master key (and thus changes when the password changes), this method creates a persistent random key that is stored in the key storage and survives password changes.</p> <p>Parameters:</p> Name Type Description Default <code>purpose</code> <code>str</code> <p>A string identifier for the key's purpose (used as key_id)</p> required <code>key_size</code> <code>int</code> <p>The size of the key to generate if needed, in bytes</p> <code>32</code> <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>The persistent key, or None if storage is not unlocked or an error occurred</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_storage.py</code> <pre><code>def get_or_create_persistent_key(self, purpose: str, key_size: int = 32) -&gt; Optional[bytes]:\n    \"\"\"Get or create a persistent purpose-specific key that survives password changes.\n\n    Unlike `derive_purpose_key` which derives a key from the master key (and thus\n    changes when the password changes), this method creates a persistent random key\n    that is stored in the key storage and survives password changes.\n\n    Args:\n        purpose: A string identifier for the key's purpose (used as key_id)\n        key_size: The size of the key to generate if needed, in bytes\n\n    Returns:\n        The persistent key, or None if storage is not unlocked or an error occurred\n    \"\"\"\n    if self.master_key is None:\n        logger.error(\"Cannot get or create persistent key, storage not unlocked\")\n        return None\n\n    # Create a deterministic key_id based on the purpose\n    key_id = f\"system_persistent_key_{purpose}\"\n\n    try:\n        # Try to get an existing key\n        key_data = self.get_key(key_id)\n\n        if key_data is None:\n            # No existing key found, generate a new one\n            logger.info(f\"No persistent key found for purpose '{purpose}', generating new key\")\n\n            # Generate a random key of the specified size\n            import os\n            new_key = os.urandom(key_size)\n\n            # Store the key with metadata\n            key_stored = self.store_key(key_id, {\n                \"key\": new_key,\n                \"purpose\": purpose,\n                \"created_at\": time.time(),\n                \"key_size\": key_size,\n                \"description\": f\"Persistent key for {purpose}\"\n            })\n\n            if not key_stored:\n                logger.error(f\"Failed to store persistent key for purpose '{purpose}'\")\n                return None\n\n            logger.info(f\"Generated and stored new persistent key for purpose '{purpose}'\")\n            return new_key\n        else:\n            # Use existing key\n            stored_key = key_data.get(\"key\")\n\n            # Validate the key\n            if not isinstance(stored_key, bytes) or len(stored_key) &lt; 16:\n                # Invalid key format, generate a new one\n                logger.warning(f\"Invalid persistent key format for purpose '{purpose}', regenerating\")\n\n                # Generate a new random key\n                import os\n                new_key = os.urandom(key_size)\n\n                # Store the new key\n                key_stored = self.store_key(key_id, {\n                    \"key\": new_key,\n                    \"purpose\": purpose,\n                    \"created_at\": time.time(),\n                    \"key_size\": key_size,\n                    \"description\": f\"Persistent key for {purpose} (regenerated)\"\n                })\n\n                if not key_stored:\n                    logger.error(f\"Failed to store regenerated persistent key for purpose '{purpose}'\")\n                    return None\n\n                logger.info(f\"Regenerated persistent key for purpose '{purpose}'\")\n                return new_key\n            else:\n                logger.debug(f\"Using existing persistent key for purpose '{purpose}'\")\n                return stored_key\n\n    except Exception as e:\n        logger.error(f\"Error managing persistent key for purpose '{purpose}': {e}\", exc_info=True)\n        return None\n</code></pre> <code>change_password(old_password, new_password)</code> \u00b6 <p>Change the password for the key storage.</p> <p>Parameters:</p> Name Type Description Default <code>old_password</code> <code>str</code> <p>The current password</p> required <code>new_password</code> <code>str</code> <p>The new password</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if password change successful, False otherwise</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_storage.py</code> <pre><code>def change_password(self, old_password: str, new_password: str) -&gt; bool:\n    \"\"\"Change the password for the key storage.\n\n    Args:\n        old_password: The current password\n        new_password: The new password\n\n    Returns:\n        True if password change successful, False otherwise\n    \"\"\"\n    # First unlock with the old password\n    if not self.unlock(old_password):\n        logger.error(\"Failed to unlock storage with old password\")\n        return False\n\n    # Generate a new master key with the new password\n    self.master_key, self.salt = self._derive_key(new_password)\n    self._derive_encryption_keys()\n\n    # Save the storage with the new master key\n    return self._save_storage()\n</code></pre> <code>reset_storage(new_password, create_backup=False)</code> \u00b6 <p>Reset the key storage with a new password, deleting all existing keys and logs.</p> <p>This is a destructive operation that erases all keys, logs, and creates a fresh key storage with the new password. Use only when the original password is forgotten and data loss is acceptable.</p> <p>Parameters:</p> Name Type Description Default <code>new_password</code> <code>str</code> <p>The new password to use</p> required <code>create_backup</code> <code>bool</code> <p>Whether to create a backup of the old storage (default: False)</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if reset successful, False otherwise</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_storage.py</code> <pre><code>def reset_storage(self, new_password: str, create_backup: bool = False) -&gt; bool:\n    \"\"\"Reset the key storage with a new password, deleting all existing keys and logs.\n\n    This is a destructive operation that erases all keys, logs, and creates a fresh\n    key storage with the new password. Use only when the original password\n    is forgotten and data loss is acceptable.\n\n    Args:\n        new_password: The new password to use\n        create_backup: Whether to create a backup of the old storage (default: False)\n\n    Returns:\n        True if reset successful, False otherwise\n    \"\"\"\n    try:\n        # Create backup of existing key storage if requested\n        if create_backup and self.storage_path.exists():\n            backup_path = self.storage_path.with_suffix(self.storage_path.suffix + '.old')\n            try:\n                import shutil\n                shutil.copy2(self.storage_path, backup_path)\n                logger.info(f\"Created backup of key storage at {backup_path}\")\n            except Exception as e:\n                logger.error(f\"Failed to create backup: {e}\")\n\n        # Delete the existing key storage files\n        try:\n            if self.storage_path.exists():\n                os.remove(self.storage_path)\n                logger.info(f\"Deleted key storage file: {self.storage_path}\")\n\n            # Also check for lock and backup files\n            lock_path = self.storage_path.with_suffix(self.storage_path.suffix + '.lock')\n            if lock_path.exists():\n                os.remove(lock_path)\n                logger.info(f\"Deleted lock file: {lock_path}\")\n\n            regular_backup = self.storage_path.with_suffix(self.storage_path.suffix + '.bak')\n            if regular_backup.exists():\n                os.remove(regular_backup)\n                logger.info(f\"Deleted regular backup file: {regular_backup}\")\n\n            # Delete any other backups\n            old_backup = self.storage_path.with_suffix(self.storage_path.suffix + '.old')\n            if old_backup.exists():\n                os.remove(old_backup)\n                logger.info(f\"Deleted old backup file: {old_backup}\")\n\n        except Exception as e:\n            logger.error(f\"Error removing old storage files: {e}\")\n            return False\n\n        # Delete secure logs\n        try:\n            # Get the logs directory (same location as key storage but in 'logs' subdirectory)\n            logs_dir = self.storage_path.parent / \"logs\"\n            if logs_dir.exists() and logs_dir.is_dir():\n                import glob\n                import shutil\n\n                # Delete all log files first\n                log_files = glob.glob(str(logs_dir / \"*.log\"))\n                for log_file in log_files:\n                    try:\n                        os.remove(log_file)\n                        logger.info(f\"Deleted log file: {log_file}\")\n                    except Exception as e:\n                        logger.warning(f\"Failed to delete log file {log_file}: {e}\")\n\n                # Delete any encryption keys for logs\n                key_files = glob.glob(str(logs_dir.parent / \"log_encryption_key*\"))\n                for key_file in key_files:\n                    try:\n                        os.remove(key_file)\n                        logger.info(f\"Deleted log encryption key: {key_file}\")\n                    except Exception as e:\n                        logger.warning(f\"Failed to delete log encryption key {key_file}: {e}\")\n\n                logger.info(\"Deleted secure logs\")\n        except Exception as e:\n            logger.error(f\"Error deleting secure logs: {e}\")\n            # Continue with reset even if log deletion fails\n\n        # Clear any existing keys from memory\n        self.keys = {}\n        self.master_key = None\n        self.salt = None\n        self.hmac_key = None\n\n        # Create a new key storage with the new password\n        success = self.unlock(new_password)\n\n        if success:\n            logger.info(\"Key storage reset successfully with new password\")\n            return True\n        else:\n            logger.error(\"Failed to initialize new key storage\")\n            return False\n\n    except Exception as e:\n        logger.error(f\"Failed to reset key storage: {e}\")\n        return False\n</code></pre> <code>store_key(key_id, key_data)</code> \u00b6 <p>Store a key in the key storage.</p> <p>Parameters:</p> Name Type Description Default <code>key_id</code> <code>str</code> <p>A unique identifier for the key</p> required <code>key_data</code> <code>Dict[str, Any]</code> <p>The key data to store</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if key stored successfully, False otherwise</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_storage.py</code> <pre><code>def store_key(self, key_id: str, key_data: Dict[str, Any]) -&gt; bool:\n    \"\"\"Store a key in the key storage.\n\n    Args:\n        key_id: A unique identifier for the key\n        key_data: The key data to store\n\n    Returns:\n        True if key stored successfully, False otherwise\n    \"\"\"\n    if self.master_key is None:\n        logger.error(\"Cannot store key, storage not unlocked\")\n        return False\n\n    try:\n        # Add metadata\n        key_data_with_meta = key_data.copy()\n        key_data_with_meta['created_at'] = time.time()\n\n        # Store the key in memory\n        self.keys[key_id] = key_data_with_meta\n\n        # Save to disk\n        return self._save_storage()\n\n    except Exception as e:\n        logger.error(f\"Failed to store key {key_id}: {e}\")\n        return False\n</code></pre> <code>get_key(key_id)</code> \u00b6 <p>Retrieve a key from the key storage.</p> <p>Parameters:</p> Name Type Description Default <code>key_id</code> <code>str</code> <p>The identifier of the key to retrieve</p> required <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>The key data, or None if not found</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_storage.py</code> <pre><code>def get_key(self, key_id: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Retrieve a key from the key storage.\n\n    Args:\n        key_id: The identifier of the key to retrieve\n\n    Returns:\n        The key data, or None if not found\n    \"\"\"\n    if self.master_key is None:\n        logger.error(\"Cannot get key, storage not unlocked\")\n        return None\n\n    if key_id not in self.keys:\n        return None\n\n    # Get the key data\n    key_data = self.keys[key_id].copy()\n\n    # Convert base64 strings back to binary data\n    decoded_data = {}\n    for k, v in key_data.items():\n        if isinstance(v, str):\n            # For known binary fields, always try to decode\n            common_binary_fields = ['key', 'public_key', 'private_key', 'shared_key', \n                                    'ciphertext', 'signature', 'original_shared_secret']\n\n            if k in common_binary_fields:\n                try:\n                    decoded_data[k] = base64.b64decode(v)\n                    continue\n                except Exception:\n                    # Not base64 encoded, will use as is below\n                    pass\n\n            # For other fields, check if it looks like base64 (length multiple of 4,\n            # only contains valid base64 characters)\n            if len(v) &gt; 0 and len(v) % 4 == 0 and all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in v):\n                try:\n                    # Try to decode it\n                    decoded = base64.b64decode(v)\n                    # Only use the decoded value if it looks like binary data\n                    # (contains bytes that aren't printable ASCII)\n                    if any(b &lt; 32 or b &gt; 126 for b in decoded):\n                        decoded_data[k] = decoded\n                        continue\n                except:\n                    # If decoding fails, use the original string\n                    pass\n\n            # If we got here, use the string value as-is\n            decoded_data[k] = v\n        else:\n            # Non-string value (int, bool, etc)\n            decoded_data[k] = v\n\n    return decoded_data\n</code></pre> <code>delete_key(key_id)</code> \u00b6 <p>Delete a key from the key storage.</p> <p>Parameters:</p> Name Type Description Default <code>key_id</code> <code>str</code> <p>The identifier of the key to delete</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if key deleted successfully, False otherwise</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_storage.py</code> <pre><code>def delete_key(self, key_id: str) -&gt; bool:\n    \"\"\"Delete a key from the key storage.\n\n    Args:\n        key_id: The identifier of the key to delete\n\n    Returns:\n        True if key deleted successfully, False otherwise\n    \"\"\"\n    if self.master_key is None:\n        logger.error(\"Cannot delete key, storage not unlocked\")\n        return False\n\n    if key_id not in self.keys:\n        logger.warning(f\"Key {key_id} not found in storage\")\n        return False\n\n    try:\n        # Remove the key from memory\n        del self.keys[key_id]\n\n        # Save to disk to remove it from storage\n        return self._save_storage()\n\n    except Exception as e:\n        logger.error(f\"Failed to delete key {key_id}: {e}\")\n        return False\n</code></pre> <code>list_keys()</code> \u00b6 <p>List all keys in the key storage.</p> <p>Returns:</p> Type Description <code>List[Tuple[str, Dict[str, Any]]]</code> <p>List of tuples (key_id, key_data)</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_storage.py</code> <pre><code>def list_keys(self) -&gt; List[Tuple[str, Dict[str, Any]]]:\n    \"\"\"List all keys in the key storage.\n\n    Returns:\n        List of tuples (key_id, key_data)\n    \"\"\"\n    if self.master_key is None:\n        logger.error(\"Cannot list keys, storage not unlocked\")\n        return []\n\n    # Create a list of (key_id, key_data) tuples\n    # Convert any base64 strings to bytes in the key data\n    result = []\n    for key_id, key_data in self.keys.items():\n        decoded_data = {}\n        for k, v in key_data.items():\n            if isinstance(v, str) and k in ['public_key', 'private_key', 'shared_key']:\n                try:\n                    decoded_data[k] = base64.b64decode(v)\n                except Exception:\n                    decoded_data[k] = v\n            else:\n                decoded_data[k] = v\n        result.append((key_id, decoded_data))\n\n    return result\n</code></pre> <code>get_key_history(decrypt_keys=False)</code> \u00b6 <p>Get a list of all saved key history.</p> <p>Parameters:</p> Name Type Description Default <code>decrypt_keys</code> <p>Whether to decrypt the key data (default: False)</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of dictionaries containing key history information</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_storage.py</code> <pre><code>def get_key_history(self, decrypt_keys=False) -&gt; List[Dict[str, Any]]:\n    \"\"\"Get a list of all saved key history.\n\n    Args:\n        decrypt_keys: Whether to decrypt the key data (default: False)\n\n    Returns:\n        List of dictionaries containing key history information\n    \"\"\"\n    if self.master_key is None:\n        logger.error(\"Cannot get key history, storage not unlocked\")\n        return []\n\n    history = []\n    for key_id, key_data in self.keys.items():\n        if key_id.startswith(\"peer_shared_key_\"):\n            # Extract and convert relevant information\n            display_data = key_data.copy()\n\n            # Only include encrypted_key_data for later decryption\n            encrypted_data = None\n\n            # Store the raw encrypted data for later decryption if needed\n            if \"shared_key\" in display_data:\n                # Remember if it's already bytes or needs to be decoded from base64\n                if isinstance(display_data[\"shared_key\"], str):\n                    try:\n                        encrypted_data = {\"type\": \"base64\", \"data\": display_data[\"shared_key\"]}\n                    except:\n                        encrypted_data = {\"type\": \"string\", \"data\": display_data[\"shared_key\"]}\n                else:\n                    encrypted_data = {\"type\": \"bytes\", \"data\": display_data[\"shared_key\"]}\n\n                # Generate a preview if it's going to be displayed\n                if decrypt_keys and isinstance(display_data[\"shared_key\"], bytes):\n                    display_data[\"shared_key_preview\"] = display_data[\"shared_key\"][:16].hex()\n                else:\n                    display_data[\"shared_key_preview\"] = \"(encrypted)\"\n\n            entry = {\n                \"key_id\": key_id,\n                \"peer_id\": display_data.get(\"peer_id\", \"Unknown\"),\n                \"algorithm\": display_data.get(\"algorithm\", \"Unknown\"),\n                \"symmetric_algorithm\": display_data.get(\"symmetric_algorithm\", \"Unknown\"),\n                \"created_at\": display_data.get(\"created_at\", 0),\n                \"key_preview\": display_data.get(\"shared_key_preview\", \"\"),\n                \"encrypted_key_data\": encrypted_data  # Store encrypted data instead of decrypted\n            }\n\n            # Only include full_key if explicitly requested\n            if decrypt_keys and \"shared_key\" in display_data:\n                if isinstance(display_data[\"shared_key\"], bytes):\n                    entry[\"full_key\"] = display_data[\"shared_key\"]\n                elif isinstance(display_data[\"shared_key\"], str):\n                    try:\n                        entry[\"full_key\"] = base64.b64decode(display_data[\"shared_key\"])\n                    except:\n                        entry[\"full_key\"] = display_data[\"shared_key\"].encode('utf-8')\n\n            history.append(entry)\n\n    # Sort by creation time, newest first\n    history.sort(key=lambda x: x[\"created_at\"], reverse=True)\n    return history\n</code></pre> <code>decrypt_key(key_id)</code> \u00b6 <p>Decrypt a specific key by ID.</p> <p>Parameters:</p> Name Type Description Default <code>key_id</code> <code>str</code> <p>The ID of the key to decrypt</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>The decrypted key as bytes, or None if not found/cannot decrypt</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_storage.py</code> <pre><code>def decrypt_key(self, key_id: str) -&gt; Optional[bytes]:\n    \"\"\"Decrypt a specific key by ID.\n\n    Args:\n        key_id: The ID of the key to decrypt\n\n    Returns:\n        The decrypted key as bytes, or None if not found/cannot decrypt\n    \"\"\"\n    if self.master_key is None:\n        logger.error(\"Cannot decrypt key, storage not unlocked\")\n        return None\n\n    # Log the decryption attempt\n    logger.info(f\"Decrypting key {key_id} from secure storage\")\n\n    # Retrieve the encrypted key data\n    key_data = self.get_key(key_id)\n    if not key_data or \"shared_key\" not in key_data:\n        logger.error(f\"Key {key_id} not found or has no shared_key\")\n        return None\n\n    # Return the already-decrypted data\n    shared_key = key_data[\"shared_key\"]\n    if isinstance(shared_key, bytes):\n        logger.info(f\"Successfully decrypted key {key_id}\")\n        return shared_key\n    elif isinstance(shared_key, str):\n        # Try to decode if it's base64 encoded\n        try:\n            decoded_key = base64.b64decode(shared_key)\n            logger.info(f\"Successfully decrypted key {key_id} (from base64)\")\n            return decoded_key\n        except:\n            # Not base64, use as is\n            logger.info(f\"Successfully decrypted key {key_id} (from string)\")\n            return shared_key.encode('utf-8')\n\n    logger.error(f\"Failed to decode key {key_id} (unknown format)\")\n    return None\n</code></pre> <code>close()</code> \u00b6 <p>Close the key storage and clear sensitive data from memory.</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_storage.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the key storage and clear sensitive data from memory.\"\"\"\n    if hasattr(self, 'master_key') and self.master_key:\n        self._secure_zero(self.master_key)\n        self.master_key = None\n\n    if hasattr(self, 'hmac_key') and self.hmac_key:\n        self._secure_zero(self.hmac_key)\n        self.hmac_key = None\n\n    self.keys = {}\n    self.salt = None\n\n    logger.info(\"Key storage closed and sensitive data cleared\")\n</code></pre>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.CryptoAlgorithm","title":"<code>CryptoAlgorithm</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for all cryptographic algorithms.</p>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.CryptoAlgorithm-attributes","title":"Attributes","text":"<code>name</code> <code>abstractmethod</code> <code>property</code> \u00b6 <p>Get the internal name of the algorithm.</p> <code>display_name</code> <code>property</code> \u00b6 <p>Get a user-friendly name of the algorithm for display in UI.</p> <code>description</code> <code>abstractmethod</code> <code>property</code> \u00b6 <p>Get a description of the algorithm.</p> <code>is_using_mock</code> <code>property</code> \u00b6 <p>Check if this algorithm is using a mock implementation.</p> <code>actual_variant</code> <code>property</code> \u00b6 <p>Get the actual OQS variant being used, if applicable.</p>"},{"location":"api/crypto/#quantum_resistant_p2p.crypto.CryptoAlgorithm-functions","title":"Functions","text":"<code>get_security_info()</code> \u00b6 <p>Get detailed security information about this algorithm.</p> Source code in <code>quantum_resistant_p2p\\crypto\\algorithm_base.py</code> <pre><code>def get_security_info(self) -&gt; dict:\n    \"\"\"Get detailed security information about this algorithm.\"\"\"\n    info = {\n        \"name\": self.display_name,\n        \"mock_implementation\": False,  # Always False now\n        \"description\": self.description\n    }\n\n    # Add variant information if available\n    if self.actual_variant:\n        info[\"actual_variant\"] = self.actual_variant\n\n    # Add security level if available\n    if hasattr(self, 'security_level'):\n        info[\"security_level\"] = getattr(self, 'security_level')\n\n    return info\n</code></pre>"},{"location":"api/crypto/algorithm_base/","title":"Algorithm Base Module","text":"<p>Base classes for cryptographic algorithms. This module provides the abstract base classes for all cryptographic algorithm implementations.</p>"},{"location":"api/crypto/algorithm_base/#quantum_resistant_p2p.crypto.algorithm_base","title":"<code>quantum_resistant_p2p.crypto.algorithm_base</code>","text":"<p>Base classes for cryptographic algorithms.</p>"},{"location":"api/crypto/algorithm_base/#quantum_resistant_p2p.crypto.algorithm_base-classes","title":"Classes","text":""},{"location":"api/crypto/algorithm_base/#quantum_resistant_p2p.crypto.algorithm_base.CryptoAlgorithm","title":"<code>CryptoAlgorithm</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for all cryptographic algorithms.</p>"},{"location":"api/crypto/algorithm_base/#quantum_resistant_p2p.crypto.algorithm_base.CryptoAlgorithm-attributes","title":"Attributes","text":"<code>name</code> <code>abstractmethod</code> <code>property</code> \u00b6 <p>Get the internal name of the algorithm.</p> <code>display_name</code> <code>property</code> \u00b6 <p>Get a user-friendly name of the algorithm for display in UI.</p> <code>description</code> <code>abstractmethod</code> <code>property</code> \u00b6 <p>Get a description of the algorithm.</p> <code>is_using_mock</code> <code>property</code> \u00b6 <p>Check if this algorithm is using a mock implementation.</p> <code>actual_variant</code> <code>property</code> \u00b6 <p>Get the actual OQS variant being used, if applicable.</p>"},{"location":"api/crypto/algorithm_base/#quantum_resistant_p2p.crypto.algorithm_base.CryptoAlgorithm-functions","title":"Functions","text":"<code>get_security_info()</code> \u00b6 <p>Get detailed security information about this algorithm.</p> Source code in <code>quantum_resistant_p2p\\crypto\\algorithm_base.py</code> <pre><code>def get_security_info(self) -&gt; dict:\n    \"\"\"Get detailed security information about this algorithm.\"\"\"\n    info = {\n        \"name\": self.display_name,\n        \"mock_implementation\": False,  # Always False now\n        \"description\": self.description\n    }\n\n    # Add variant information if available\n    if self.actual_variant:\n        info[\"actual_variant\"] = self.actual_variant\n\n    # Add security level if available\n    if hasattr(self, 'security_level'):\n        info[\"security_level\"] = getattr(self, 'security_level')\n\n    return info\n</code></pre>"},{"location":"api/crypto/key_exchange/","title":"Key Exchange Module","text":"<p>Post-quantum key exchange algorithms. This module implements various post-quantum key exchange mechanisms for secure communication.</p>"},{"location":"api/crypto/key_exchange/#quantum_resistant_p2p.crypto.key_exchange","title":"<code>quantum_resistant_p2p.crypto.key_exchange</code>","text":"<p>Post-quantum key exchange algorithms.</p>"},{"location":"api/crypto/key_exchange/#quantum_resistant_p2p.crypto.key_exchange-classes","title":"Classes","text":""},{"location":"api/crypto/key_exchange/#quantum_resistant_p2p.crypto.key_exchange.KeyExchangeAlgorithm","title":"<code>KeyExchangeAlgorithm</code>","text":"<p>               Bases: <code>CryptoAlgorithm</code></p> <p>Abstract base class for key exchange algorithms.</p>"},{"location":"api/crypto/key_exchange/#quantum_resistant_p2p.crypto.key_exchange.KeyExchangeAlgorithm-functions","title":"Functions","text":"<code>generate_keypair()</code> <code>abstractmethod</code> \u00b6 <p>Generate a new keypair.</p> <p>Returns:</p> Type Description <code>Tuple[bytes, bytes]</code> <p>Tuple of (public_key, private_key)</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>@abc.abstractmethod\ndef generate_keypair(self) -&gt; Tuple[bytes, bytes]:\n    \"\"\"Generate a new keypair.\n\n    Returns:\n        Tuple of (public_key, private_key)\n    \"\"\"\n    pass\n</code></pre> <code>encapsulate(public_key)</code> <code>abstractmethod</code> \u00b6 <p>Encapsulate a shared secret using the recipient's public key.</p> <p>Parameters:</p> Name Type Description Default <code>public_key</code> <code>bytes</code> <p>The recipient's public key</p> required <p>Returns:</p> Type Description <code>Tuple[bytes, bytes]</code> <p>Tuple of (ciphertext, shared_secret)</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>@abc.abstractmethod\ndef encapsulate(self, public_key: bytes) -&gt; Tuple[bytes, bytes]:\n    \"\"\"Encapsulate a shared secret using the recipient's public key.\n\n    Args:\n        public_key: The recipient's public key\n\n    Returns:\n        Tuple of (ciphertext, shared_secret)\n    \"\"\"\n    pass\n</code></pre> <code>decapsulate(private_key, ciphertext)</code> <code>abstractmethod</code> \u00b6 <p>Decapsulate a shared secret using the recipient's private key.</p> <p>Parameters:</p> Name Type Description Default <code>private_key</code> <code>bytes</code> <p>The recipient's private key</p> required <code>ciphertext</code> <code>bytes</code> <p>The ciphertext from the sender</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The shared secret</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>@abc.abstractmethod\ndef decapsulate(self, private_key: bytes, ciphertext: bytes) -&gt; bytes:\n    \"\"\"Decapsulate a shared secret using the recipient's private key.\n\n    Args:\n        private_key: The recipient's private key\n        ciphertext: The ciphertext from the sender\n\n    Returns:\n        The shared secret\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/crypto/key_exchange/#quantum_resistant_p2p.crypto.key_exchange.MLKEMKeyExchange","title":"<code>MLKEMKeyExchange(security_level=3)</code>","text":"<p>               Bases: <code>KeyExchangeAlgorithm</code></p> <p>ML-KEM (previously CRYSTALS-Kyber) key exchange algorithm.</p> <p>ML-KEM is a post-quantum key encapsulation mechanism (KEM) based on the hardness of solving the learning-with-errors (LWE) problem over module lattices.</p> <p>Initialize ML-KEM with the specified security level.</p> <p>Parameters:</p> Name Type Description Default <code>security_level</code> <code>int</code> <p>Security level (1, 3, or 5)</p> <code>3</code> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>def __init__(self, security_level: int = 3):\n    \"\"\"Initialize ML-KEM with the specified security level.\n\n    Args:\n        security_level: Security level (1, 3, or 5)\n    \"\"\"\n    self.security_level = security_level\n    self.kem = None\n    self.variant = None\n\n    # Map security levels to ML-KEM variants\n    ml_kem_variants = {\n        1: \"ML-KEM-512\",\n        3: \"ML-KEM-768\",\n        5: \"ML-KEM-1024\"\n    }\n\n    # Also check for older Kyber names as a fallback\n    kyber_variants = {\n        1: \"Kyber512\",\n        3: \"Kyber768\",\n        5: \"Kyber1024\"\n    }\n\n    if security_level not in ml_kem_variants:\n        raise ValueError(f\"Invalid security level: {security_level}. Must be 1, 3, or 5.\")\n\n    # Determine available enabled KEM mechanisms\n    self.enabled_kems = oqs.get_enabled_kem_mechanisms()\n\n    # Try to find an available implementation\n    if ml_kem_variants[security_level] in self.enabled_kems:\n        self.variant = ml_kem_variants[security_level]\n    elif kyber_variants[security_level] in self.enabled_kems:\n        # Use older Kyber implementation if available\n        self.variant = kyber_variants[security_level]\n    else:\n        raise ValueError(f\"No ML-KEM or Kyber variant found for security level {security_level}\")\n\n    # Create the KEM instance\n    self.kem = oqs.KeyEncapsulation(self.variant)\n    logger.info(f\"Successfully initialized ML-KEM variant {self.variant}\")\n\n    logger.info(f\"Initialized ML-KEM key exchange with security level {security_level}\")\n</code></pre>"},{"location":"api/crypto/key_exchange/#quantum_resistant_p2p.crypto.key_exchange.MLKEMKeyExchange-attributes","title":"Attributes","text":"<code>name</code> <code>property</code> \u00b6 <p>Get the internal name of the algorithm.</p> <code>display_name</code> <code>property</code> \u00b6 <p>Get the user-friendly name for display.</p> <code>description</code> <code>property</code> \u00b6 <p>Get a description of the algorithm.</p>"},{"location":"api/crypto/key_exchange/#quantum_resistant_p2p.crypto.key_exchange.MLKEMKeyExchange-functions","title":"Functions","text":"<code>generate_keypair()</code> \u00b6 <p>Generate a new ML-KEM keypair.</p> <p>Returns:</p> Type Description <code>Tuple[bytes, bytes]</code> <p>Tuple of (public_key, private_key)</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>def generate_keypair(self) -&gt; Tuple[bytes, bytes]:\n    \"\"\"Generate a new ML-KEM keypair.\n\n    Returns:\n        Tuple of (public_key, private_key)\n    \"\"\"\n    try:\n        # Use actual OQS implementation\n        public_key = self.kem.generate_keypair()\n        private_key = self.kem.export_secret_key()\n\n        logger.debug(f\"Generated ML-KEM keypair: public key {len(public_key)} bytes, \"\n                  f\"private key {len(private_key)} bytes\")\n\n        return public_key, private_key\n    except Exception as e:\n        logger.error(f\"Error generating ML-KEM keypair: {e}\")\n        raise\n</code></pre> <code>encapsulate(public_key)</code> \u00b6 <p>Encapsulate a shared secret using the recipient's public key.</p> <p>Parameters:</p> Name Type Description Default <code>public_key</code> <code>bytes</code> <p>The recipient's public key</p> required <p>Returns:</p> Type Description <code>Tuple[bytes, bytes]</code> <p>Tuple of (ciphertext, shared_secret)</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>def encapsulate(self, public_key: bytes) -&gt; Tuple[bytes, bytes]:\n    \"\"\"Encapsulate a shared secret using the recipient's public key.\n\n    Args:\n        public_key: The recipient's public key\n\n    Returns:\n        Tuple of (ciphertext, shared_secret)\n    \"\"\"\n    try:\n        # Create a new instance for encapsulation\n        encap_kem = oqs.KeyEncapsulation(self.variant)\n        ciphertext, shared_secret = encap_kem.encap_secret(public_key)\n\n        logger.debug(f\"ML-KEM encapsulation: ciphertext {len(ciphertext)} bytes, \"\n                  f\"shared secret {len(shared_secret)} bytes\")\n\n        return ciphertext, shared_secret\n    except Exception as e:\n        logger.error(f\"Error during ML-KEM encapsulation: {e}\")\n        raise\n</code></pre> <code>decapsulate(private_key, ciphertext)</code> \u00b6 <p>Decapsulate a shared secret using the recipient's private key.</p> <p>Parameters:</p> Name Type Description Default <code>private_key</code> <code>bytes</code> <p>The recipient's private key</p> required <code>ciphertext</code> <code>bytes</code> <p>The ciphertext from the sender</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The shared secret</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>def decapsulate(self, private_key: bytes, ciphertext: bytes) -&gt; bytes:\n    \"\"\"Decapsulate a shared secret using the recipient's private key.\n\n    Args:\n        private_key: The recipient's private key\n        ciphertext: The ciphertext from the sender\n\n    Returns:\n        The shared secret\n    \"\"\"\n    try:\n        # Create a new KEM instance with the private key for decapsulation\n        decap_kem = oqs.KeyEncapsulation(self.variant, private_key)\n        shared_secret = decap_kem.decap_secret(ciphertext)\n\n        logger.debug(f\"ML-KEM decapsulation: shared secret {len(shared_secret)} bytes\")\n\n        return shared_secret\n    except Exception as e:\n        logger.error(f\"Error during ML-KEM decapsulation: {e}\")\n        raise\n</code></pre>"},{"location":"api/crypto/key_exchange/#quantum_resistant_p2p.crypto.key_exchange.HQCKeyExchange","title":"<code>HQCKeyExchange(security_level=3)</code>","text":"<p>               Bases: <code>KeyExchangeAlgorithm</code></p> <p>HQC (Hamming Quasi-Cyclic) key exchange algorithm.</p> <p>HQC is a code-based post-quantum key encapsulation mechanism (KEM) based on the hardness of decoding problems in quasi-cyclic codes.</p> <p>Initialize HQC with the specified security level.</p> <p>Parameters:</p> Name Type Description Default <code>security_level</code> <code>int</code> <p>Security level (1 for 128-bit, 3 for 192-bit, 5 for 256-bit)</p> <code>3</code> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>def __init__(self, security_level: int = 3):\n    \"\"\"Initialize HQC with the specified security level.\n\n    Args:\n        security_level: Security level (1 for 128-bit, 3 for 192-bit, 5 for 256-bit)\n    \"\"\"\n    self.security_level = security_level\n    self.kem = None\n    self.variant = None\n\n    # Map security levels to HQC variants\n    hqc_variants = {\n        1: \"HQC-128\",\n        3: \"HQC-192\",\n        5: \"HQC-256\"\n    }\n\n    if security_level not in hqc_variants:\n        raise ValueError(f\"Invalid security level: {security_level}. Must be 1, 3, or 5.\")\n\n    # Determine available enabled KEM mechanisms\n    self.enabled_kems = oqs.get_enabled_kem_mechanisms()\n\n    # Try to find an available implementation\n    if hqc_variants[security_level] in self.enabled_kems:\n        self.variant = hqc_variants[security_level]\n    else:\n        raise ValueError(f\"No HQC variant found for security level {security_level}\")\n\n    # Create the KEM instance\n    self.kem = oqs.KeyEncapsulation(self.variant)\n    logger.info(f\"Successfully initialized HQC variant {self.variant}\")\n\n    logger.info(f\"Initialized HQC key exchange with security level {security_level}\")\n</code></pre>"},{"location":"api/crypto/key_exchange/#quantum_resistant_p2p.crypto.key_exchange.HQCKeyExchange-attributes","title":"Attributes","text":"<code>name</code> <code>property</code> \u00b6 <p>Get the internal name of the algorithm.</p> <code>display_name</code> <code>property</code> \u00b6 <p>Get the user-friendly name for display.</p> <code>description</code> <code>property</code> \u00b6 <p>Get a description of the algorithm.</p>"},{"location":"api/crypto/key_exchange/#quantum_resistant_p2p.crypto.key_exchange.HQCKeyExchange-functions","title":"Functions","text":"<code>generate_keypair()</code> \u00b6 <p>Generate a new HQC keypair.</p> <p>Returns:</p> Type Description <code>Tuple[bytes, bytes]</code> <p>Tuple of (public_key, private_key)</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>def generate_keypair(self) -&gt; Tuple[bytes, bytes]:\n    \"\"\"Generate a new HQC keypair.\n\n    Returns:\n        Tuple of (public_key, private_key)\n    \"\"\"\n    try:\n        # Use actual OQS implementation\n        public_key = self.kem.generate_keypair()\n        private_key = self.kem.export_secret_key()\n\n        logger.debug(f\"Generated HQC keypair: public key {len(public_key)} bytes, \"\n                  f\"private key {len(private_key)} bytes\")\n\n        return public_key, private_key\n    except Exception as e:\n        logger.error(f\"Error generating HQC keypair: {e}\")\n        raise\n</code></pre> <code>encapsulate(public_key)</code> \u00b6 <p>Encapsulate a shared secret using the recipient's public key.</p> <p>Parameters:</p> Name Type Description Default <code>public_key</code> <code>bytes</code> <p>The recipient's public key</p> required <p>Returns:</p> Type Description <code>Tuple[bytes, bytes]</code> <p>Tuple of (ciphertext, shared_secret)</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>def encapsulate(self, public_key: bytes) -&gt; Tuple[bytes, bytes]:\n    \"\"\"Encapsulate a shared secret using the recipient's public key.\n\n    Args:\n        public_key: The recipient's public key\n\n    Returns:\n        Tuple of (ciphertext, shared_secret)\n    \"\"\"\n    try:\n        # Create a new instance for encapsulation\n        encap_kem = oqs.KeyEncapsulation(self.variant)\n        ciphertext, shared_secret = encap_kem.encap_secret(public_key)\n\n        logger.debug(f\"HQC encapsulation: ciphertext {len(ciphertext)} bytes, \"\n                  f\"shared secret {len(shared_secret)} bytes\")\n\n        return ciphertext, shared_secret\n    except Exception as e:\n        logger.error(f\"Error during HQC encapsulation: {e}\")\n        raise\n</code></pre> <code>decapsulate(private_key, ciphertext)</code> \u00b6 <p>Decapsulate a shared secret using the recipient's private key.</p> <p>Parameters:</p> Name Type Description Default <code>private_key</code> <code>bytes</code> <p>The recipient's private key</p> required <code>ciphertext</code> <code>bytes</code> <p>The ciphertext from the sender</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The shared secret</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>def decapsulate(self, private_key: bytes, ciphertext: bytes) -&gt; bytes:\n    \"\"\"Decapsulate a shared secret using the recipient's private key.\n\n    Args:\n        private_key: The recipient's private key\n        ciphertext: The ciphertext from the sender\n\n    Returns:\n        The shared secret\n    \"\"\"\n    try:\n        # Create a new KEM instance with the private key for decapsulation\n        decap_kem = oqs.KeyEncapsulation(self.variant, private_key)\n        shared_secret = decap_kem.decap_secret(ciphertext)\n\n        logger.debug(f\"HQC decapsulation: shared secret {len(shared_secret)} bytes\")\n\n        return shared_secret\n    except Exception as e:\n        logger.error(f\"Error during HQC decapsulation: {e}\")\n        raise\n</code></pre>"},{"location":"api/crypto/key_exchange/#quantum_resistant_p2p.crypto.key_exchange.FrodoKEMKeyExchange","title":"<code>FrodoKEMKeyExchange(security_level=3, use_aes=True)</code>","text":"<p>               Bases: <code>KeyExchangeAlgorithm</code></p> <p>FrodoKEM key exchange algorithm.</p> <p>FrodoKEM is a lattice-based key encapsulation mechanism (KEM) based on the standard Learning With Errors problem without any additional structure.</p> <p>Initialize FrodoKEM with the specified security level.</p> <p>Parameters:</p> Name Type Description Default <code>security_level</code> <code>int</code> <p>Security level (1 for 640, 3 for 976, 5 for 1344)</p> <code>3</code> <code>use_aes</code> <code>bool</code> <p>Whether to use AES (True) or SHAKE (False) for randomness</p> <code>True</code> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>def __init__(self, security_level: int = 3, use_aes: bool = True):\n    \"\"\"Initialize FrodoKEM with the specified security level.\n\n    Args:\n        security_level: Security level (1 for 640, 3 for 976, 5 for 1344)\n        use_aes: Whether to use AES (True) or SHAKE (False) for randomness\n    \"\"\"\n    self.security_level = security_level\n    self.use_aes = use_aes\n    self.kem = None\n    self.variant = None\n\n    # Map security levels to FrodoKEM variants\n    if use_aes:\n        frodo_variants = {\n            1: \"FrodoKEM-640-AES\",\n            3: \"FrodoKEM-976-AES\",\n            5: \"FrodoKEM-1344-AES\"\n        }\n    else:\n        frodo_variants = {\n            1: \"FrodoKEM-640-SHAKE\",\n            3: \"FrodoKEM-976-SHAKE\",\n            5: \"FrodoKEM-1344-SHAKE\"\n        }\n\n    if security_level not in frodo_variants:\n        raise ValueError(f\"Invalid security level: {security_level}. Must be 1, 3, or 5.\")\n\n    # Determine available enabled KEM mechanisms\n    self.enabled_kems = oqs.get_enabled_kem_mechanisms()\n\n    # Try to find an available implementation\n    if frodo_variants[security_level] in self.enabled_kems:\n        self.variant = frodo_variants[security_level]\n    else:\n        # Try the other variant (AES vs SHAKE) if available\n        alt_variant = frodo_variants[security_level].replace('-AES', '-SHAKE') if use_aes else frodo_variants[security_level].replace('-SHAKE', '-AES')\n        if alt_variant in self.enabled_kems:\n            self.variant = alt_variant\n            logger.info(f\"Using alternative FrodoKEM variant: {alt_variant}\")\n        else:\n            raise ValueError(f\"No FrodoKEM variant found for security level {security_level}\")\n\n    # Create the KEM instance\n    self.kem = oqs.KeyEncapsulation(self.variant)\n    logger.info(f\"Successfully initialized FrodoKEM variant {self.variant}\")\n\n    logger.info(f\"Initialized FrodoKEM key exchange with security level {security_level}\")\n</code></pre>"},{"location":"api/crypto/key_exchange/#quantum_resistant_p2p.crypto.key_exchange.FrodoKEMKeyExchange-attributes","title":"Attributes","text":"<code>name</code> <code>property</code> \u00b6 <p>Get the internal name of the algorithm.</p> <code>display_name</code> <code>property</code> \u00b6 <p>Get the user-friendly name for display.</p> <code>description</code> <code>property</code> \u00b6 <p>Get a description of the algorithm.</p>"},{"location":"api/crypto/key_exchange/#quantum_resistant_p2p.crypto.key_exchange.FrodoKEMKeyExchange-functions","title":"Functions","text":"<code>generate_keypair()</code> \u00b6 <p>Generate a new FrodoKEM keypair.</p> <p>Returns:</p> Type Description <code>Tuple[bytes, bytes]</code> <p>Tuple of (public_key, private_key)</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>def generate_keypair(self) -&gt; Tuple[bytes, bytes]:\n    \"\"\"Generate a new FrodoKEM keypair.\n\n    Returns:\n        Tuple of (public_key, private_key)\n    \"\"\"\n    try:\n        # Use actual OQS implementation\n        public_key = self.kem.generate_keypair()\n        private_key = self.kem.export_secret_key()\n\n        logger.debug(f\"Generated FrodoKEM keypair: public key {len(public_key)} bytes, \"\n                  f\"private key {len(private_key)} bytes\")\n\n        return public_key, private_key\n    except Exception as e:\n        logger.error(f\"Error generating FrodoKEM keypair: {e}\")\n        raise\n</code></pre> <code>encapsulate(public_key)</code> \u00b6 <p>Encapsulate a shared secret using the recipient's public key.</p> <p>Parameters:</p> Name Type Description Default <code>public_key</code> <code>bytes</code> <p>The recipient's public key</p> required <p>Returns:</p> Type Description <code>Tuple[bytes, bytes]</code> <p>Tuple of (ciphertext, shared_secret)</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>def encapsulate(self, public_key: bytes) -&gt; Tuple[bytes, bytes]:\n    \"\"\"Encapsulate a shared secret using the recipient's public key.\n\n    Args:\n        public_key: The recipient's public key\n\n    Returns:\n        Tuple of (ciphertext, shared_secret)\n    \"\"\"\n    try:\n        # Create a new instance for encapsulation\n        encap_kem = oqs.KeyEncapsulation(self.variant)\n        ciphertext, shared_secret = encap_kem.encap_secret(public_key)\n\n        logger.debug(f\"FrodoKEM encapsulation: ciphertext {len(ciphertext)} bytes, \"\n                  f\"shared secret {len(shared_secret)} bytes\")\n\n        return ciphertext, shared_secret\n    except Exception as e:\n        logger.error(f\"Error during FrodoKEM encapsulation: {e}\")\n        raise\n</code></pre> <code>decapsulate(private_key, ciphertext)</code> \u00b6 <p>Decapsulate a shared secret using the recipient's private key.</p> <p>Parameters:</p> Name Type Description Default <code>private_key</code> <code>bytes</code> <p>The recipient's private key</p> required <code>ciphertext</code> <code>bytes</code> <p>The ciphertext from the sender</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The shared secret</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_exchange.py</code> <pre><code>def decapsulate(self, private_key: bytes, ciphertext: bytes) -&gt; bytes:\n    \"\"\"Decapsulate a shared secret using the recipient's private key.\n\n    Args:\n        private_key: The recipient's private key\n        ciphertext: The ciphertext from the sender\n\n    Returns:\n        The shared secret\n    \"\"\"\n    try:\n        # Create a new KEM instance with the private key for decapsulation\n        decap_kem = oqs.KeyEncapsulation(self.variant, private_key)\n        shared_secret = decap_kem.decap_secret(ciphertext)\n\n        logger.debug(f\"FrodoKEM decapsulation: shared secret {len(shared_secret)} bytes\")\n\n        return shared_secret\n    except Exception as e:\n        logger.error(f\"Error during FrodoKEM decapsulation: {e}\")\n        raise\n</code></pre>"},{"location":"api/crypto/key_storage/","title":"Key Storage Module","text":"<p>Secure storage for cryptographic keys with full metadata encryption. This module provides secure storage functionality with comprehensive encryption of both key data and metadata.</p>"},{"location":"api/crypto/key_storage/#quantum_resistant_p2p.crypto.key_storage","title":"<code>quantum_resistant_p2p.crypto.key_storage</code>","text":"<p>Secure storage for cryptographic keys with full metadata encryption.</p>"},{"location":"api/crypto/key_storage/#quantum_resistant_p2p.crypto.key_storage-classes","title":"Classes","text":""},{"location":"api/crypto/key_storage/#quantum_resistant_p2p.crypto.key_storage.KeyStorage","title":"<code>KeyStorage(storage_path=None)</code>","text":"<p>Secure storage for cryptographic keys with full metadata encryption.</p> <p>This class provides complete encryption of all data and metadata, with no information leakage in the stored file. It uses Argon2id for key derivation and AES-GCM for encryption.</p> <p>Initialize a new key storage instance.</p> <p>Parameters:</p> Name Type Description Default <code>storage_path</code> <code>Optional[str]</code> <p>Path to the key storage file. If None, uses          ~/.quantum_resistant_p2p/keys.json.</p> <code>None</code> Source code in <code>quantum_resistant_p2p\\crypto\\key_storage.py</code> <pre><code>def __init__(self, storage_path: Optional[str] = None):\n    \"\"\"Initialize a new key storage instance.\n\n    Args:\n        storage_path: Path to the key storage file. If None, uses\n                     ~/.quantum_resistant_p2p/keys.json.\n    \"\"\"\n    if storage_path is None:\n        # Use default path in user's home directory\n        home_dir = Path.home()\n        storage_dir = home_dir / \".quantum_resistant_p2p\"\n        storage_dir.mkdir(exist_ok=True, parents=True)\n        self.storage_path = storage_dir / \"keys.json\"\n    else:\n        self.storage_path = Path(storage_path)\n        # Make sure parent directory exists\n        self.storage_path.parent.mkdir(exist_ok=True, parents=True)\n\n    # In-memory key storage\n    self.keys: Dict[str, Dict[str, Any]] = {}\n\n    # Cryptographic keys - all None until unlocked\n    self.master_key: Optional[bytes] = None\n    self.salt: Optional[bytes] = None\n    self.hmac_key: Optional[bytes] = None\n\n    # Create the secure file handler\n    self.secure_file = SecureFile(self.storage_path)\n\n    logger.info(f\"Key storage initialized at {self.storage_path}\")\n</code></pre>"},{"location":"api/crypto/key_storage/#quantum_resistant_p2p.crypto.key_storage.KeyStorage-functions","title":"Functions","text":"<code>unlock(password)</code> \u00b6 <p>Unlock the key storage with the given password.</p> <p>Parameters:</p> Name Type Description Default <code>password</code> <code>str</code> <p>The user's password</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if unlock successful, False otherwise</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_storage.py</code> <pre><code>def unlock(self, password: str) -&gt; bool:\n    \"\"\"Unlock the key storage with the given password.\n\n    Args:\n        password: The user's password\n\n    Returns:\n        True if unlock successful, False otherwise\n    \"\"\"\n    try:\n        # Read the storage file using SecureFile\n        data = self.secure_file.read_json()\n\n        if data is None:\n            # First time use, create a new storage file\n            self.salt = os.urandom(16)\n            self.master_key, _ = self._derive_key(password, self.salt)\n            self._derive_encryption_keys()\n            return self._save_storage()\n\n        # Check format version\n        format_version = data.get('format_version', 0)\n        if format_version != self.FORMAT_VERSION:\n            logger.error(f\"Unsupported storage format version: {format_version}\")\n            return False\n\n        if 'salt' not in data:\n            logger.error(\"Invalid key storage file, missing salt\")\n            return False\n\n        # Derive the master key from the password\n        salt = base64.b64decode(data['salt'])\n        derived_key, _ = self._derive_key(password, salt)\n\n        # Verify the password using the test value\n        if 'test_nonce' in data and 'test_ciphertext' in data:\n            try:\n                nonce = base64.b64decode(data['test_nonce'])\n                ciphertext = base64.b64decode(data['test_ciphertext'])\n\n                aesgcm = AESGCM(derived_key)\n                plaintext = aesgcm.decrypt(nonce, ciphertext, None)\n\n                if plaintext.decode() != \"test_value\":\n                    logger.error(\"Password verification failed\")\n                    return False\n            except Exception as e:\n                logger.error(f\"Failed to decrypt test value, wrong password? {e}\")\n                return False\n        else:\n            logger.error(\"Invalid key storage file, missing verification data\")\n            return False\n\n        # Password verified, set the keys\n        self.master_key = derived_key\n        self.salt = salt\n        self._derive_encryption_keys()\n\n        # Load the encrypted keys\n        if 'keys' not in data:\n            logger.warning(\"No keys found in storage\")\n            return True\n\n        aesgcm = AESGCM(self.master_key)\n\n        for entry_id, encrypted_key_data in data['keys'].items():\n            try:\n                # Decrypt the key data\n                nonce = base64.b64decode(encrypted_key_data['nonce'])\n                ciphertext = base64.b64decode(encrypted_key_data['ciphertext'])\n\n                key_data_json = aesgcm.decrypt(nonce, ciphertext, None)\n                key_data = json.loads(key_data_json.decode())\n\n                # Extract the original key_id from the decrypted data\n                if '__key_id' not in key_data:\n                    logger.error(f\"Missing key_id in entry {entry_id}, skipping\")\n                    continue\n\n                key_id = key_data.pop('__key_id')  # Remove the special marker\n                self.keys[key_id] = key_data\n\n            except Exception as e:\n                logger.error(f\"Failed to decrypt key {entry_id}: {e}\")\n\n        logger.info(f\"Unlocked key storage with {len(self.keys)} keys\")\n        return True\n\n    except Exception as e:\n        logger.error(f\"Failed to unlock key storage: {e}\")\n        return False\n</code></pre> <code>derive_purpose_key(purpose)</code> \u00b6 <p>Derive a special-purpose key from the master key.</p> <p>Parameters:</p> Name Type Description Default <code>purpose</code> <code>str</code> <p>A string identifier for the key's purpose</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>A derived key for the specified purpose</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_storage.py</code> <pre><code>def derive_purpose_key(self, purpose: str) -&gt; bytes:\n    \"\"\"Derive a special-purpose key from the master key.\n\n    Args:\n        purpose: A string identifier for the key's purpose\n\n    Returns:\n        A derived key for the specified purpose\n    \"\"\"\n    if self.master_key is None:\n        logger.error(\"Cannot derive purpose key, storage not unlocked\")\n        return None\n\n    # Derive a purpose-specific key using HMAC\n    purpose_key = hmac.new(\n        key=self.master_key,\n        msg=purpose.encode(),\n        digestmod=hashlib.sha256\n    ).digest()\n\n    logger.debug(f\"Derived purpose key for: {purpose}\")\n    return purpose_key\n</code></pre> <code>get_or_create_persistent_key(purpose, key_size=32)</code> \u00b6 <p>Get or create a persistent purpose-specific key that survives password changes.</p> <p>Unlike <code>derive_purpose_key</code> which derives a key from the master key (and thus changes when the password changes), this method creates a persistent random key that is stored in the key storage and survives password changes.</p> <p>Parameters:</p> Name Type Description Default <code>purpose</code> <code>str</code> <p>A string identifier for the key's purpose (used as key_id)</p> required <code>key_size</code> <code>int</code> <p>The size of the key to generate if needed, in bytes</p> <code>32</code> <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>The persistent key, or None if storage is not unlocked or an error occurred</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_storage.py</code> <pre><code>def get_or_create_persistent_key(self, purpose: str, key_size: int = 32) -&gt; Optional[bytes]:\n    \"\"\"Get or create a persistent purpose-specific key that survives password changes.\n\n    Unlike `derive_purpose_key` which derives a key from the master key (and thus\n    changes when the password changes), this method creates a persistent random key\n    that is stored in the key storage and survives password changes.\n\n    Args:\n        purpose: A string identifier for the key's purpose (used as key_id)\n        key_size: The size of the key to generate if needed, in bytes\n\n    Returns:\n        The persistent key, or None if storage is not unlocked or an error occurred\n    \"\"\"\n    if self.master_key is None:\n        logger.error(\"Cannot get or create persistent key, storage not unlocked\")\n        return None\n\n    # Create a deterministic key_id based on the purpose\n    key_id = f\"system_persistent_key_{purpose}\"\n\n    try:\n        # Try to get an existing key\n        key_data = self.get_key(key_id)\n\n        if key_data is None:\n            # No existing key found, generate a new one\n            logger.info(f\"No persistent key found for purpose '{purpose}', generating new key\")\n\n            # Generate a random key of the specified size\n            import os\n            new_key = os.urandom(key_size)\n\n            # Store the key with metadata\n            key_stored = self.store_key(key_id, {\n                \"key\": new_key,\n                \"purpose\": purpose,\n                \"created_at\": time.time(),\n                \"key_size\": key_size,\n                \"description\": f\"Persistent key for {purpose}\"\n            })\n\n            if not key_stored:\n                logger.error(f\"Failed to store persistent key for purpose '{purpose}'\")\n                return None\n\n            logger.info(f\"Generated and stored new persistent key for purpose '{purpose}'\")\n            return new_key\n        else:\n            # Use existing key\n            stored_key = key_data.get(\"key\")\n\n            # Validate the key\n            if not isinstance(stored_key, bytes) or len(stored_key) &lt; 16:\n                # Invalid key format, generate a new one\n                logger.warning(f\"Invalid persistent key format for purpose '{purpose}', regenerating\")\n\n                # Generate a new random key\n                import os\n                new_key = os.urandom(key_size)\n\n                # Store the new key\n                key_stored = self.store_key(key_id, {\n                    \"key\": new_key,\n                    \"purpose\": purpose,\n                    \"created_at\": time.time(),\n                    \"key_size\": key_size,\n                    \"description\": f\"Persistent key for {purpose} (regenerated)\"\n                })\n\n                if not key_stored:\n                    logger.error(f\"Failed to store regenerated persistent key for purpose '{purpose}'\")\n                    return None\n\n                logger.info(f\"Regenerated persistent key for purpose '{purpose}'\")\n                return new_key\n            else:\n                logger.debug(f\"Using existing persistent key for purpose '{purpose}'\")\n                return stored_key\n\n    except Exception as e:\n        logger.error(f\"Error managing persistent key for purpose '{purpose}': {e}\", exc_info=True)\n        return None\n</code></pre> <code>change_password(old_password, new_password)</code> \u00b6 <p>Change the password for the key storage.</p> <p>Parameters:</p> Name Type Description Default <code>old_password</code> <code>str</code> <p>The current password</p> required <code>new_password</code> <code>str</code> <p>The new password</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if password change successful, False otherwise</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_storage.py</code> <pre><code>def change_password(self, old_password: str, new_password: str) -&gt; bool:\n    \"\"\"Change the password for the key storage.\n\n    Args:\n        old_password: The current password\n        new_password: The new password\n\n    Returns:\n        True if password change successful, False otherwise\n    \"\"\"\n    # First unlock with the old password\n    if not self.unlock(old_password):\n        logger.error(\"Failed to unlock storage with old password\")\n        return False\n\n    # Generate a new master key with the new password\n    self.master_key, self.salt = self._derive_key(new_password)\n    self._derive_encryption_keys()\n\n    # Save the storage with the new master key\n    return self._save_storage()\n</code></pre> <code>reset_storage(new_password, create_backup=False)</code> \u00b6 <p>Reset the key storage with a new password, deleting all existing keys and logs.</p> <p>This is a destructive operation that erases all keys, logs, and creates a fresh key storage with the new password. Use only when the original password is forgotten and data loss is acceptable.</p> <p>Parameters:</p> Name Type Description Default <code>new_password</code> <code>str</code> <p>The new password to use</p> required <code>create_backup</code> <code>bool</code> <p>Whether to create a backup of the old storage (default: False)</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if reset successful, False otherwise</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_storage.py</code> <pre><code>def reset_storage(self, new_password: str, create_backup: bool = False) -&gt; bool:\n    \"\"\"Reset the key storage with a new password, deleting all existing keys and logs.\n\n    This is a destructive operation that erases all keys, logs, and creates a fresh\n    key storage with the new password. Use only when the original password\n    is forgotten and data loss is acceptable.\n\n    Args:\n        new_password: The new password to use\n        create_backup: Whether to create a backup of the old storage (default: False)\n\n    Returns:\n        True if reset successful, False otherwise\n    \"\"\"\n    try:\n        # Create backup of existing key storage if requested\n        if create_backup and self.storage_path.exists():\n            backup_path = self.storage_path.with_suffix(self.storage_path.suffix + '.old')\n            try:\n                import shutil\n                shutil.copy2(self.storage_path, backup_path)\n                logger.info(f\"Created backup of key storage at {backup_path}\")\n            except Exception as e:\n                logger.error(f\"Failed to create backup: {e}\")\n\n        # Delete the existing key storage files\n        try:\n            if self.storage_path.exists():\n                os.remove(self.storage_path)\n                logger.info(f\"Deleted key storage file: {self.storage_path}\")\n\n            # Also check for lock and backup files\n            lock_path = self.storage_path.with_suffix(self.storage_path.suffix + '.lock')\n            if lock_path.exists():\n                os.remove(lock_path)\n                logger.info(f\"Deleted lock file: {lock_path}\")\n\n            regular_backup = self.storage_path.with_suffix(self.storage_path.suffix + '.bak')\n            if regular_backup.exists():\n                os.remove(regular_backup)\n                logger.info(f\"Deleted regular backup file: {regular_backup}\")\n\n            # Delete any other backups\n            old_backup = self.storage_path.with_suffix(self.storage_path.suffix + '.old')\n            if old_backup.exists():\n                os.remove(old_backup)\n                logger.info(f\"Deleted old backup file: {old_backup}\")\n\n        except Exception as e:\n            logger.error(f\"Error removing old storage files: {e}\")\n            return False\n\n        # Delete secure logs\n        try:\n            # Get the logs directory (same location as key storage but in 'logs' subdirectory)\n            logs_dir = self.storage_path.parent / \"logs\"\n            if logs_dir.exists() and logs_dir.is_dir():\n                import glob\n                import shutil\n\n                # Delete all log files first\n                log_files = glob.glob(str(logs_dir / \"*.log\"))\n                for log_file in log_files:\n                    try:\n                        os.remove(log_file)\n                        logger.info(f\"Deleted log file: {log_file}\")\n                    except Exception as e:\n                        logger.warning(f\"Failed to delete log file {log_file}: {e}\")\n\n                # Delete any encryption keys for logs\n                key_files = glob.glob(str(logs_dir.parent / \"log_encryption_key*\"))\n                for key_file in key_files:\n                    try:\n                        os.remove(key_file)\n                        logger.info(f\"Deleted log encryption key: {key_file}\")\n                    except Exception as e:\n                        logger.warning(f\"Failed to delete log encryption key {key_file}: {e}\")\n\n                logger.info(\"Deleted secure logs\")\n        except Exception as e:\n            logger.error(f\"Error deleting secure logs: {e}\")\n            # Continue with reset even if log deletion fails\n\n        # Clear any existing keys from memory\n        self.keys = {}\n        self.master_key = None\n        self.salt = None\n        self.hmac_key = None\n\n        # Create a new key storage with the new password\n        success = self.unlock(new_password)\n\n        if success:\n            logger.info(\"Key storage reset successfully with new password\")\n            return True\n        else:\n            logger.error(\"Failed to initialize new key storage\")\n            return False\n\n    except Exception as e:\n        logger.error(f\"Failed to reset key storage: {e}\")\n        return False\n</code></pre> <code>store_key(key_id, key_data)</code> \u00b6 <p>Store a key in the key storage.</p> <p>Parameters:</p> Name Type Description Default <code>key_id</code> <code>str</code> <p>A unique identifier for the key</p> required <code>key_data</code> <code>Dict[str, Any]</code> <p>The key data to store</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if key stored successfully, False otherwise</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_storage.py</code> <pre><code>def store_key(self, key_id: str, key_data: Dict[str, Any]) -&gt; bool:\n    \"\"\"Store a key in the key storage.\n\n    Args:\n        key_id: A unique identifier for the key\n        key_data: The key data to store\n\n    Returns:\n        True if key stored successfully, False otherwise\n    \"\"\"\n    if self.master_key is None:\n        logger.error(\"Cannot store key, storage not unlocked\")\n        return False\n\n    try:\n        # Add metadata\n        key_data_with_meta = key_data.copy()\n        key_data_with_meta['created_at'] = time.time()\n\n        # Store the key in memory\n        self.keys[key_id] = key_data_with_meta\n\n        # Save to disk\n        return self._save_storage()\n\n    except Exception as e:\n        logger.error(f\"Failed to store key {key_id}: {e}\")\n        return False\n</code></pre> <code>get_key(key_id)</code> \u00b6 <p>Retrieve a key from the key storage.</p> <p>Parameters:</p> Name Type Description Default <code>key_id</code> <code>str</code> <p>The identifier of the key to retrieve</p> required <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>The key data, or None if not found</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_storage.py</code> <pre><code>def get_key(self, key_id: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Retrieve a key from the key storage.\n\n    Args:\n        key_id: The identifier of the key to retrieve\n\n    Returns:\n        The key data, or None if not found\n    \"\"\"\n    if self.master_key is None:\n        logger.error(\"Cannot get key, storage not unlocked\")\n        return None\n\n    if key_id not in self.keys:\n        return None\n\n    # Get the key data\n    key_data = self.keys[key_id].copy()\n\n    # Convert base64 strings back to binary data\n    decoded_data = {}\n    for k, v in key_data.items():\n        if isinstance(v, str):\n            # For known binary fields, always try to decode\n            common_binary_fields = ['key', 'public_key', 'private_key', 'shared_key', \n                                    'ciphertext', 'signature', 'original_shared_secret']\n\n            if k in common_binary_fields:\n                try:\n                    decoded_data[k] = base64.b64decode(v)\n                    continue\n                except Exception:\n                    # Not base64 encoded, will use as is below\n                    pass\n\n            # For other fields, check if it looks like base64 (length multiple of 4,\n            # only contains valid base64 characters)\n            if len(v) &gt; 0 and len(v) % 4 == 0 and all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in v):\n                try:\n                    # Try to decode it\n                    decoded = base64.b64decode(v)\n                    # Only use the decoded value if it looks like binary data\n                    # (contains bytes that aren't printable ASCII)\n                    if any(b &lt; 32 or b &gt; 126 for b in decoded):\n                        decoded_data[k] = decoded\n                        continue\n                except:\n                    # If decoding fails, use the original string\n                    pass\n\n            # If we got here, use the string value as-is\n            decoded_data[k] = v\n        else:\n            # Non-string value (int, bool, etc)\n            decoded_data[k] = v\n\n    return decoded_data\n</code></pre> <code>delete_key(key_id)</code> \u00b6 <p>Delete a key from the key storage.</p> <p>Parameters:</p> Name Type Description Default <code>key_id</code> <code>str</code> <p>The identifier of the key to delete</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if key deleted successfully, False otherwise</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_storage.py</code> <pre><code>def delete_key(self, key_id: str) -&gt; bool:\n    \"\"\"Delete a key from the key storage.\n\n    Args:\n        key_id: The identifier of the key to delete\n\n    Returns:\n        True if key deleted successfully, False otherwise\n    \"\"\"\n    if self.master_key is None:\n        logger.error(\"Cannot delete key, storage not unlocked\")\n        return False\n\n    if key_id not in self.keys:\n        logger.warning(f\"Key {key_id} not found in storage\")\n        return False\n\n    try:\n        # Remove the key from memory\n        del self.keys[key_id]\n\n        # Save to disk to remove it from storage\n        return self._save_storage()\n\n    except Exception as e:\n        logger.error(f\"Failed to delete key {key_id}: {e}\")\n        return False\n</code></pre> <code>list_keys()</code> \u00b6 <p>List all keys in the key storage.</p> <p>Returns:</p> Type Description <code>List[Tuple[str, Dict[str, Any]]]</code> <p>List of tuples (key_id, key_data)</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_storage.py</code> <pre><code>def list_keys(self) -&gt; List[Tuple[str, Dict[str, Any]]]:\n    \"\"\"List all keys in the key storage.\n\n    Returns:\n        List of tuples (key_id, key_data)\n    \"\"\"\n    if self.master_key is None:\n        logger.error(\"Cannot list keys, storage not unlocked\")\n        return []\n\n    # Create a list of (key_id, key_data) tuples\n    # Convert any base64 strings to bytes in the key data\n    result = []\n    for key_id, key_data in self.keys.items():\n        decoded_data = {}\n        for k, v in key_data.items():\n            if isinstance(v, str) and k in ['public_key', 'private_key', 'shared_key']:\n                try:\n                    decoded_data[k] = base64.b64decode(v)\n                except Exception:\n                    decoded_data[k] = v\n            else:\n                decoded_data[k] = v\n        result.append((key_id, decoded_data))\n\n    return result\n</code></pre> <code>get_key_history(decrypt_keys=False)</code> \u00b6 <p>Get a list of all saved key history.</p> <p>Parameters:</p> Name Type Description Default <code>decrypt_keys</code> <p>Whether to decrypt the key data (default: False)</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of dictionaries containing key history information</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_storage.py</code> <pre><code>def get_key_history(self, decrypt_keys=False) -&gt; List[Dict[str, Any]]:\n    \"\"\"Get a list of all saved key history.\n\n    Args:\n        decrypt_keys: Whether to decrypt the key data (default: False)\n\n    Returns:\n        List of dictionaries containing key history information\n    \"\"\"\n    if self.master_key is None:\n        logger.error(\"Cannot get key history, storage not unlocked\")\n        return []\n\n    history = []\n    for key_id, key_data in self.keys.items():\n        if key_id.startswith(\"peer_shared_key_\"):\n            # Extract and convert relevant information\n            display_data = key_data.copy()\n\n            # Only include encrypted_key_data for later decryption\n            encrypted_data = None\n\n            # Store the raw encrypted data for later decryption if needed\n            if \"shared_key\" in display_data:\n                # Remember if it's already bytes or needs to be decoded from base64\n                if isinstance(display_data[\"shared_key\"], str):\n                    try:\n                        encrypted_data = {\"type\": \"base64\", \"data\": display_data[\"shared_key\"]}\n                    except:\n                        encrypted_data = {\"type\": \"string\", \"data\": display_data[\"shared_key\"]}\n                else:\n                    encrypted_data = {\"type\": \"bytes\", \"data\": display_data[\"shared_key\"]}\n\n                # Generate a preview if it's going to be displayed\n                if decrypt_keys and isinstance(display_data[\"shared_key\"], bytes):\n                    display_data[\"shared_key_preview\"] = display_data[\"shared_key\"][:16].hex()\n                else:\n                    display_data[\"shared_key_preview\"] = \"(encrypted)\"\n\n            entry = {\n                \"key_id\": key_id,\n                \"peer_id\": display_data.get(\"peer_id\", \"Unknown\"),\n                \"algorithm\": display_data.get(\"algorithm\", \"Unknown\"),\n                \"symmetric_algorithm\": display_data.get(\"symmetric_algorithm\", \"Unknown\"),\n                \"created_at\": display_data.get(\"created_at\", 0),\n                \"key_preview\": display_data.get(\"shared_key_preview\", \"\"),\n                \"encrypted_key_data\": encrypted_data  # Store encrypted data instead of decrypted\n            }\n\n            # Only include full_key if explicitly requested\n            if decrypt_keys and \"shared_key\" in display_data:\n                if isinstance(display_data[\"shared_key\"], bytes):\n                    entry[\"full_key\"] = display_data[\"shared_key\"]\n                elif isinstance(display_data[\"shared_key\"], str):\n                    try:\n                        entry[\"full_key\"] = base64.b64decode(display_data[\"shared_key\"])\n                    except:\n                        entry[\"full_key\"] = display_data[\"shared_key\"].encode('utf-8')\n\n            history.append(entry)\n\n    # Sort by creation time, newest first\n    history.sort(key=lambda x: x[\"created_at\"], reverse=True)\n    return history\n</code></pre> <code>decrypt_key(key_id)</code> \u00b6 <p>Decrypt a specific key by ID.</p> <p>Parameters:</p> Name Type Description Default <code>key_id</code> <code>str</code> <p>The ID of the key to decrypt</p> required <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>The decrypted key as bytes, or None if not found/cannot decrypt</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_storage.py</code> <pre><code>def decrypt_key(self, key_id: str) -&gt; Optional[bytes]:\n    \"\"\"Decrypt a specific key by ID.\n\n    Args:\n        key_id: The ID of the key to decrypt\n\n    Returns:\n        The decrypted key as bytes, or None if not found/cannot decrypt\n    \"\"\"\n    if self.master_key is None:\n        logger.error(\"Cannot decrypt key, storage not unlocked\")\n        return None\n\n    # Log the decryption attempt\n    logger.info(f\"Decrypting key {key_id} from secure storage\")\n\n    # Retrieve the encrypted key data\n    key_data = self.get_key(key_id)\n    if not key_data or \"shared_key\" not in key_data:\n        logger.error(f\"Key {key_id} not found or has no shared_key\")\n        return None\n\n    # Return the already-decrypted data\n    shared_key = key_data[\"shared_key\"]\n    if isinstance(shared_key, bytes):\n        logger.info(f\"Successfully decrypted key {key_id}\")\n        return shared_key\n    elif isinstance(shared_key, str):\n        # Try to decode if it's base64 encoded\n        try:\n            decoded_key = base64.b64decode(shared_key)\n            logger.info(f\"Successfully decrypted key {key_id} (from base64)\")\n            return decoded_key\n        except:\n            # Not base64, use as is\n            logger.info(f\"Successfully decrypted key {key_id} (from string)\")\n            return shared_key.encode('utf-8')\n\n    logger.error(f\"Failed to decode key {key_id} (unknown format)\")\n    return None\n</code></pre> <code>close()</code> \u00b6 <p>Close the key storage and clear sensitive data from memory.</p> Source code in <code>quantum_resistant_p2p\\crypto\\key_storage.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the key storage and clear sensitive data from memory.\"\"\"\n    if hasattr(self, 'master_key') and self.master_key:\n        self._secure_zero(self.master_key)\n        self.master_key = None\n\n    if hasattr(self, 'hmac_key') and self.hmac_key:\n        self._secure_zero(self.hmac_key)\n        self.hmac_key = None\n\n    self.keys = {}\n    self.salt = None\n\n    logger.info(\"Key storage closed and sensitive data cleared\")\n</code></pre>"},{"location":"api/crypto/signatures/","title":"Signatures Module","text":"<p>Post-quantum digital signature algorithms. This module implements various post-quantum digital signature schemes for message authentication.</p>"},{"location":"api/crypto/signatures/#quantum_resistant_p2p.crypto.signatures","title":"<code>quantum_resistant_p2p.crypto.signatures</code>","text":"<p>Post-quantum digital signature algorithms.</p>"},{"location":"api/crypto/signatures/#quantum_resistant_p2p.crypto.signatures-classes","title":"Classes","text":""},{"location":"api/crypto/signatures/#quantum_resistant_p2p.crypto.signatures.SignatureAlgorithm","title":"<code>SignatureAlgorithm</code>","text":"<p>               Bases: <code>CryptoAlgorithm</code></p> <p>Abstract base class for digital signature algorithms.</p>"},{"location":"api/crypto/signatures/#quantum_resistant_p2p.crypto.signatures.SignatureAlgorithm-functions","title":"Functions","text":"<code>generate_keypair()</code> <code>abstractmethod</code> \u00b6 <p>Generate a new keypair.</p> <p>Returns:</p> Type Description <code>Tuple[bytes, bytes]</code> <p>Tuple of (public_key, private_key)</p> Source code in <code>quantum_resistant_p2p\\crypto\\signatures.py</code> <pre><code>@abc.abstractmethod\ndef generate_keypair(self) -&gt; Tuple[bytes, bytes]:\n    \"\"\"Generate a new keypair.\n\n    Returns:\n        Tuple of (public_key, private_key)\n    \"\"\"\n    pass\n</code></pre> <code>sign(private_key, message)</code> <code>abstractmethod</code> \u00b6 <p>Sign a message using the private key.</p> <p>Parameters:</p> Name Type Description Default <code>private_key</code> <code>bytes</code> <p>The private key for signing</p> required <code>message</code> <code>bytes</code> <p>The message to sign</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The signature</p> Source code in <code>quantum_resistant_p2p\\crypto\\signatures.py</code> <pre><code>@abc.abstractmethod\ndef sign(self, private_key: bytes, message: bytes) -&gt; bytes:\n    \"\"\"Sign a message using the private key.\n\n    Args:\n        private_key: The private key for signing\n        message: The message to sign\n\n    Returns:\n        The signature\n    \"\"\"\n    pass\n</code></pre> <code>verify(public_key, message, signature)</code> <code>abstractmethod</code> \u00b6 <p>Verify a signature using the public key.</p> <p>Parameters:</p> Name Type Description Default <code>public_key</code> <code>bytes</code> <p>The public key for verification</p> required <code>message</code> <code>bytes</code> <p>The message that was signed</p> required <code>signature</code> <code>bytes</code> <p>The signature to verify</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the signature is valid, False otherwise</p> Source code in <code>quantum_resistant_p2p\\crypto\\signatures.py</code> <pre><code>@abc.abstractmethod\ndef verify(self, public_key: bytes, message: bytes, signature: bytes) -&gt; bool:\n    \"\"\"Verify a signature using the public key.\n\n    Args:\n        public_key: The public key for verification\n        message: The message that was signed\n        signature: The signature to verify\n\n    Returns:\n        True if the signature is valid, False otherwise\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/crypto/signatures/#quantum_resistant_p2p.crypto.signatures.MLDSASignature","title":"<code>MLDSASignature(security_level=3)</code>","text":"<p>               Bases: <code>SignatureAlgorithm</code></p> <p>ML-DSA (previously CRYSTALS-Dilithium) digital signature algorithm.</p> <p>ML-DSA is a post-quantum signature scheme based on the hardness of lattice problems.</p> <p>Initialize ML-DSA with the specified security level.</p> <p>Parameters:</p> Name Type Description Default <code>security_level</code> <code>int</code> <p>Security level (2, 3, or 5)</p> <code>3</code> Source code in <code>quantum_resistant_p2p\\crypto\\signatures.py</code> <pre><code>def __init__(self, security_level: int = 3):\n    \"\"\"Initialize ML-DSA with the specified security level.\n\n    Args:\n        security_level: Security level (2, 3, or 5)\n    \"\"\"\n    self.security_level = security_level\n    self.signer = None\n    self.variant = None\n\n    # Map security levels to ML-DSA variants\n    ml_dsa_variants = {\n        2: \"ML-DSA-44\",\n        3: \"ML-DSA-65\",\n        5: \"ML-DSA-87\"\n    }\n\n    # Also check older Dilithium names as fallback\n    dilithium_variants = {\n        2: \"Dilithium2\",\n        3: \"Dilithium3\",\n        5: \"Dilithium5\"\n    }\n\n    if security_level not in ml_dsa_variants:\n        raise ValueError(f\"Invalid security level: {security_level}. Must be 2, 3, or 5.\")\n\n    # Get enabled signature mechanisms\n    self.enabled_sigs = oqs.get_enabled_sig_mechanisms()\n\n    # Try to find an available variant\n    if ml_dsa_variants[security_level] in self.enabled_sigs:\n        self.variant = ml_dsa_variants[security_level]\n    elif dilithium_variants[security_level] in self.enabled_sigs:\n        # Use older Dilithium implementation if available\n        self.variant = dilithium_variants[security_level]\n    else:\n        raise ValueError(f\"No ML-DSA or Dilithium variant found for security level {security_level}\")\n\n    # Create the Signature instance\n    self.signer = oqs.Signature(self.variant)\n    logger.info(f\"Successfully initialized ML-DSA variant {self.variant}\")\n\n    logger.info(f\"Initialized ML-DSA signature with security level {security_level}\")\n</code></pre>"},{"location":"api/crypto/signatures/#quantum_resistant_p2p.crypto.signatures.MLDSASignature-attributes","title":"Attributes","text":"<code>name</code> <code>property</code> \u00b6 <p>Get the internal name of the algorithm.</p> <code>display_name</code> <code>property</code> \u00b6 <p>Get the user-friendly name for display.</p> <code>description</code> <code>property</code> \u00b6 <p>Get a description of the algorithm.</p>"},{"location":"api/crypto/signatures/#quantum_resistant_p2p.crypto.signatures.MLDSASignature-functions","title":"Functions","text":"<code>generate_keypair()</code> \u00b6 <p>Generate a new ML-DSA keypair.</p> <p>Returns:</p> Type Description <code>Tuple[bytes, bytes]</code> <p>Tuple of (public_key, private_key)</p> Source code in <code>quantum_resistant_p2p\\crypto\\signatures.py</code> <pre><code>def generate_keypair(self) -&gt; Tuple[bytes, bytes]:\n    \"\"\"Generate a new ML-DSA keypair.\n\n    Returns:\n        Tuple of (public_key, private_key)\n    \"\"\"\n    try:\n        # Use actual OQS implementation\n        public_key = self.signer.generate_keypair()\n        private_key = self.signer.export_secret_key()\n\n        logger.debug(f\"Generated ML-DSA keypair: public key {len(public_key)} bytes, \"\n                   f\"private key {len(private_key)} bytes\")\n\n        return public_key, private_key\n    except Exception as e:\n        logger.error(f\"Error generating ML-DSA keypair: {e}\")\n        raise\n</code></pre> <code>sign(private_key, message)</code> \u00b6 <p>Sign a message using ML-DSA.</p> <p>Parameters:</p> Name Type Description Default <code>private_key</code> <code>bytes</code> <p>The private key for signing</p> required <code>message</code> <code>bytes</code> <p>The message to sign</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The signature</p> Source code in <code>quantum_resistant_p2p\\crypto\\signatures.py</code> <pre><code>def sign(self, private_key: bytes, message: bytes) -&gt; bytes:\n    \"\"\"Sign a message using ML-DSA.\n\n    Args:\n        private_key: The private key for signing\n        message: The message to sign\n\n    Returns:\n        The signature\n    \"\"\"\n    try:\n        # Create a new signer with the private key\n        signer = oqs.Signature(self.variant, private_key)\n        signature = signer.sign(message)\n\n        logger.debug(f\"Created ML-DSA signature: {len(signature)} bytes\")\n\n        return signature\n    except Exception as e:\n        logger.error(f\"Error signing with ML-DSA: {e}\")\n        raise\n</code></pre> <code>verify(public_key, message, signature)</code> \u00b6 <p>Verify a ML-DSA signature.</p> <p>Parameters:</p> Name Type Description Default <code>public_key</code> <code>bytes</code> <p>The public key for verification</p> required <code>message</code> <code>bytes</code> <p>The message that was signed</p> required <code>signature</code> <code>bytes</code> <p>The signature to verify</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the signature is valid, False otherwise</p> Source code in <code>quantum_resistant_p2p\\crypto\\signatures.py</code> <pre><code>def verify(self, public_key: bytes, message: bytes, signature: bytes) -&gt; bool:\n    \"\"\"Verify a ML-DSA signature.\n\n    Args:\n        public_key: The public key for verification\n        message: The message that was signed\n        signature: The signature to verify\n\n    Returns:\n        True if the signature is valid, False otherwise\n    \"\"\"\n    try:\n        # Create a new verifier\n        verifier = oqs.Signature(self.variant)\n        result = verifier.verify(message, signature, public_key)\n\n        logger.debug(f\"ML-DSA signature verification: {'success' if result else 'failure'}\")\n\n        return result\n    except Exception as e:\n        logger.error(f\"Error verifying ML-DSA signature: {e}\")\n        return False\n</code></pre>"},{"location":"api/crypto/signatures/#quantum_resistant_p2p.crypto.signatures.SPHINCSSignature","title":"<code>SPHINCSSignature(security_level=3)</code>","text":"<p>               Bases: <code>SignatureAlgorithm</code></p> <p>SPHINCS+ digital signature algorithm.</p> <p>SPHINCS+ is a stateless hash-based signature scheme.</p> <p>Initialize SPHINCS+ with the specified security level.</p> <p>Parameters:</p> Name Type Description Default <code>security_level</code> <code>int</code> <p>Security level (1, 3, or 5)</p> <code>3</code> Source code in <code>quantum_resistant_p2p\\crypto\\signatures.py</code> <pre><code>def __init__(self, security_level: int = 3):\n    \"\"\"Initialize SPHINCS+ with the specified security level.\n\n    Args:\n        security_level: Security level (1, 3, or 5)\n    \"\"\"\n    self.security_level = security_level\n    self.signer = None\n    self.variant = None\n\n    # Map security levels to SPHINCS+ variants\n    sphincs_variants = {\n        1: [\"SPHINCS+-SHA2-128f-simple\"],\n        3: [\"SPHINCS+-SHA2-192f-simple\"],\n        5: [\"SPHINCS+-SHA2-256f-simple\"]\n    }\n\n    if security_level not in sphincs_variants:\n        raise ValueError(f\"Invalid security level: {security_level}. Must be 1, 3, or 5.\")\n\n    # Get enabled signature mechanisms\n    self.enabled_sigs = oqs.get_enabled_sig_mechanisms()\n\n    # Try to find an available variant\n    variant_found = False\n    for variant in sphincs_variants[security_level]:\n        if variant in self.enabled_sigs:\n            self.variant = variant\n            variant_found = True\n            break\n\n    if not variant_found:\n        raise ValueError(f\"No SPHINCS+ variant found for security level {security_level}\")\n\n    # Create the Signature instance\n    self.signer = oqs.Signature(self.variant)\n    logger.info(f\"Successfully initialized SPHINCS+ variant {self.variant}\")\n\n    logger.info(f\"Initialized SPHINCS+ signature with security level {security_level}\")\n</code></pre>"},{"location":"api/crypto/signatures/#quantum_resistant_p2p.crypto.signatures.SPHINCSSignature-attributes","title":"Attributes","text":"<code>name</code> <code>property</code> \u00b6 <p>Get the internal name of the algorithm.</p> <code>display_name</code> <code>property</code> \u00b6 <p>Get the user-friendly name for display.</p> <code>description</code> <code>property</code> \u00b6 <p>Get a description of the algorithm.</p>"},{"location":"api/crypto/signatures/#quantum_resistant_p2p.crypto.signatures.SPHINCSSignature-functions","title":"Functions","text":"<code>generate_keypair()</code> \u00b6 <p>Generate a new SPHINCS+ keypair.</p> <p>Returns:</p> Type Description <code>Tuple[bytes, bytes]</code> <p>Tuple of (public_key, private_key)</p> Source code in <code>quantum_resistant_p2p\\crypto\\signatures.py</code> <pre><code>def generate_keypair(self) -&gt; Tuple[bytes, bytes]:\n    \"\"\"Generate a new SPHINCS+ keypair.\n\n    Returns:\n        Tuple of (public_key, private_key)\n    \"\"\"\n    try:\n        # Use actual OQS implementation\n        public_key = self.signer.generate_keypair()\n        private_key = self.signer.export_secret_key()\n\n        logger.debug(f\"Generated SPHINCS+ keypair: public key {len(public_key)} bytes, \"\n                   f\"private key {len(private_key)} bytes\")\n\n        return public_key, private_key\n    except Exception as e:\n        logger.error(f\"Error generating SPHINCS+ keypair: {e}\")\n        raise\n</code></pre> <code>sign(private_key, message)</code> \u00b6 <p>Sign a message using SPHINCS+.</p> <p>Parameters:</p> Name Type Description Default <code>private_key</code> <code>bytes</code> <p>The private key for signing</p> required <code>message</code> <code>bytes</code> <p>The message to sign</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The signature</p> Source code in <code>quantum_resistant_p2p\\crypto\\signatures.py</code> <pre><code>def sign(self, private_key: bytes, message: bytes) -&gt; bytes:\n    \"\"\"Sign a message using SPHINCS+.\n\n    Args:\n        private_key: The private key for signing\n        message: The message to sign\n\n    Returns:\n        The signature\n    \"\"\"\n    try:\n        # Create a new signer with the private key\n        signer = oqs.Signature(self.variant, private_key)\n        signature = signer.sign(message)\n\n        logger.debug(f\"Created SPHINCS+ signature: {len(signature)} bytes\")\n\n        return signature\n    except Exception as e:\n        logger.error(f\"Error signing with SPHINCS+: {e}\")\n        raise\n</code></pre> <code>verify(public_key, message, signature)</code> \u00b6 <p>Verify a SPHINCS+ signature.</p> <p>Parameters:</p> Name Type Description Default <code>public_key</code> <code>bytes</code> <p>The public key for verification</p> required <code>message</code> <code>bytes</code> <p>The message that was signed</p> required <code>signature</code> <code>bytes</code> <p>The signature to verify</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the signature is valid, False otherwise</p> Source code in <code>quantum_resistant_p2p\\crypto\\signatures.py</code> <pre><code>def verify(self, public_key: bytes, message: bytes, signature: bytes) -&gt; bool:\n    \"\"\"Verify a SPHINCS+ signature.\n\n    Args:\n        public_key: The public key for verification\n        message: The message that was signed\n        signature: The signature to verify\n\n    Returns:\n        True if the signature is valid, False otherwise\n    \"\"\"\n    try:\n        # Create a new verifier\n        verifier = oqs.Signature(self.variant)\n        result = verifier.verify(message, signature, public_key)\n\n        logger.debug(f\"SPHINCS+ signature verification: {'success' if result else 'failure'}\")\n\n        return result\n    except Exception as e:\n        logger.error(f\"Error verifying SPHINCS+ signature: {e}\")\n        return False\n</code></pre>"},{"location":"api/crypto/symmetric/","title":"Symmetric Encryption Module","text":"<p>Symmetric encryption algorithms. This module provides authenticated encryption algorithms for secure communication.</p>"},{"location":"api/crypto/symmetric/#quantum_resistant_p2p.crypto.symmetric","title":"<code>quantum_resistant_p2p.crypto.symmetric</code>","text":"<p>Symmetric encryption algorithms.</p>"},{"location":"api/crypto/symmetric/#quantum_resistant_p2p.crypto.symmetric-classes","title":"Classes","text":""},{"location":"api/crypto/symmetric/#quantum_resistant_p2p.crypto.symmetric.SymmetricAlgorithm","title":"<code>SymmetricAlgorithm</code>","text":"<p>               Bases: <code>CryptoAlgorithm</code></p> <p>Abstract base class for symmetric encryption algorithms.</p>"},{"location":"api/crypto/symmetric/#quantum_resistant_p2p.crypto.symmetric.SymmetricAlgorithm-attributes","title":"Attributes","text":"<code>key_size</code> <code>abstractmethod</code> <code>property</code> \u00b6 <p>Get the key size in bytes.</p>"},{"location":"api/crypto/symmetric/#quantum_resistant_p2p.crypto.symmetric.SymmetricAlgorithm-functions","title":"Functions","text":"<code>generate_key()</code> <code>abstractmethod</code> \u00b6 <p>Generate a new random key.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>A new key as bytes</p> Source code in <code>quantum_resistant_p2p\\crypto\\symmetric.py</code> <pre><code>@abc.abstractmethod\ndef generate_key(self) -&gt; bytes:\n    \"\"\"Generate a new random key.\n\n    Returns:\n        A new key as bytes\n    \"\"\"\n    pass\n</code></pre> <code>encrypt(key, plaintext, associated_data=None)</code> <code>abstractmethod</code> \u00b6 <p>Encrypt data using the given key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes</code> <p>The encryption key</p> required <code>plaintext</code> <code>bytes</code> <p>The data to encrypt</p> required <code>associated_data</code> <code>Optional[bytes]</code> <p>Optional additional authenticated data</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The encrypted data (including nonce/IV)</p> Source code in <code>quantum_resistant_p2p\\crypto\\symmetric.py</code> <pre><code>@abc.abstractmethod\ndef encrypt(self, key: bytes, plaintext: bytes, associated_data: Optional[bytes] = None) -&gt; bytes:\n    \"\"\"Encrypt data using the given key.\n\n    Args:\n        key: The encryption key\n        plaintext: The data to encrypt\n        associated_data: Optional additional authenticated data\n\n    Returns:\n        The encrypted data (including nonce/IV)\n    \"\"\"\n    pass\n</code></pre> <code>decrypt(key, ciphertext, associated_data=None)</code> <code>abstractmethod</code> \u00b6 <p>Decrypt data using the given key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes</code> <p>The encryption key</p> required <code>ciphertext</code> <code>bytes</code> <p>The data to decrypt (including nonce/IV)</p> required <code>associated_data</code> <code>Optional[bytes]</code> <p>Optional additional authenticated data</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The decrypted data</p> Source code in <code>quantum_resistant_p2p\\crypto\\symmetric.py</code> <pre><code>@abc.abstractmethod\ndef decrypt(self, key: bytes, ciphertext: bytes, associated_data: Optional[bytes] = None) -&gt; bytes:\n    \"\"\"Decrypt data using the given key.\n\n    Args:\n        key: The encryption key\n        ciphertext: The data to decrypt (including nonce/IV)\n        associated_data: Optional additional authenticated data\n\n    Returns:\n        The decrypted data\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/crypto/symmetric/#quantum_resistant_p2p.crypto.symmetric.AES256GCM","title":"<code>AES256GCM</code>","text":"<p>               Bases: <code>SymmetricAlgorithm</code></p> <p>AES-256 in GCM mode for authenticated encryption.</p>"},{"location":"api/crypto/symmetric/#quantum_resistant_p2p.crypto.symmetric.AES256GCM-attributes","title":"Attributes","text":"<code>name</code> <code>property</code> \u00b6 <p>Get the name of the algorithm.</p> <code>description</code> <code>property</code> \u00b6 <p>Get a description of the algorithm.</p> <code>key_size</code> <code>property</code> \u00b6 <p>Get the key size in bytes.</p>"},{"location":"api/crypto/symmetric/#quantum_resistant_p2p.crypto.symmetric.AES256GCM-functions","title":"Functions","text":"<code>generate_key()</code> \u00b6 <p>Generate a new random AES-256 key.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>A new 256-bit (32-byte) key</p> Source code in <code>quantum_resistant_p2p\\crypto\\symmetric.py</code> <pre><code>def generate_key(self) -&gt; bytes:\n    \"\"\"Generate a new random AES-256 key.\n\n    Returns:\n        A new 256-bit (32-byte) key\n    \"\"\"\n    key = os.urandom(self.key_size)\n    logger.debug(f\"Generated new AES-256 key ({self.key_size} bytes)\")\n    return key\n</code></pre> <code>encrypt(key, plaintext, associated_data=None)</code> \u00b6 <p>Encrypt data using AES-256-GCM.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes</code> <p>The 256-bit AES key</p> required <code>plaintext</code> <code>bytes</code> <p>The data to encrypt</p> required <code>associated_data</code> <code>Optional[bytes]</code> <p>Optional additional authenticated data</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes</code> <p>Nonce + ciphertext + tag</p> Source code in <code>quantum_resistant_p2p\\crypto\\symmetric.py</code> <pre><code>def encrypt(self, key: bytes, plaintext: bytes, associated_data: Optional[bytes] = None) -&gt; bytes:\n    \"\"\"Encrypt data using AES-256-GCM.\n\n    Args:\n        key: The 256-bit AES key\n        plaintext: The data to encrypt\n        associated_data: Optional additional authenticated data\n\n    Returns:\n        Nonce + ciphertext + tag\n    \"\"\"\n    if len(key) != self.key_size:\n        raise ValueError(f\"Key must be {self.key_size} bytes, got {len(key)}\")\n\n    # Generate a random 96-bit (12-byte) nonce\n    nonce = os.urandom(12)\n\n    # Create the AES-GCM cipher\n    aesgcm = AESGCM(key)\n\n    # Encrypt the data\n    ciphertext = aesgcm.encrypt(nonce, plaintext, associated_data)\n\n    # Return nonce + ciphertext (including tag)\n    result = nonce + ciphertext\n\n    logger.debug(f\"AES-256-GCM encryption: {len(plaintext)} bytes plaintext -&gt; \"\n               f\"{len(result)} bytes ciphertext (includes {len(nonce)} bytes nonce)\")\n\n    return result\n</code></pre> <code>decrypt(key, ciphertext, associated_data=None)</code> \u00b6 <p>Decrypt data using AES-256-GCM.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes</code> <p>The 256-bit AES key</p> required <code>ciphertext</code> <code>bytes</code> <p>Nonce + ciphertext + tag</p> required <code>associated_data</code> <code>Optional[bytes]</code> <p>Optional additional authenticated data</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The decrypted data</p> Source code in <code>quantum_resistant_p2p\\crypto\\symmetric.py</code> <pre><code>def decrypt(self, key: bytes, ciphertext: bytes, associated_data: Optional[bytes] = None) -&gt; bytes:\n    \"\"\"Decrypt data using AES-256-GCM.\n\n    Args:\n        key: The 256-bit AES key\n        ciphertext: Nonce + ciphertext + tag\n        associated_data: Optional additional authenticated data\n\n    Returns:\n        The decrypted data\n    \"\"\"\n    if len(key) != self.key_size:\n        raise ValueError(f\"Key must be {self.key_size} bytes, got {len(key)}\")\n\n    if len(ciphertext) &lt; 12:  # Nonce is 12 bytes\n        raise ValueError(f\"Ciphertext too short: {len(ciphertext)} bytes, need at least 12 bytes for nonce\")\n\n    # Extract the nonce (first 12 bytes)\n    nonce = ciphertext[:12]\n    # Extract the actual ciphertext (including tag)\n    actual_ciphertext = ciphertext[12:]\n\n    # Create the AES-GCM cipher\n    aesgcm = AESGCM(key)\n\n    # Decrypt the data\n    try:\n        plaintext = aesgcm.decrypt(nonce, actual_ciphertext, associated_data)\n\n        logger.debug(f\"AES-256-GCM decryption: {len(ciphertext)} bytes ciphertext -&gt; \"\n                   f\"{len(plaintext)} bytes plaintext\")\n\n        return plaintext\n    except Exception as e:\n        logger.error(f\"AES-256-GCM decryption failed: {e}\")\n        raise ValueError(\"Authentication failed or decryption error\") from e\n</code></pre>"},{"location":"api/crypto/symmetric/#quantum_resistant_p2p.crypto.symmetric.ChaCha20Poly1305","title":"<code>ChaCha20Poly1305</code>","text":"<p>               Bases: <code>SymmetricAlgorithm</code></p> <p>ChaCha20-Poly1305 for authenticated encryption.</p>"},{"location":"api/crypto/symmetric/#quantum_resistant_p2p.crypto.symmetric.ChaCha20Poly1305-attributes","title":"Attributes","text":"<code>name</code> <code>property</code> \u00b6 <p>Get the name of the algorithm.</p> <code>description</code> <code>property</code> \u00b6 <p>Get a description of the algorithm.</p> <code>key_size</code> <code>property</code> \u00b6 <p>Get the key size in bytes.</p>"},{"location":"api/crypto/symmetric/#quantum_resistant_p2p.crypto.symmetric.ChaCha20Poly1305-functions","title":"Functions","text":"<code>generate_key()</code> \u00b6 <p>Generate a new random ChaCha20 key.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>A new 256-bit (32-byte) key</p> Source code in <code>quantum_resistant_p2p\\crypto\\symmetric.py</code> <pre><code>def generate_key(self) -&gt; bytes:\n    \"\"\"Generate a new random ChaCha20 key.\n\n    Returns:\n        A new 256-bit (32-byte) key\n    \"\"\"\n    key = os.urandom(self.key_size)\n    logger.debug(f\"Generated new ChaCha20 key ({self.key_size} bytes)\")\n    return key\n</code></pre> <code>encrypt(key, plaintext, associated_data=None)</code> \u00b6 <p>Encrypt data using ChaCha20-Poly1305.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes</code> <p>The 256-bit ChaCha20 key</p> required <code>plaintext</code> <code>bytes</code> <p>The data to encrypt</p> required <code>associated_data</code> <code>Optional[bytes]</code> <p>Optional additional authenticated data</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes</code> <p>Nonce + ciphertext + tag</p> Source code in <code>quantum_resistant_p2p\\crypto\\symmetric.py</code> <pre><code>def encrypt(self, key: bytes, plaintext: bytes, associated_data: Optional[bytes] = None) -&gt; bytes:\n    \"\"\"Encrypt data using ChaCha20-Poly1305.\n\n    Args:\n        key: The 256-bit ChaCha20 key\n        plaintext: The data to encrypt\n        associated_data: Optional additional authenticated data\n\n    Returns:\n        Nonce + ciphertext + tag\n    \"\"\"\n    if len(key) != self.key_size:\n        raise ValueError(f\"Key must be {self.key_size} bytes, got {len(key)}\")\n\n    # Generate a random 96-bit (12-byte) nonce\n    nonce = os.urandom(12)\n\n    # Create the ChaCha20-Poly1305 cipher\n    chacha = ChaCha20Poly1305Cipher(key)\n\n    # Encrypt the data\n    ciphertext = chacha.encrypt(nonce, plaintext, associated_data)\n\n    # Return nonce + ciphertext (including tag)\n    result = nonce + ciphertext\n\n    logger.debug(f\"ChaCha20-Poly1305 encryption: {len(plaintext)} bytes plaintext -&gt; \"\n               f\"{len(result)} bytes ciphertext (includes {len(nonce)} bytes nonce)\")\n\n    return result\n</code></pre> <code>decrypt(key, ciphertext, associated_data=None)</code> \u00b6 <p>Decrypt data using ChaCha20-Poly1305.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes</code> <p>The 256-bit ChaCha20 key</p> required <code>ciphertext</code> <code>bytes</code> <p>Nonce + ciphertext + tag</p> required <code>associated_data</code> <code>Optional[bytes]</code> <p>Optional additional authenticated data</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The decrypted data</p> Source code in <code>quantum_resistant_p2p\\crypto\\symmetric.py</code> <pre><code>def decrypt(self, key: bytes, ciphertext: bytes, associated_data: Optional[bytes] = None) -&gt; bytes:\n    \"\"\"Decrypt data using ChaCha20-Poly1305.\n\n    Args:\n        key: The 256-bit ChaCha20 key\n        ciphertext: Nonce + ciphertext + tag\n        associated_data: Optional additional authenticated data\n\n    Returns:\n        The decrypted data\n    \"\"\"\n    if len(key) != self.key_size:\n        raise ValueError(f\"Key must be {self.key_size} bytes, got {len(key)}\")\n\n    if len(ciphertext) &lt; 12:  # Nonce is 12 bytes\n        raise ValueError(f\"Ciphertext too short: {len(ciphertext)} bytes, need at least 12 bytes for nonce\")\n\n    # Extract the nonce (first 12 bytes)\n    nonce = ciphertext[:12]\n    # Extract the actual ciphertext (including tag)\n    actual_ciphertext = ciphertext[12:]\n\n    # Create the ChaCha20-Poly1305 cipher\n    chacha = ChaCha20Poly1305Cipher(key)\n\n    # Decrypt the data\n    try:\n        plaintext = chacha.decrypt(nonce, actual_ciphertext, associated_data)\n\n        logger.debug(f\"ChaCha20-Poly1305 decryption: {len(ciphertext)} bytes ciphertext -&gt; \"\n                   f\"{len(plaintext)} bytes plaintext\")\n\n        return plaintext\n    except Exception as e:\n        logger.error(f\"ChaCha20-Poly1305 decryption failed: {e}\")\n        raise ValueError(\"Authentication failed or decryption error\") from e\n</code></pre>"},{"location":"api/networking/","title":"Networking Package","text":"<p>Networking layer for P2P communication. This package provides functionality for peer discovery, direct communication between nodes, and handling network connections.</p>"},{"location":"api/networking/#quantum_resistant_p2p.networking","title":"<code>quantum_resistant_p2p.networking</code>","text":"<p>Networking layer for P2P communication.</p> <p>This package provides functionality for peer discovery, direct communication between nodes, and handling of network connections.</p>"},{"location":"api/networking/#quantum_resistant_p2p.networking-classes","title":"Classes","text":""},{"location":"api/networking/#quantum_resistant_p2p.networking.P2PNode","title":"<code>P2PNode(host='0.0.0.0', port=8000, node_id=None, max_chunk_size=64 * 1024, node_discovery=None, key_storage=None)</code>","text":"<p>A peer-to-peer network node supporting direct communication between peers.</p> <p>Initialize a new P2P node.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The host IP address to bind to</p> <code>'0.0.0.0'</code> <code>port</code> <code>int</code> <p>The port number to listen on</p> <code>8000</code> <code>node_id</code> <code>Optional[str]</code> <p>Unique identifier for this node. If None, a persistent ID will be loaded or generated.</p> <code>None</code> <code>max_chunk_size</code> <code>int</code> <p>Maximum size of message chunks in bytes</p> <code>64 * 1024</code> <code>node_discovery</code> <p>Optional reference to the NodeDiscovery instance</p> <code>None</code> <code>key_storage</code> <p>Optional reference to KeyStorage for secure node ID storage</p> <code>None</code> Source code in <code>quantum_resistant_p2p\\networking\\p2p_node.py</code> <pre><code>def __init__(self, host: str = '0.0.0.0', port: int = 8000, node_id: Optional[str] = None,\n             max_chunk_size: int = 64*1024, node_discovery=None, key_storage=None):\n    \"\"\"Initialize a new P2P node.\n\n    Args:\n        host: The host IP address to bind to\n        port: The port number to listen on\n        node_id: Unique identifier for this node. If None, a persistent ID will be loaded or generated.\n        max_chunk_size: Maximum size of message chunks in bytes\n        node_discovery: Optional reference to the NodeDiscovery instance\n        key_storage: Optional reference to KeyStorage for secure node ID storage\n    \"\"\"\n    self.host = host\n    self.port = port\n    # Use the utility function to load or generate a persistent node ID\n    # KeyStorage is passed for secure storage if available\n    self.node_id = load_or_generate_node_id(key_storage, node_id)\n    self.max_chunk_size = max_chunk_size\n    self.peers: Dict[str, Tuple[str, int]] = {}  # node_id -&gt; (host, port)\n    self.connections: Dict[str, asyncio.StreamWriter] = {}  # node_id -&gt; writer\n    self.server = None\n    self.message_handlers: Dict[str, List[Callable]] = {}\n    self.connection_handlers: Set[Callable[[str], None]] = set()\n    self.running = False\n    self.node_discovery = node_discovery  # Store reference to NodeDiscovery\n\n    if key_storage:\n        logger.info(f\"P2P Node initialized with secure persistent ID: {self.node_id[:8]}...\")\n    else:\n        logger.info(f\"P2P Node initialized with persistent ID: {self.node_id[:8]}...\")\n</code></pre>"},{"location":"api/networking/#quantum_resistant_p2p.networking.P2PNode-functions","title":"Functions","text":"<code>start()</code> <code>async</code> \u00b6 <p>Start the P2P node server.</p> Source code in <code>quantum_resistant_p2p\\networking\\p2p_node.py</code> <pre><code>async def start(self) -&gt; None:\n    \"\"\"Start the P2P node server.\"\"\"\n    self.server = await asyncio.start_server(\n        self._handle_connection, self.host, self.port\n    )\n\n    self.running = True\n    logger.info(f\"P2P Node {self.node_id} listening on {self.host}:{self.port}\")\n\n    async with self.server:\n        await self.server.serve_forever()\n</code></pre> <code>stop()</code> <code>async</code> \u00b6 <p>Stop the P2P node server.</p> Source code in <code>quantum_resistant_p2p\\networking\\p2p_node.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop the P2P node server.\"\"\"\n    if self.server:\n        self.server.close()\n        await self.server.wait_closed()\n        self.running = False\n\n        # Close all connections\n        for writer in self.connections.values():\n            writer.close()\n            try:\n                await writer.wait_closed()\n            except Exception as e:\n                logger.error(f\"Error closing connection: {e}\")\n\n        self.connections.clear()\n        logger.info(f\"P2P Node {self.node_id} stopped\")\n</code></pre> <code>register_connection_handler(handler)</code> \u00b6 <p>Register a handler for new peer connections.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable[[str], None]</code> <p>Function to call when a new peer connects. Takes peer_id as parameter.</p> required Source code in <code>quantum_resistant_p2p\\networking\\p2p_node.py</code> <pre><code>def register_connection_handler(self, handler: Callable[[str], None]) -&gt; None:\n    \"\"\"Register a handler for new peer connections.\n\n    Args:\n        handler: Function to call when a new peer connects. Takes peer_id as parameter.\n    \"\"\"\n    self.connection_handlers.add(handler)\n    logger.debug(f\"Registered connection handler {id(handler)}\")\n</code></pre> <code>connect_to_peer(host, port)</code> <code>async</code> \u00b6 <p>Connect to a peer at the specified host and port.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The host IP address or hostname of the peer</p> required <code>port</code> <code>int</code> <p>The port number the peer is listening on</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if connection successful, False otherwise</p> Source code in <code>quantum_resistant_p2p\\networking\\p2p_node.py</code> <pre><code>async def connect_to_peer(self, host: str, port: int) -&gt; bool:\n    \"\"\"Connect to a peer at the specified host and port.\n\n    Args:\n        host: The host IP address or hostname of the peer\n        port: The port number the peer is listening on\n\n    Returns:\n        bool: True if connection successful, False otherwise\n    \"\"\"\n    logger.info(f\"Attempting to connect to peer at {host}:{port}\")\n\n    # First check if we're already connected to this peer by host and port\n    for peer_id, (peer_host, peer_port) in self.peers.items():\n        if peer_host == host and peer_port == port:\n            logger.info(f\"Already connected to peer {peer_id} at {host}:{port}\")\n            return True\n\n    try:\n        reader, writer = await asyncio.open_connection(host, port)\n\n        # Send initial message with our node ID\n        initial_message = {\n            'node_id': self.node_id,\n            'type': 'hello'\n        }\n        initial_json = json.dumps(initial_message).encode()\n\n        # Use chunked sending\n        await self._send_chunked_message(writer, initial_json)\n        logger.debug(f\"Sent hello message to {host}:{port}\")\n\n        # Read peer's response to get their node ID\n        try:\n            data = await asyncio.wait_for(self._read_message(reader), timeout=5.0)\n            if not data:\n                logger.error(f\"No response from peer at {host}:{port}\")\n                writer.close()\n                return False\n        except asyncio.TimeoutError:\n            logger.error(f\"Timeout waiting for response from {host}:{port}\")\n            writer.close()\n            return False\n\n        try:\n            message = json.loads(data.decode())\n        except json.JSONDecodeError:\n            logger.error(f\"Invalid JSON response from peer at {host}:{port}\")\n            writer.close()\n            return False\n\n        if 'node_id' not in message:\n            logger.error(f\"Invalid response from peer at {host}:{port}, missing node_id\")\n            writer.close()\n            return False\n\n        peer_id = message['node_id']\n\n        # Don't connect to ourselves\n        if peer_id == self.node_id:\n            logger.warning(f\"Attempted to connect to ourselves at {host}:{port}\")\n            writer.close()\n            return False\n\n        # Store peer information\n        self.peers[peer_id] = (host, port)\n        self.connections[peer_id] = writer\n\n        logger.info(f\"Connected to peer {peer_id} at {host}:{port}\")\n\n        # Start a task to handle messages from this peer\n        asyncio.create_task(self._handle_peer_messages(peer_id, reader))\n\n        # Notify connection handlers\n        await self._notify_connection_handlers(peer_id)\n\n        # NEW: If we have a node discovery instance, add the peer to it\n        # This ensures the peer immediately shows up in both sides' peer lists\n        if hasattr(self, 'node_discovery') and self.node_discovery:\n            self.node_discovery.add_known_node(peer_id, host, port)\n            # Also send a direct announcement to the new peer\n            self.node_discovery._send_direct_announcement(host, port)\n\n        return True\n\n    except (OSError, asyncio.TimeoutError) as e:\n        logger.error(f\"Failed to connect to peer at {host}:{port}: {e}\")\n        return False\n    except Exception as e:\n        logger.error(f\"Unexpected error connecting to peer at {host}:{port}: {e}\")\n        return False\n</code></pre> <code>send_message(peer_id, message_type, **kwargs)</code> <code>async</code> \u00b6 <p>Send a message to a specific peer.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <code>str</code> <p>The ID of the peer to send the message to</p> required <code>message_type</code> <code>str</code> <p>The type of message being sent</p> required <code>**kwargs</code> <p>Additional key-value pairs to include in the message</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if message was sent, False otherwise</p> Source code in <code>quantum_resistant_p2p\\networking\\p2p_node.py</code> <pre><code>async def send_message(self, peer_id: str, message_type: str, **kwargs) -&gt; bool:\n    \"\"\"Send a message to a specific peer.\n\n    Args:\n        peer_id: The ID of the peer to send the message to\n        message_type: The type of message being sent\n        **kwargs: Additional key-value pairs to include in the message\n\n    Returns:\n        bool: True if message was sent, False otherwise\n    \"\"\"\n    if peer_id not in self.connections:\n        logger.error(f\"Cannot send message to unknown peer {peer_id}\")\n        return False\n\n    try:\n        message = {\n            'type': message_type,\n            'from': self.node_id,\n            **kwargs\n        }\n\n        writer = self.connections[peer_id]\n        message_json = json.dumps(message).encode()\n\n        # Use chunked sending\n        success = await self._send_chunked_message(writer, message_json)\n\n        if success:\n            logger.debug(f\"Sent {message_type} message to {peer_id}\")\n            return True\n        else:\n            logger.error(f\"Failed to send message to {peer_id}\")\n\n    except (ConnectionError, asyncio.TimeoutError) as e:\n        logger.error(f\"Failed to send message to {peer_id}: {e}\")\n    except Exception as e:\n        logger.error(f\"Unexpected error sending message to {peer_id}: {e}\")\n\n    # Remove the peer if we can't send to them\n    if peer_id in self.peers:\n        del self.peers[peer_id]\n    if peer_id in self.connections:\n        try:\n            self.connections[peer_id].close()\n        except Exception:\n            pass\n        del self.connections[peer_id]\n\n    return False\n</code></pre> <code>register_message_handler(message_type, handler)</code> \u00b6 <p>Register a handler function for a specific message type.</p> <p>Parameters:</p> Name Type Description Default <code>message_type</code> <code>str</code> <p>The type of message to handle</p> required <code>handler</code> <code>Callable</code> <p>The callback function to call when a message of this type is received.      The function should accept (peer_id, message) as parameters.</p> required Source code in <code>quantum_resistant_p2p\\networking\\p2p_node.py</code> <pre><code>def register_message_handler(self, message_type: str, handler: Callable) -&gt; None:\n    \"\"\"Register a handler function for a specific message type.\n\n    Args:\n        message_type: The type of message to handle\n        handler: The callback function to call when a message of this type is received.\n                 The function should accept (peer_id, message) as parameters.\n    \"\"\"\n    if message_type not in self.message_handlers:\n        self.message_handlers[message_type] = []\n\n    self.message_handlers[message_type].append(handler)\n    logger.debug(f\"Registered handler for message type {message_type}\")\n</code></pre> <code>get_peers()</code> \u00b6 <p>Get a list of connected peer IDs.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of peer IDs</p> Source code in <code>quantum_resistant_p2p\\networking\\p2p_node.py</code> <pre><code>def get_peers(self) -&gt; List[str]:\n    \"\"\"Get a list of connected peer IDs.\n\n    Returns:\n        List of peer IDs\n    \"\"\"\n    return list(self.peers.keys())\n</code></pre> <code>get_peer_info(peer_id)</code> \u00b6 <p>Get the host and port for a specific peer.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <code>str</code> <p>The ID of the peer</p> required <p>Returns:</p> Type Description <code>Optional[Tuple[str, int]]</code> <p>Tuple of (host, port) if the peer exists, None otherwise</p> Source code in <code>quantum_resistant_p2p\\networking\\p2p_node.py</code> <pre><code>def get_peer_info(self, peer_id: str) -&gt; Optional[Tuple[str, int]]:\n    \"\"\"Get the host and port for a specific peer.\n\n    Args:\n        peer_id: The ID of the peer\n\n    Returns:\n        Tuple of (host, port) if the peer exists, None otherwise\n    \"\"\"\n    return self.peers.get(peer_id)\n</code></pre>"},{"location":"api/networking/#quantum_resistant_p2p.networking.NodeDiscovery","title":"<code>NodeDiscovery(node_id, host='0.0.0.0', port=8000, discovery_port=8001)</code>","text":"<p>Discovery mechanism for P2P nodes on the local network.</p> <p>This class provides functionality for discovering other nodes in the network using UDP broadcast messages. It implements both automatic discovery through broadcast messages and manual peer addition.</p> <p>Initialize a new node discovery service.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>str</code> <p>The ID of the node this discovery service is for</p> required <code>host</code> <code>str</code> <p>The host IP address the node is listening on</p> <code>'0.0.0.0'</code> <code>port</code> <code>int</code> <p>The port number the node is listening on</p> <code>8000</code> <code>discovery_port</code> <code>int</code> <p>The port to use for discovery broadcasts</p> <code>8001</code> Source code in <code>quantum_resistant_p2p\\networking\\discovery.py</code> <pre><code>def __init__(self, node_id: str, host: str = '0.0.0.0', \n            port: int = 8000, discovery_port: int = 8001):\n    \"\"\"Initialize a new node discovery service.\n\n    Args:\n        node_id: The ID of the node this discovery service is for\n        host: The host IP address the node is listening on\n        port: The port number the node is listening on\n        discovery_port: The port to use for discovery broadcasts\n    \"\"\"\n    self.node_id = node_id\n    self.host = host\n    self.port = port\n    self.discovery_port = discovery_port\n    self.discovered_nodes: Dict[str, Tuple[str, int, float]] = {}  # node_id -&gt; (host, port, last_seen)\n    self.running = False\n    self.transport = None\n    self.protocol = None\n\n    # If host is 0.0.0.0, try to get the actual IP\n    if host == '0.0.0.0':\n        self.advertised_host = self._get_local_ip()\n    else:\n        self.advertised_host = host\n\n    logger.info(f\"Node Discovery initialized for node {node_id}, advertising as {self.advertised_host}:{port}\")\n</code></pre>"},{"location":"api/networking/#quantum_resistant_p2p.networking.NodeDiscovery-functions","title":"Functions","text":"<code>start()</code> <code>async</code> \u00b6 <p>Start the discovery service.</p> Source code in <code>quantum_resistant_p2p\\networking\\discovery.py</code> <pre><code>async def start(self) -&gt; None:\n    \"\"\"Start the discovery service.\"\"\"\n    # Define the protocol\n    class DiscoveryProtocol(asyncio.DatagramProtocol):\n        def __init__(self, parent):\n            self.parent = parent\n            self.transport = None\n\n        def connection_made(self, transport):\n            self.transport = transport\n\n        def datagram_received(self, data, addr):\n            self.parent._handle_discovery_message(data, addr)\n\n        def error_received(self, exc):\n            logger.error(f\"Discovery protocol error: {exc}\")\n\n    try:\n        # Manual socket approach for better control\n        # Create a UDP socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n        # Set SO_REUSEADDR to allow reusing the address\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\n        # Bind to the discovery port\n        sock.bind(('0.0.0.0', self.discovery_port))\n\n        # Set socket to non-blocking mode (needed for asyncio)\n        sock.setblocking(False)\n\n        # Enable broadcasting (needed for broadcasting announcements)\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n\n        # Create the transport and protocol\n        loop = asyncio.get_running_loop()\n        self.transport, self.protocol = await loop.create_datagram_endpoint(\n            lambda: DiscoveryProtocol(self),\n            sock=sock\n        )\n\n        self.running = True\n        logger.info(f\"Discovery service started on port {self.discovery_port}\")\n\n        # Start the announcement and cleanup tasks\n        asyncio.create_task(self._periodic_announce())\n        asyncio.create_task(self._cleanup_old_nodes())\n\n    except Exception as e:\n        logger.error(f\"Failed to start discovery service: {e}\")\n        raise\n</code></pre> <code>stop()</code> <code>async</code> \u00b6 <p>Stop the discovery service.</p> Source code in <code>quantum_resistant_p2p\\networking\\discovery.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop the discovery service.\"\"\"\n    if self.transport:\n        self.transport.close()\n        self.running = False\n        logger.info(\"Discovery service stopped\")\n</code></pre> <code>get_discovered_nodes()</code> \u00b6 <p>Get a list of all discovered nodes.</p> <p>Returns:</p> Type Description <code>List[Tuple[str, str, int]]</code> <p>List of tuples (node_id, host, port)</p> Source code in <code>quantum_resistant_p2p\\networking\\discovery.py</code> <pre><code>def get_discovered_nodes(self) -&gt; List[Tuple[str, str, int]]:\n    \"\"\"Get a list of all discovered nodes.\n\n    Returns:\n        List of tuples (node_id, host, port)\n    \"\"\"\n    return [(node_id, host, port) \n            for node_id, (host, port, _) in self.discovered_nodes.items()]\n</code></pre> <code>add_known_node(node_id, host, port)</code> \u00b6 <p>Manually add a known node to the discovery list.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>str</code> <p>The ID of the node</p> required <code>host</code> <code>str</code> <p>The host IP address of the node</p> required <code>port</code> <code>int</code> <p>The port number the node is listening on</p> required Source code in <code>quantum_resistant_p2p\\networking\\discovery.py</code> <pre><code>def add_known_node(self, node_id: str, host: str, port: int) -&gt; None:\n    \"\"\"Manually add a known node to the discovery list.\n\n    Args:\n        node_id: The ID of the node\n        host: The host IP address of the node\n        port: The port number the node is listening on\n    \"\"\"\n    self.discovered_nodes[node_id] = (host, port, time.time())\n    logger.info(f\"Manually added node {node_id} at {host}:{port}\")\n</code></pre>"},{"location":"api/networking/#quantum_resistant_p2p.networking-functions","title":"Functions","text":""},{"location":"api/networking/#quantum_resistant_p2p.networking.load_or_generate_node_id","title":"<code>load_or_generate_node_id(key_storage=None, custom_id=None)</code>","text":"<p>Load an existing node ID from secure storage or generate a new persistent one.</p> <p>Parameters:</p> Name Type Description Default <code>key_storage</code> <p>Optional KeyStorage instance for secure storage. If None, uses file storage.</p> <code>None</code> <code>custom_id</code> <code>Optional[str]</code> <p>Optional custom ID to use instead of generating or loading</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The node ID as a string</p> Source code in <code>quantum_resistant_p2p\\networking\\node_identity.py</code> <pre><code>def load_or_generate_node_id(key_storage=None, custom_id: Optional[str] = None) -&gt; str:\n    \"\"\"Load an existing node ID from secure storage or generate a new persistent one.\n\n    Args:\n        key_storage: Optional KeyStorage instance for secure storage. If None, uses file storage.\n        custom_id: Optional custom ID to use instead of generating or loading\n\n    Returns:\n        The node ID as a string\n    \"\"\"\n    # If a custom ID is provided, use it and save it\n    if custom_id:\n        save_node_id(key_storage, custom_id)\n        return custom_id\n\n    # First try to load from KeyStorage if provided (encrypted storage)\n    if key_storage:\n        node_id_key = \"system_node_id\"\n        node_id_data = key_storage.get_key(node_id_key)\n\n        if node_id_data and \"node_id\" in node_id_data:\n            node_id = node_id_data[\"node_id\"]\n            logger.info(f\"Loaded encrypted node ID: {node_id[:8]}...\")\n            return node_id\n\n    # If not in KeyStorage or KeyStorage not provided, try the file location\n    node_id_file = get_app_data_dir() / \"node_id\"\n\n    if node_id_file.exists():\n        try:\n            with open(node_id_file, \"r\") as f:\n                node_id = f.read().strip()\n                if node_id:  # Make sure it's not empty\n                    logger.info(f\"Loaded node ID from file: {node_id[:8]}...\")\n\n                    # Migrate to secure storage if KeyStorage is available\n                    if key_storage:\n                        save_node_id(key_storage, node_id)\n                        # Delete the file after migration\n                        try:\n                            os.remove(node_id_file)\n                            logger.info(\"Deleted plaintext node ID file after migration to secure storage\")\n                        except Exception as e:\n                            logger.warning(f\"Failed to delete plaintext node ID file: {e}\")\n\n                    return node_id\n        except Exception as e:\n            logger.error(f\"Failed to load node ID from file: {e}\")\n\n    # Generate a new ID if no existing ID was found\n    node_id = str(uuid.uuid4())\n\n    # Save the new ID\n    save_node_id(key_storage, node_id)\n    logger.info(f\"Generated new persistent node ID: {node_id[:8]}...\")\n\n    return node_id\n</code></pre>"},{"location":"api/networking/#quantum_resistant_p2p.networking.save_node_id","title":"<code>save_node_id(key_storage, node_id)</code>","text":"<p>Save a node ID to storage for persistence.</p> <p>Parameters:</p> Name Type Description Default <code>key_storage</code> <p>Optional KeyStorage instance for secure storage. If None, uses file storage.</p> required <code>node_id</code> <code>str</code> <p>The node ID to save</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if saving succeeded, False otherwise</p> Source code in <code>quantum_resistant_p2p\\networking\\node_identity.py</code> <pre><code>def save_node_id(key_storage, node_id: str) -&gt; bool:\n    \"\"\"Save a node ID to storage for persistence.\n\n    Args:\n        key_storage: Optional KeyStorage instance for secure storage. If None, uses file storage.\n        node_id: The node ID to save\n\n    Returns:\n        True if saving succeeded, False otherwise\n    \"\"\"\n    # If KeyStorage is provided, use it for encrypted storage\n    if key_storage:\n        node_id_key = \"system_node_id\"\n\n        # Store the node ID in KeyStorage\n        node_id_data = {\n            \"node_id\": node_id,\n            \"created_at\": time.time()  # Use time.time() instead of non-existent method\n        }\n\n        success = key_storage.store_key(node_id_key, node_id_data)\n        if success:\n            logger.debug(f\"Saved encrypted node ID: {node_id[:8]}...\")\n            return True\n        else:\n            logger.error(\"Failed to save encrypted node ID\")\n            # Fall back to file storage if KeyStorage fails\n\n    # Use file storage as fallback or if KeyStorage not provided\n    node_id_file = get_app_data_dir() / \"node_id\"\n\n    try:\n        # Write the ID to the file\n        with open(node_id_file, \"w\") as f:\n            f.write(node_id)\n\n        # Set file permissions to be readable/writable only by the owner\n        if os.name == 'posix':  # Unix/Linux/MacOS\n            os.chmod(node_id_file, stat.S_IRUSR | stat.S_IWUSR)  # 0o600 permissions\n\n        logger.debug(f\"Saved node ID to file: {node_id[:8]}...\")\n        return True\n    except Exception as e:\n        logger.error(f\"Failed to save node ID to file: {e}\")\n        return False\n</code></pre>"},{"location":"api/networking/#quantum_resistant_p2p.networking.get_app_data_dir","title":"<code>get_app_data_dir()</code>","text":"<p>Get the application data directory, creating it if it doesn't exist.</p> Source code in <code>quantum_resistant_p2p\\networking\\node_identity.py</code> <pre><code>def get_app_data_dir() -&gt; Path:\n    \"\"\"Get the application data directory, creating it if it doesn't exist.\"\"\"\n    app_dir = Path.home() / \".quantum_resistant_p2p\"\n    app_dir.mkdir(exist_ok=True, parents=True)\n\n    # Set directory permissions to be accessible only by the owner\n    try:\n        if os.name == 'posix':  # Unix/Linux/MacOS\n            os.chmod(app_dir, stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR)  # 0o700 permissions\n    except Exception as e:\n        logger.warning(f\"Failed to set directory permissions: {e}\")\n\n    return app_dir\n</code></pre>"},{"location":"api/networking/discovery/","title":"Discovery Module","text":"<p>Node discovery implementation for P2P network. This module provides functionality for discovering other nodes in the network.</p>"},{"location":"api/networking/discovery/#quantum_resistant_p2p.networking.discovery","title":"<code>quantum_resistant_p2p.networking.discovery</code>","text":"<p>Node discovery implementation for P2P network.</p>"},{"location":"api/networking/discovery/#quantum_resistant_p2p.networking.discovery-classes","title":"Classes","text":""},{"location":"api/networking/discovery/#quantum_resistant_p2p.networking.discovery.NodeDiscovery","title":"<code>NodeDiscovery(node_id, host='0.0.0.0', port=8000, discovery_port=8001)</code>","text":"<p>Discovery mechanism for P2P nodes on the local network.</p> <p>This class provides functionality for discovering other nodes in the network using UDP broadcast messages. It implements both automatic discovery through broadcast messages and manual peer addition.</p> <p>Initialize a new node discovery service.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>str</code> <p>The ID of the node this discovery service is for</p> required <code>host</code> <code>str</code> <p>The host IP address the node is listening on</p> <code>'0.0.0.0'</code> <code>port</code> <code>int</code> <p>The port number the node is listening on</p> <code>8000</code> <code>discovery_port</code> <code>int</code> <p>The port to use for discovery broadcasts</p> <code>8001</code> Source code in <code>quantum_resistant_p2p\\networking\\discovery.py</code> <pre><code>def __init__(self, node_id: str, host: str = '0.0.0.0', \n            port: int = 8000, discovery_port: int = 8001):\n    \"\"\"Initialize a new node discovery service.\n\n    Args:\n        node_id: The ID of the node this discovery service is for\n        host: The host IP address the node is listening on\n        port: The port number the node is listening on\n        discovery_port: The port to use for discovery broadcasts\n    \"\"\"\n    self.node_id = node_id\n    self.host = host\n    self.port = port\n    self.discovery_port = discovery_port\n    self.discovered_nodes: Dict[str, Tuple[str, int, float]] = {}  # node_id -&gt; (host, port, last_seen)\n    self.running = False\n    self.transport = None\n    self.protocol = None\n\n    # If host is 0.0.0.0, try to get the actual IP\n    if host == '0.0.0.0':\n        self.advertised_host = self._get_local_ip()\n    else:\n        self.advertised_host = host\n\n    logger.info(f\"Node Discovery initialized for node {node_id}, advertising as {self.advertised_host}:{port}\")\n</code></pre>"},{"location":"api/networking/discovery/#quantum_resistant_p2p.networking.discovery.NodeDiscovery-functions","title":"Functions","text":"<code>start()</code> <code>async</code> \u00b6 <p>Start the discovery service.</p> Source code in <code>quantum_resistant_p2p\\networking\\discovery.py</code> <pre><code>async def start(self) -&gt; None:\n    \"\"\"Start the discovery service.\"\"\"\n    # Define the protocol\n    class DiscoveryProtocol(asyncio.DatagramProtocol):\n        def __init__(self, parent):\n            self.parent = parent\n            self.transport = None\n\n        def connection_made(self, transport):\n            self.transport = transport\n\n        def datagram_received(self, data, addr):\n            self.parent._handle_discovery_message(data, addr)\n\n        def error_received(self, exc):\n            logger.error(f\"Discovery protocol error: {exc}\")\n\n    try:\n        # Manual socket approach for better control\n        # Create a UDP socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n        # Set SO_REUSEADDR to allow reusing the address\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\n        # Bind to the discovery port\n        sock.bind(('0.0.0.0', self.discovery_port))\n\n        # Set socket to non-blocking mode (needed for asyncio)\n        sock.setblocking(False)\n\n        # Enable broadcasting (needed for broadcasting announcements)\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n\n        # Create the transport and protocol\n        loop = asyncio.get_running_loop()\n        self.transport, self.protocol = await loop.create_datagram_endpoint(\n            lambda: DiscoveryProtocol(self),\n            sock=sock\n        )\n\n        self.running = True\n        logger.info(f\"Discovery service started on port {self.discovery_port}\")\n\n        # Start the announcement and cleanup tasks\n        asyncio.create_task(self._periodic_announce())\n        asyncio.create_task(self._cleanup_old_nodes())\n\n    except Exception as e:\n        logger.error(f\"Failed to start discovery service: {e}\")\n        raise\n</code></pre> <code>stop()</code> <code>async</code> \u00b6 <p>Stop the discovery service.</p> Source code in <code>quantum_resistant_p2p\\networking\\discovery.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop the discovery service.\"\"\"\n    if self.transport:\n        self.transport.close()\n        self.running = False\n        logger.info(\"Discovery service stopped\")\n</code></pre> <code>get_discovered_nodes()</code> \u00b6 <p>Get a list of all discovered nodes.</p> <p>Returns:</p> Type Description <code>List[Tuple[str, str, int]]</code> <p>List of tuples (node_id, host, port)</p> Source code in <code>quantum_resistant_p2p\\networking\\discovery.py</code> <pre><code>def get_discovered_nodes(self) -&gt; List[Tuple[str, str, int]]:\n    \"\"\"Get a list of all discovered nodes.\n\n    Returns:\n        List of tuples (node_id, host, port)\n    \"\"\"\n    return [(node_id, host, port) \n            for node_id, (host, port, _) in self.discovered_nodes.items()]\n</code></pre> <code>add_known_node(node_id, host, port)</code> \u00b6 <p>Manually add a known node to the discovery list.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>str</code> <p>The ID of the node</p> required <code>host</code> <code>str</code> <p>The host IP address of the node</p> required <code>port</code> <code>int</code> <p>The port number the node is listening on</p> required Source code in <code>quantum_resistant_p2p\\networking\\discovery.py</code> <pre><code>def add_known_node(self, node_id: str, host: str, port: int) -&gt; None:\n    \"\"\"Manually add a known node to the discovery list.\n\n    Args:\n        node_id: The ID of the node\n        host: The host IP address of the node\n        port: The port number the node is listening on\n    \"\"\"\n    self.discovered_nodes[node_id] = (host, port, time.time())\n    logger.info(f\"Manually added node {node_id} at {host}:{port}\")\n</code></pre>"},{"location":"api/networking/node_identity/","title":"Node Identity Module","text":"<p>Secure node identity management with encryption support. This module provides functionality for managing node identities securely.</p>"},{"location":"api/networking/node_identity/#quantum_resistant_p2p.networking.node_identity","title":"<code>quantum_resistant_p2p.networking.node_identity</code>","text":"<p>Secure node identity management with encryption support.</p>"},{"location":"api/networking/node_identity/#quantum_resistant_p2p.networking.node_identity-functions","title":"Functions","text":""},{"location":"api/networking/node_identity/#quantum_resistant_p2p.networking.node_identity.get_app_data_dir","title":"<code>get_app_data_dir()</code>","text":"<p>Get the application data directory, creating it if it doesn't exist.</p> Source code in <code>quantum_resistant_p2p\\networking\\node_identity.py</code> <pre><code>def get_app_data_dir() -&gt; Path:\n    \"\"\"Get the application data directory, creating it if it doesn't exist.\"\"\"\n    app_dir = Path.home() / \".quantum_resistant_p2p\"\n    app_dir.mkdir(exist_ok=True, parents=True)\n\n    # Set directory permissions to be accessible only by the owner\n    try:\n        if os.name == 'posix':  # Unix/Linux/MacOS\n            os.chmod(app_dir, stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR)  # 0o700 permissions\n    except Exception as e:\n        logger.warning(f\"Failed to set directory permissions: {e}\")\n\n    return app_dir\n</code></pre>"},{"location":"api/networking/node_identity/#quantum_resistant_p2p.networking.node_identity.load_or_generate_node_id","title":"<code>load_or_generate_node_id(key_storage=None, custom_id=None)</code>","text":"<p>Load an existing node ID from secure storage or generate a new persistent one.</p> <p>Parameters:</p> Name Type Description Default <code>key_storage</code> <p>Optional KeyStorage instance for secure storage. If None, uses file storage.</p> <code>None</code> <code>custom_id</code> <code>Optional[str]</code> <p>Optional custom ID to use instead of generating or loading</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The node ID as a string</p> Source code in <code>quantum_resistant_p2p\\networking\\node_identity.py</code> <pre><code>def load_or_generate_node_id(key_storage=None, custom_id: Optional[str] = None) -&gt; str:\n    \"\"\"Load an existing node ID from secure storage or generate a new persistent one.\n\n    Args:\n        key_storage: Optional KeyStorage instance for secure storage. If None, uses file storage.\n        custom_id: Optional custom ID to use instead of generating or loading\n\n    Returns:\n        The node ID as a string\n    \"\"\"\n    # If a custom ID is provided, use it and save it\n    if custom_id:\n        save_node_id(key_storage, custom_id)\n        return custom_id\n\n    # First try to load from KeyStorage if provided (encrypted storage)\n    if key_storage:\n        node_id_key = \"system_node_id\"\n        node_id_data = key_storage.get_key(node_id_key)\n\n        if node_id_data and \"node_id\" in node_id_data:\n            node_id = node_id_data[\"node_id\"]\n            logger.info(f\"Loaded encrypted node ID: {node_id[:8]}...\")\n            return node_id\n\n    # If not in KeyStorage or KeyStorage not provided, try the file location\n    node_id_file = get_app_data_dir() / \"node_id\"\n\n    if node_id_file.exists():\n        try:\n            with open(node_id_file, \"r\") as f:\n                node_id = f.read().strip()\n                if node_id:  # Make sure it's not empty\n                    logger.info(f\"Loaded node ID from file: {node_id[:8]}...\")\n\n                    # Migrate to secure storage if KeyStorage is available\n                    if key_storage:\n                        save_node_id(key_storage, node_id)\n                        # Delete the file after migration\n                        try:\n                            os.remove(node_id_file)\n                            logger.info(\"Deleted plaintext node ID file after migration to secure storage\")\n                        except Exception as e:\n                            logger.warning(f\"Failed to delete plaintext node ID file: {e}\")\n\n                    return node_id\n        except Exception as e:\n            logger.error(f\"Failed to load node ID from file: {e}\")\n\n    # Generate a new ID if no existing ID was found\n    node_id = str(uuid.uuid4())\n\n    # Save the new ID\n    save_node_id(key_storage, node_id)\n    logger.info(f\"Generated new persistent node ID: {node_id[:8]}...\")\n\n    return node_id\n</code></pre>"},{"location":"api/networking/node_identity/#quantum_resistant_p2p.networking.node_identity.save_node_id","title":"<code>save_node_id(key_storage, node_id)</code>","text":"<p>Save a node ID to storage for persistence.</p> <p>Parameters:</p> Name Type Description Default <code>key_storage</code> <p>Optional KeyStorage instance for secure storage. If None, uses file storage.</p> required <code>node_id</code> <code>str</code> <p>The node ID to save</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if saving succeeded, False otherwise</p> Source code in <code>quantum_resistant_p2p\\networking\\node_identity.py</code> <pre><code>def save_node_id(key_storage, node_id: str) -&gt; bool:\n    \"\"\"Save a node ID to storage for persistence.\n\n    Args:\n        key_storage: Optional KeyStorage instance for secure storage. If None, uses file storage.\n        node_id: The node ID to save\n\n    Returns:\n        True if saving succeeded, False otherwise\n    \"\"\"\n    # If KeyStorage is provided, use it for encrypted storage\n    if key_storage:\n        node_id_key = \"system_node_id\"\n\n        # Store the node ID in KeyStorage\n        node_id_data = {\n            \"node_id\": node_id,\n            \"created_at\": time.time()  # Use time.time() instead of non-existent method\n        }\n\n        success = key_storage.store_key(node_id_key, node_id_data)\n        if success:\n            logger.debug(f\"Saved encrypted node ID: {node_id[:8]}...\")\n            return True\n        else:\n            logger.error(\"Failed to save encrypted node ID\")\n            # Fall back to file storage if KeyStorage fails\n\n    # Use file storage as fallback or if KeyStorage not provided\n    node_id_file = get_app_data_dir() / \"node_id\"\n\n    try:\n        # Write the ID to the file\n        with open(node_id_file, \"w\") as f:\n            f.write(node_id)\n\n        # Set file permissions to be readable/writable only by the owner\n        if os.name == 'posix':  # Unix/Linux/MacOS\n            os.chmod(node_id_file, stat.S_IRUSR | stat.S_IWUSR)  # 0o600 permissions\n\n        logger.debug(f\"Saved node ID to file: {node_id[:8]}...\")\n        return True\n    except Exception as e:\n        logger.error(f\"Failed to save node ID to file: {e}\")\n        return False\n</code></pre>"},{"location":"api/networking/p2p_node/","title":"P2P Node Module","text":"<p>P2P Node implementation for quantum-resistant P2P communication. This module provides the core functionality for peer-to-peer networking.</p>"},{"location":"api/networking/p2p_node/#quantum_resistant_p2p.networking.p2p_node","title":"<code>quantum_resistant_p2p.networking.p2p_node</code>","text":"<p>P2P Node implementation for quantum-resistant P2P communication.</p>"},{"location":"api/networking/p2p_node/#quantum_resistant_p2p.networking.p2p_node-classes","title":"Classes","text":""},{"location":"api/networking/p2p_node/#quantum_resistant_p2p.networking.p2p_node.P2PNode","title":"<code>P2PNode(host='0.0.0.0', port=8000, node_id=None, max_chunk_size=64 * 1024, node_discovery=None, key_storage=None)</code>","text":"<p>A peer-to-peer network node supporting direct communication between peers.</p> <p>Initialize a new P2P node.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The host IP address to bind to</p> <code>'0.0.0.0'</code> <code>port</code> <code>int</code> <p>The port number to listen on</p> <code>8000</code> <code>node_id</code> <code>Optional[str]</code> <p>Unique identifier for this node. If None, a persistent ID will be loaded or generated.</p> <code>None</code> <code>max_chunk_size</code> <code>int</code> <p>Maximum size of message chunks in bytes</p> <code>64 * 1024</code> <code>node_discovery</code> <p>Optional reference to the NodeDiscovery instance</p> <code>None</code> <code>key_storage</code> <p>Optional reference to KeyStorage for secure node ID storage</p> <code>None</code> Source code in <code>quantum_resistant_p2p\\networking\\p2p_node.py</code> <pre><code>def __init__(self, host: str = '0.0.0.0', port: int = 8000, node_id: Optional[str] = None,\n             max_chunk_size: int = 64*1024, node_discovery=None, key_storage=None):\n    \"\"\"Initialize a new P2P node.\n\n    Args:\n        host: The host IP address to bind to\n        port: The port number to listen on\n        node_id: Unique identifier for this node. If None, a persistent ID will be loaded or generated.\n        max_chunk_size: Maximum size of message chunks in bytes\n        node_discovery: Optional reference to the NodeDiscovery instance\n        key_storage: Optional reference to KeyStorage for secure node ID storage\n    \"\"\"\n    self.host = host\n    self.port = port\n    # Use the utility function to load or generate a persistent node ID\n    # KeyStorage is passed for secure storage if available\n    self.node_id = load_or_generate_node_id(key_storage, node_id)\n    self.max_chunk_size = max_chunk_size\n    self.peers: Dict[str, Tuple[str, int]] = {}  # node_id -&gt; (host, port)\n    self.connections: Dict[str, asyncio.StreamWriter] = {}  # node_id -&gt; writer\n    self.server = None\n    self.message_handlers: Dict[str, List[Callable]] = {}\n    self.connection_handlers: Set[Callable[[str], None]] = set()\n    self.running = False\n    self.node_discovery = node_discovery  # Store reference to NodeDiscovery\n\n    if key_storage:\n        logger.info(f\"P2P Node initialized with secure persistent ID: {self.node_id[:8]}...\")\n    else:\n        logger.info(f\"P2P Node initialized with persistent ID: {self.node_id[:8]}...\")\n</code></pre>"},{"location":"api/networking/p2p_node/#quantum_resistant_p2p.networking.p2p_node.P2PNode-functions","title":"Functions","text":"<code>start()</code> <code>async</code> \u00b6 <p>Start the P2P node server.</p> Source code in <code>quantum_resistant_p2p\\networking\\p2p_node.py</code> <pre><code>async def start(self) -&gt; None:\n    \"\"\"Start the P2P node server.\"\"\"\n    self.server = await asyncio.start_server(\n        self._handle_connection, self.host, self.port\n    )\n\n    self.running = True\n    logger.info(f\"P2P Node {self.node_id} listening on {self.host}:{self.port}\")\n\n    async with self.server:\n        await self.server.serve_forever()\n</code></pre> <code>stop()</code> <code>async</code> \u00b6 <p>Stop the P2P node server.</p> Source code in <code>quantum_resistant_p2p\\networking\\p2p_node.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop the P2P node server.\"\"\"\n    if self.server:\n        self.server.close()\n        await self.server.wait_closed()\n        self.running = False\n\n        # Close all connections\n        for writer in self.connections.values():\n            writer.close()\n            try:\n                await writer.wait_closed()\n            except Exception as e:\n                logger.error(f\"Error closing connection: {e}\")\n\n        self.connections.clear()\n        logger.info(f\"P2P Node {self.node_id} stopped\")\n</code></pre> <code>register_connection_handler(handler)</code> \u00b6 <p>Register a handler for new peer connections.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable[[str], None]</code> <p>Function to call when a new peer connects. Takes peer_id as parameter.</p> required Source code in <code>quantum_resistant_p2p\\networking\\p2p_node.py</code> <pre><code>def register_connection_handler(self, handler: Callable[[str], None]) -&gt; None:\n    \"\"\"Register a handler for new peer connections.\n\n    Args:\n        handler: Function to call when a new peer connects. Takes peer_id as parameter.\n    \"\"\"\n    self.connection_handlers.add(handler)\n    logger.debug(f\"Registered connection handler {id(handler)}\")\n</code></pre> <code>connect_to_peer(host, port)</code> <code>async</code> \u00b6 <p>Connect to a peer at the specified host and port.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The host IP address or hostname of the peer</p> required <code>port</code> <code>int</code> <p>The port number the peer is listening on</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if connection successful, False otherwise</p> Source code in <code>quantum_resistant_p2p\\networking\\p2p_node.py</code> <pre><code>async def connect_to_peer(self, host: str, port: int) -&gt; bool:\n    \"\"\"Connect to a peer at the specified host and port.\n\n    Args:\n        host: The host IP address or hostname of the peer\n        port: The port number the peer is listening on\n\n    Returns:\n        bool: True if connection successful, False otherwise\n    \"\"\"\n    logger.info(f\"Attempting to connect to peer at {host}:{port}\")\n\n    # First check if we're already connected to this peer by host and port\n    for peer_id, (peer_host, peer_port) in self.peers.items():\n        if peer_host == host and peer_port == port:\n            logger.info(f\"Already connected to peer {peer_id} at {host}:{port}\")\n            return True\n\n    try:\n        reader, writer = await asyncio.open_connection(host, port)\n\n        # Send initial message with our node ID\n        initial_message = {\n            'node_id': self.node_id,\n            'type': 'hello'\n        }\n        initial_json = json.dumps(initial_message).encode()\n\n        # Use chunked sending\n        await self._send_chunked_message(writer, initial_json)\n        logger.debug(f\"Sent hello message to {host}:{port}\")\n\n        # Read peer's response to get their node ID\n        try:\n            data = await asyncio.wait_for(self._read_message(reader), timeout=5.0)\n            if not data:\n                logger.error(f\"No response from peer at {host}:{port}\")\n                writer.close()\n                return False\n        except asyncio.TimeoutError:\n            logger.error(f\"Timeout waiting for response from {host}:{port}\")\n            writer.close()\n            return False\n\n        try:\n            message = json.loads(data.decode())\n        except json.JSONDecodeError:\n            logger.error(f\"Invalid JSON response from peer at {host}:{port}\")\n            writer.close()\n            return False\n\n        if 'node_id' not in message:\n            logger.error(f\"Invalid response from peer at {host}:{port}, missing node_id\")\n            writer.close()\n            return False\n\n        peer_id = message['node_id']\n\n        # Don't connect to ourselves\n        if peer_id == self.node_id:\n            logger.warning(f\"Attempted to connect to ourselves at {host}:{port}\")\n            writer.close()\n            return False\n\n        # Store peer information\n        self.peers[peer_id] = (host, port)\n        self.connections[peer_id] = writer\n\n        logger.info(f\"Connected to peer {peer_id} at {host}:{port}\")\n\n        # Start a task to handle messages from this peer\n        asyncio.create_task(self._handle_peer_messages(peer_id, reader))\n\n        # Notify connection handlers\n        await self._notify_connection_handlers(peer_id)\n\n        # NEW: If we have a node discovery instance, add the peer to it\n        # This ensures the peer immediately shows up in both sides' peer lists\n        if hasattr(self, 'node_discovery') and self.node_discovery:\n            self.node_discovery.add_known_node(peer_id, host, port)\n            # Also send a direct announcement to the new peer\n            self.node_discovery._send_direct_announcement(host, port)\n\n        return True\n\n    except (OSError, asyncio.TimeoutError) as e:\n        logger.error(f\"Failed to connect to peer at {host}:{port}: {e}\")\n        return False\n    except Exception as e:\n        logger.error(f\"Unexpected error connecting to peer at {host}:{port}: {e}\")\n        return False\n</code></pre> <code>send_message(peer_id, message_type, **kwargs)</code> <code>async</code> \u00b6 <p>Send a message to a specific peer.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <code>str</code> <p>The ID of the peer to send the message to</p> required <code>message_type</code> <code>str</code> <p>The type of message being sent</p> required <code>**kwargs</code> <p>Additional key-value pairs to include in the message</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if message was sent, False otherwise</p> Source code in <code>quantum_resistant_p2p\\networking\\p2p_node.py</code> <pre><code>async def send_message(self, peer_id: str, message_type: str, **kwargs) -&gt; bool:\n    \"\"\"Send a message to a specific peer.\n\n    Args:\n        peer_id: The ID of the peer to send the message to\n        message_type: The type of message being sent\n        **kwargs: Additional key-value pairs to include in the message\n\n    Returns:\n        bool: True if message was sent, False otherwise\n    \"\"\"\n    if peer_id not in self.connections:\n        logger.error(f\"Cannot send message to unknown peer {peer_id}\")\n        return False\n\n    try:\n        message = {\n            'type': message_type,\n            'from': self.node_id,\n            **kwargs\n        }\n\n        writer = self.connections[peer_id]\n        message_json = json.dumps(message).encode()\n\n        # Use chunked sending\n        success = await self._send_chunked_message(writer, message_json)\n\n        if success:\n            logger.debug(f\"Sent {message_type} message to {peer_id}\")\n            return True\n        else:\n            logger.error(f\"Failed to send message to {peer_id}\")\n\n    except (ConnectionError, asyncio.TimeoutError) as e:\n        logger.error(f\"Failed to send message to {peer_id}: {e}\")\n    except Exception as e:\n        logger.error(f\"Unexpected error sending message to {peer_id}: {e}\")\n\n    # Remove the peer if we can't send to them\n    if peer_id in self.peers:\n        del self.peers[peer_id]\n    if peer_id in self.connections:\n        try:\n            self.connections[peer_id].close()\n        except Exception:\n            pass\n        del self.connections[peer_id]\n\n    return False\n</code></pre> <code>register_message_handler(message_type, handler)</code> \u00b6 <p>Register a handler function for a specific message type.</p> <p>Parameters:</p> Name Type Description Default <code>message_type</code> <code>str</code> <p>The type of message to handle</p> required <code>handler</code> <code>Callable</code> <p>The callback function to call when a message of this type is received.      The function should accept (peer_id, message) as parameters.</p> required Source code in <code>quantum_resistant_p2p\\networking\\p2p_node.py</code> <pre><code>def register_message_handler(self, message_type: str, handler: Callable) -&gt; None:\n    \"\"\"Register a handler function for a specific message type.\n\n    Args:\n        message_type: The type of message to handle\n        handler: The callback function to call when a message of this type is received.\n                 The function should accept (peer_id, message) as parameters.\n    \"\"\"\n    if message_type not in self.message_handlers:\n        self.message_handlers[message_type] = []\n\n    self.message_handlers[message_type].append(handler)\n    logger.debug(f\"Registered handler for message type {message_type}\")\n</code></pre> <code>get_peers()</code> \u00b6 <p>Get a list of connected peer IDs.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of peer IDs</p> Source code in <code>quantum_resistant_p2p\\networking\\p2p_node.py</code> <pre><code>def get_peers(self) -&gt; List[str]:\n    \"\"\"Get a list of connected peer IDs.\n\n    Returns:\n        List of peer IDs\n    \"\"\"\n    return list(self.peers.keys())\n</code></pre> <code>get_peer_info(peer_id)</code> \u00b6 <p>Get the host and port for a specific peer.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <code>str</code> <p>The ID of the peer</p> required <p>Returns:</p> Type Description <code>Optional[Tuple[str, int]]</code> <p>Tuple of (host, port) if the peer exists, None otherwise</p> Source code in <code>quantum_resistant_p2p\\networking\\p2p_node.py</code> <pre><code>def get_peer_info(self, peer_id: str) -&gt; Optional[Tuple[str, int]]:\n    \"\"\"Get the host and port for a specific peer.\n\n    Args:\n        peer_id: The ID of the peer\n\n    Returns:\n        Tuple of (host, port) if the peer exists, None otherwise\n    \"\"\"\n    return self.peers.get(peer_id)\n</code></pre>"},{"location":"api/networking/p2p_node/#quantum_resistant_p2p.networking.p2p_node-functions","title":"Functions","text":""},{"location":"api/ui/","title":"UI Package","text":"<p>User interface for the post-quantum P2P application. This package provides the graphical user interface for the application.</p>"},{"location":"api/ui/#quantum_resistant_p2p.ui","title":"<code>quantum_resistant_p2p.ui</code>","text":"<p>User interface for the post-quantum P2P application.</p> <p>This package provides the graphical user interface for the application.</p>"},{"location":"api/ui/#quantum_resistant_p2p.ui-classes","title":"Classes","text":""},{"location":"api/ui/#quantum_resistant_p2p.ui.MainWindow","title":"<code>MainWindow()</code>","text":"<p>               Bases: <code>QMainWindow</code></p> <p>Main window for the application.</p> <p>Initialize the main window.</p> Source code in <code>quantum_resistant_p2p\\ui\\main_window.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the main window.\"\"\"\n    super().__init__()\n\n    # Initialize components\n    self.key_storage = KeyStorage()\n    # Secure logger will be initialized after login when we have the master key\n    self.secure_logger = None\n\n    # Network components will be initialized after login\n    self.node = None\n    self.node_discovery = None\n    self.secure_messaging = None\n\n    # Track if message handler has been registered to prevent duplicates\n    self._message_handler_registered = False\n\n    # UI initialization\n    self.setWindowTitle(\"Quantum Resistant P2P\")\n    self.setMinimumSize(800, 600)\n\n    self.central_widget = QWidget()\n    self.setCentralWidget(self.central_widget)\n\n    layout = QVBoxLayout(self.central_widget)\n    layout.addWidget(QLabel(\"Logging in...\"))\n\n    # Connect async signal\n    self.async_task.connect(self._run_async_task)\n\n    # Show login dialog first\n    QTimer.singleShot(100, self._show_login_dialog)\n</code></pre>"},{"location":"api/ui/#quantum_resistant_p2p.ui.MainWindow-functions","title":"Functions","text":"<code>closeEvent(event)</code> \u00b6 <p>Handle the window close event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <p>The close event</p> required Source code in <code>quantum_resistant_p2p\\ui\\main_window.py</code> <pre><code>def closeEvent(self, event):\n    \"\"\"Handle the window close event.\n\n    Args:\n        event: The close event\n    \"\"\"\n    # If we have a messaging widget, make sure to clean it up\n    if hasattr(self, 'messaging') and self.messaging:\n        # This will trigger the destroyed signal and _cleanup_resources\n        self.messaging.deleteLater()\n\n    # Stop the network components asynchronously\n    asyncio.create_task(self._async_stop_network())\n    event.accept()\n</code></pre>"},{"location":"api/ui/#quantum_resistant_p2p.ui.LoginDialog","title":"<code>LoginDialog(key_storage, parent=None)</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>Dialog for unlocking the key storage with a password.</p> <p>Initialize the login dialog.</p> <p>Parameters:</p> Name Type Description Default <code>key_storage</code> <code>KeyStorage</code> <p>The key storage to unlock</p> required <code>parent</code> <p>The parent widget</p> <code>None</code> Source code in <code>quantum_resistant_p2p\\ui\\login_dialog.py</code> <pre><code>def __init__(self, key_storage: KeyStorage, parent=None):\n    \"\"\"Initialize the login dialog.\n\n    Args:\n        key_storage: The key storage to unlock\n        parent: The parent widget\n    \"\"\"\n    super().__init__(parent)\n\n    self.key_storage = key_storage\n\n    self.setWindowTitle(\"Unlock Key Storage\")\n    self.setMinimumWidth(350)\n\n    self._init_ui()\n</code></pre>"},{"location":"api/ui/#quantum_resistant_p2p.ui.LoginDialog-functions","title":"Functions","text":"<code>try_unlock()</code> \u00b6 <p>Try to unlock the key storage with the entered password.</p> Source code in <code>quantum_resistant_p2p\\ui\\login_dialog.py</code> <pre><code>def try_unlock(self):\n    \"\"\"Try to unlock the key storage with the entered password.\"\"\"\n    password = self.password_input.text()\n    confirm = self.confirm_input.text()\n\n    if not password:\n        QMessageBox.warning(self, \"Error\", \"Please enter a password.\")\n        return\n\n    # Check if passwords match\n    if self.confirm_input.isVisible() and password != confirm:\n        QMessageBox.warning(self, \"Error\", \"Passwords do not match.\")\n        return\n\n    # Try to unlock the key storage\n    success = self.key_storage.unlock(password)\n\n    if success:\n        logger.info(\"Key storage unlocked successfully\")\n        self.login_successful.emit()\n        self.accept()\n    else:\n        # Show error dialog with option to try again or reset password\n        reply = QMessageBox(QMessageBox.Warning, \"Login Failed\", \n                            \"Failed to unlock key storage. Incorrect password?\", \n                            QMessageBox.NoButton, self)\n\n        # Add custom buttons\n        try_again_button = reply.addButton(\"Try Again\", QMessageBox.AcceptRole)\n        reset_button = reply.addButton(\"Reset Password\", QMessageBox.ActionRole)\n        cancel_button = reply.addButton(\"Cancel\", QMessageBox.RejectRole)\n\n        reply.exec_()\n\n        clicked_button = reply.clickedButton()\n\n        if clicked_button == try_again_button:\n            # Clear input and set focus for another attempt\n            self.password_input.clear()\n            self.confirm_input.clear()\n            self.password_input.setFocus()\n        elif clicked_button == reset_button:\n            # Show the reset password dialog\n            self._show_reset_password_dialog()\n        else:  # Cancel button\n            # Reject the dialog to close the application\n            self.reject()\n</code></pre>"},{"location":"api/ui/#quantum_resistant_p2p.ui.PeerListWidget","title":"<code>PeerListWidget(node, discovery, secure_messaging=None, message_store=None, parent=None)</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>Widget for displaying and interacting with the list of peers.</p> <p>Initialize the peer list widget.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>P2PNode</code> <p>The P2P node</p> required <code>discovery</code> <code>NodeDiscovery</code> <p>The node discovery service</p> required <code>secure_messaging</code> <p>The secure messaging service (optional)</p> <code>None</code> <code>message_store</code> <p>The message store for persistent messages (optional)</p> <code>None</code> <code>parent</code> <p>The parent widget</p> <code>None</code> Source code in <code>quantum_resistant_p2p\\ui\\peer_list.py</code> <pre><code>def __init__(self, node: P2PNode, discovery: NodeDiscovery, secure_messaging=None, message_store=None, parent=None):\n    \"\"\"Initialize the peer list widget.\n\n    Args:\n        node: The P2P node\n        discovery: The node discovery service\n        secure_messaging: The secure messaging service (optional)\n        message_store: The message store for persistent messages (optional)\n        parent: The parent widget\n    \"\"\"\n    super().__init__(parent)\n\n    self.node = node\n    self.discovery = discovery\n    self.secure_messaging = secure_messaging\n    self.message_store = message_store\n\n    # Keep track of the currently selected peer\n    self.current_peer_id = None\n\n    self._init_ui()\n\n    # If we have secure messaging, register for crypto changes\n    if self.secure_messaging:\n        self.secure_messaging.register_settings_change_listener(self._refresh_crypto_indicators)\n</code></pre>"},{"location":"api/ui/#quantum_resistant_p2p.ui.PeerListWidget-functions","title":"Functions","text":"<code>update_peers(discovered, connected)</code> \u00b6 <p>Update the list of peers while preserving selection.</p> <p>Parameters:</p> Name Type Description Default <code>discovered</code> <code>list</code> <p>List of discovered peers (node_id, host, port)</p> required <code>connected</code> <code>list</code> <p>List of connected peer IDs</p> required Source code in <code>quantum_resistant_p2p\\ui\\peer_list.py</code> <pre><code>def update_peers(self, discovered: list, connected: list):\n    \"\"\"Update the list of peers while preserving selection.\n\n    Args:\n        discovered: List of discovered peers (node_id, host, port)\n        connected: List of connected peer IDs\n    \"\"\"\n    # Remember the currently selected peer ID\n    selected_rows = self.peer_table.selectedItems()\n    if selected_rows and selected_rows[0].column() == 0:  # Make sure we get a peer ID column\n        selected_peer_id = selected_rows[0].data(Qt.UserRole)\n    else:\n        selected_peer_id = self.current_peer_id\n\n    # Remember scroll position\n    scrollbar_pos = self.peer_table.verticalScrollBar().value()\n\n    # Clear and rebuild the table\n    self.peer_table.setRowCount(0)  # Clear all rows\n    self.peer_table.setSortingEnabled(False)  # Disable sorting while updating\n\n    # Rebuild the table\n    row = 0\n    for node_id, host, port in discovered:\n        self.peer_table.insertRow(row)\n\n        # Determine state\n        is_connected = node_id in connected\n        has_shared_key = False\n        is_secure = False\n\n        if self.secure_messaging:\n            has_shared_key = node_id in self.secure_messaging.shared_keys\n            key_exchange_state = self.secure_messaging.key_exchange_states.get(node_id, 0)\n            is_secure = has_shared_key and key_exchange_state == 4  # ESTABLISHED\n\n        # ID column (short peer ID + address)\n        id_item = QTableWidgetItem(f\"{node_id[:8]}...\")\n        id_item.setData(Qt.UserRole, node_id)  # Store full ID\n        id_item.setData(Qt.UserRole + 1, host)  # Store host\n        id_item.setData(Qt.UserRole + 2, port)  # Store port\n\n        # Set tooltip with full information\n        tooltip = f\"ID: {node_id}\\nHost: {host}\\nPort: {port}\"\n        if self.secure_messaging and node_id in self.secure_messaging.peer_crypto_settings:\n            peer_settings = self.secure_messaging.peer_crypto_settings[node_id]\n            key_exchange = peer_settings.get(\"key_exchange\", \"Unknown\")\n            symmetric = peer_settings.get(\"symmetric\", \"Unknown\")\n            signature = peer_settings.get(\"signature\", \"Unknown\")\n            tooltip += f\"\\n\\nCrypto Settings:\\nKey Exchange: {key_exchange}\\nSymmetric: {symmetric}\\nSignature: {signature}\"\n        id_item.setToolTip(tooltip)\n\n        # Status column\n        status_item = QTableWidgetItem()\n\n        # Set text based on state\n        if is_connected:\n            if is_secure:\n                status_text = \"Secure\"\n            else:\n                if has_shared_key:\n                    status_text = \"Connected, Key Issue\"\n                else:\n                    status_text = \"Connected\"\n\n            # Add crypto compatibility indicator\n            if self.secure_messaging and node_id in self.secure_messaging.peer_crypto_settings:\n                peer_settings = self.secure_messaging.peer_crypto_settings[node_id]\n                my_settings = {\n                    \"key_exchange\": self.secure_messaging.key_exchange.name,\n                    \"symmetric\": self.secure_messaging.symmetric.name,\n                    \"signature\": self.secure_messaging.signature.name\n                }\n\n                # Check for mismatches\n                has_mismatches = any(\n                    peer_settings.get(key, \"\") != my_settings[key]\n                    for key in my_settings\n                    if key in peer_settings\n                )\n\n                if has_mismatches:\n                    status_text += \" \u26a0\ufe0f\"\n\n        else:\n            status_text = \"Discovered\"\n\n        status_item.setText(status_text)\n\n        # Add to table\n        self.peer_table.setItem(row, 0, id_item)\n        self.peer_table.setItem(row, 1, status_item)\n\n        # Apply color based on state\n        background_color = Qt.white  # Default white\n        text_color = Qt.black  # Default black\n\n        if is_connected:\n            if is_secure:\n                background_color = QColor(230, 255, 230)  # Light green\n            else:\n                background_color = QColor(240, 240, 255)  # Light blue\n\n        # Apply colors to both columns\n        id_item.setBackground(background_color)\n        status_item.setBackground(background_color)\n        id_item.setForeground(text_color)\n        status_item.setForeground(text_color)\n\n        # Separately handle unread messages\n        if self.message_store and self.message_store.has_unread_messages(node_id):\n            unread_count = self.message_store.get_unread_count(node_id)\n\n            # Make text bold for unread messages\n            font = id_item.font()\n            font.setBold(True)\n            id_item.setFont(font)\n            status_item.setFont(font)\n\n            # Update status text to include unread count\n            status_item.setText(f\"{status_text} ({unread_count} unread)\")\n\n        row += 1\n\n    # Restore selection if possible\n    if selected_peer_id:\n        for r in range(self.peer_table.rowCount()):\n            item = self.peer_table.item(r, 0)  # ID column\n            if item and item.data(Qt.UserRole) == selected_peer_id:\n                self.peer_table.selectRow(r)\n                break\n\n    # Restore scroll position\n    self.peer_table.verticalScrollBar().setValue(scrollbar_pos)\n\n    # Re-enable sorting\n    self.peer_table.setSortingEnabled(True)\n\n    logger.debug(f\"Updated peer table with {len(discovered)} peers\")\n</code></pre>"},{"location":"api/ui/#quantum_resistant_p2p.ui.MessagingWidget","title":"<code>MessagingWidget(secure_messaging, message_store=None, parent=None)</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>Widget for securely messaging with peers.</p> <p>Initialize the messaging widget.</p> <p>Parameters:</p> Name Type Description Default <code>secure_messaging</code> <code>SecureMessaging</code> <p>The secure messaging service</p> required <code>message_store</code> <p>The message store for persistent messages (optional)</p> <code>None</code> <code>parent</code> <p>The parent widget</p> <code>None</code> Source code in <code>quantum_resistant_p2p\\ui\\messaging_widget.py</code> <pre><code>def __init__(self, secure_messaging: SecureMessaging, message_store=None, parent=None):\n    \"\"\"Initialize the messaging widget.\n\n    Args:\n        secure_messaging: The secure messaging service\n        message_store: The message store for persistent messages (optional)\n        parent: The parent widget\n    \"\"\"\n    super().__init__(parent)\n\n    self.secure_messaging = secure_messaging\n    self.message_store = message_store\n    self.current_peer = None\n    self.is_connecting = False\n\n    self._init_ui()\n\n    # Connect async signal\n    self.async_task.connect(self._run_async_task)\n\n    # Register for crypto settings changes\n    self.secure_messaging.register_settings_change_listener(self._on_crypto_settings_changed)\n\n    # Add connection status checker timer\n    self.connection_checker = QTimer(self)\n    self.connection_checker.timeout.connect(self._check_connection_status)\n    self.connection_checker.start(2000)  # Check every 2 seconds\n\n    # Connect to the destroyed signal to clean up resources\n    self.destroyed.connect(self._cleanup_resources)\n</code></pre>"},{"location":"api/ui/#quantum_resistant_p2p.ui.MessagingWidget-functions","title":"Functions","text":"<code>set_current_peer(peer_id)</code> \u00b6 <p>Set the current peer for messaging.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <code>str</code> <p>The ID of the peer</p> required Source code in <code>quantum_resistant_p2p\\ui\\messaging_widget.py</code> <pre><code>def set_current_peer(self, peer_id: str):\n    \"\"\"Set the current peer for messaging.\n\n    Args:\n        peer_id: The ID of the peer\n    \"\"\"\n    # Clear previous notification flag\n    if hasattr(self, '_mismatch_notified'):\n        delattr(self, '_mismatch_notified')\n\n    self.current_peer = peer_id\n    self.peer_label.setText(f\"Chatting with: {peer_id[:8]}...\")\n\n    # Enable settings and refresh buttons when peer is selected\n    self.settings_button.setEnabled(True)\n    self.refresh_button.setEnabled(True)\n\n    # Clear the chat area and file message map\n    self.chat_area.clear()\n    self.file_messages.clear()\n\n    # Add a system message\n    self._add_system_message(f\"Started chat with {peer_id[:8]}...\")\n\n    # Check connection status\n    connected_peers = self.secure_messaging.node.get_peers()\n    is_connected = peer_id in connected_peers\n\n    # Initialize previous connection state\n    self.previous_connection_state = is_connected\n\n    if is_connected:\n        self._add_system_message(\"Connected to peer\")\n        has_shared_key = peer_id in self.secure_messaging.shared_keys\n        key_exchange_state = self.secure_messaging.key_exchange_states.get(peer_id, 0)\n\n        if has_shared_key and key_exchange_state == 4:  # KeyExchangeState.ESTABLISHED\n            self._add_system_message(\"Secure connection established\")\n            self._enable_messaging()\n        else:\n            self._add_system_message(\"No secure connection established. Use 'Establish Shared Key' button to create a secure channel.\", True)\n            self._disable_messaging()\n\n            # Request crypto settings to prepare for key exchange\n            self.async_task.emit(\n                self.secure_messaging.request_crypto_settings_from_peer(peer_id)\n            )\n\n        # Make crypto panel visible immediately with \"requesting\" status\n        self.crypto_panel.setVisible(True)\n\n        # Request crypto settings from the peer\n        self.async_task.emit(\n            self.secure_messaging.request_crypto_settings_from_peer(peer_id)\n        )\n    else:\n        self._add_system_message(\"Not connected to peer. Attempting to autoconnect...\", True)\n        self._disable_messaging()\n\n    # Load previous messages if we have a message store\n    if self.message_store:\n        messages = self.message_store.get_messages(peer_id)\n        if messages:\n            self._add_system_message(f\"Loading {len(messages)} previous messages...\")\n\n            for message in messages:\n                # Determine if this message is from us or the peer\n                is_outgoing = message.sender_id == self.secure_messaging.node.node_id\n                self._add_message(message, is_outgoing)\n\n    # Update the crypto settings display\n    self._update_crypto_display()\n\n    logger.info(f\"Set current peer to {peer_id}\")\n</code></pre> <code>initiate_connection(peer_id, host, port)</code> \u00b6 <p>Initiate connection to a peer.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <code>str</code> <p>The ID of the peer</p> required <code>host</code> <code>str</code> <p>The host address of the peer</p> required <code>port</code> <code>int</code> <p>The port number of the peer</p> required Source code in <code>quantum_resistant_p2p\\ui\\messaging_widget.py</code> <pre><code>def initiate_connection(self, peer_id: str, host: str, port: int):\n    \"\"\"Initiate connection to a peer.\n\n    Args:\n        peer_id: The ID of the peer\n        host: The host address of the peer\n        port: The port number of the peer\n    \"\"\"\n    # Check if this is the currently selected peer\n    if peer_id != self.current_peer:\n        return\n\n    # Check if already connecting\n    if self.is_connecting:\n        return\n\n    self.is_connecting = True\n\n    self._add_system_message(f\"Connecting to {host}:{port}...\")\n\n    # Start connection task\n    self.async_task.emit(self._connect_to_peer(host, port))\n</code></pre> <code>handle_message(message)</code> \u00b6 <p>Handle a received message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>The received message</p> required Source code in <code>quantum_resistant_p2p\\ui\\messaging_widget.py</code> <pre><code>def handle_message(self, message: Message):\n    \"\"\"Handle a received message.\n\n    Args:\n        message: The received message\n    \"\"\"\n    logger.debug(f\"MessagingWidget displaying message {message.message_id} from {message.sender_id}\")\n\n    # Special handling for system messages\n    if message.is_system:\n        # Display as a system message\n        try:\n            content = message.content.decode(\"utf-8\")\n            is_warning = \"different\" in content.lower() or \"mismatch\" in content.lower()\n            self._add_system_message(content, is_warning)\n\n            # If this is a crypto settings message, add more details\n            if (\"crypto\" in content.lower() or \"settings\" in content.lower() or \n                \"algorithm\" in content.lower() or \"key exchange\" in content.lower()):\n                if hasattr(message, 'key_exchange_algo') and message.key_exchange_algo:\n                    self._add_system_message(f\"Peer key exchange: {message.key_exchange_algo}\")\n                if hasattr(message, 'symmetric_algo') and message.symmetric_algo:\n                    self._add_system_message(f\"Peer symmetric encryption: {message.symmetric_algo}\")\n                if hasattr(message, 'signature_algo') and message.signature_algo:\n                    self._add_system_message(f\"Peer signature: {message.signature_algo}\")\n\n                # Update the crypto settings display\n                self._update_crypto_display()\n\n        except Exception as e:\n            logger.error(f\"Error displaying system message: {e}\")\n        return\n\n    # Regular message handling\n    self._add_message(message, is_outgoing=False)\n\n    # Update peer crypto settings from message metadata if available\n    if hasattr(message, 'key_exchange_algo') or hasattr(message, 'symmetric_algo') or hasattr(message, 'signature_algo'):\n        if self.current_peer not in self.secure_messaging.peer_crypto_settings:\n            self.secure_messaging.peer_crypto_settings[self.current_peer] = {}\n\n        if hasattr(message, 'key_exchange_algo') and message.key_exchange_algo:\n            self.secure_messaging.peer_crypto_settings[self.current_peer][\"key_exchange\"] = message.key_exchange_algo\n\n        if hasattr(message, 'symmetric_algo') and message.symmetric_algo:\n            self.secure_messaging.peer_crypto_settings[self.current_peer][\"symmetric\"] = message.symmetric_algo\n\n        if hasattr(message, 'signature_algo') and message.signature_algo:\n            self.secure_messaging.peer_crypto_settings[self.current_peer][\"signature\"] = message.signature_algo\n\n        # Update the display\n        self._update_crypto_display()\n</code></pre>"},{"location":"api/ui/#quantum_resistant_p2p.ui.SettingsDialog","title":"<code>SettingsDialog(secure_messaging, parent=None)</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>Dialog for configuring application settings.</p> <p>Initialize the settings dialog.</p> <p>Parameters:</p> Name Type Description Default <code>secure_messaging</code> <code>SecureMessaging</code> <p>The secure messaging service</p> required <code>parent</code> <p>The parent widget</p> <code>None</code> Source code in <code>quantum_resistant_p2p\\ui\\settings_dialog.py</code> <pre><code>def __init__(self, secure_messaging: SecureMessaging, parent=None):\n    \"\"\"Initialize the settings dialog.\n\n    Args:\n        secure_messaging: The secure messaging service\n        parent: The parent widget\n    \"\"\"\n    super().__init__(parent)\n\n    self.secure_messaging = secure_messaging\n\n    self.setWindowTitle(\"Cryptography Settings\")\n    self.setMinimumWidth(550)\n\n    self._init_ui()\n</code></pre>"},{"location":"api/ui/#quantum_resistant_p2p.ui.SettingsDialog-functions","title":"Functions","text":""},{"location":"api/ui/#quantum_resistant_p2p.ui.SecurityMetricsDialog","title":"<code>SecurityMetricsDialog(secure_messaging, secure_logger, parent=None)</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>Dialog for displaying security metrics.</p> <p>Initialize the security metrics dialog.</p> <p>Parameters:</p> Name Type Description Default <code>secure_messaging</code> <p>The secure messaging service</p> required <code>secure_logger</code> <p>The secure logger instance</p> required <code>parent</code> <p>The parent widget</p> <code>None</code> Source code in <code>quantum_resistant_p2p\\ui\\security_metrics_dialog.py</code> <pre><code>def __init__(self, secure_messaging, secure_logger, parent=None):\n    \"\"\"Initialize the security metrics dialog.\n\n    Args:\n        secure_messaging: The secure messaging service\n        secure_logger: The secure logger instance\n        parent: The parent widget\n    \"\"\"\n    super().__init__(parent)\n\n    self.secure_messaging = secure_messaging\n    self.secure_logger = secure_logger\n\n    self.setWindowTitle(\"Security Metrics\")\n    self.setMinimumSize(600, 450)\n\n    self._init_ui()\n</code></pre>"},{"location":"api/ui/#quantum_resistant_p2p.ui.SecurityMetricsDialog-functions","title":"Functions","text":""},{"location":"api/ui/#quantum_resistant_p2p.ui.LogViewerDialog","title":"<code>LogViewerDialog(secure_logger, parent=None)</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>Dialog for viewing secure logs.</p> <p>Initialize the log viewer dialog.</p> <p>Parameters:</p> Name Type Description Default <code>secure_logger</code> <p>The secure logger instance</p> required <code>parent</code> <p>The parent widget</p> <code>None</code> Source code in <code>quantum_resistant_p2p\\ui\\log_viewer_dialog.py</code> <pre><code>def __init__(self, secure_logger, parent=None):\n    \"\"\"Initialize the log viewer dialog.\n\n    Args:\n        secure_logger: The secure logger instance\n        parent: The parent widget\n    \"\"\"\n    super().__init__(parent)\n\n    self.secure_logger = secure_logger\n\n    self.setWindowTitle(\"Secure Logs\")\n    self.setMinimumSize(800, 600)\n\n    self._init_ui()\n</code></pre>"},{"location":"api/ui/#quantum_resistant_p2p.ui.LogViewerDialog-functions","title":"Functions","text":""},{"location":"api/ui/#quantum_resistant_p2p.ui.OQSStatusWidget","title":"<code>OQSStatusWidget(parent=None)</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>Widget to display OQS implementation status.</p> <p>Initialize the OQS status widget.</p> Source code in <code>quantum_resistant_p2p\\ui\\oqs_status_widget.py</code> <pre><code>def __init__(self, parent=None):\n    \"\"\"Initialize the OQS status widget.\"\"\"\n    super().__init__(parent)\n    self._init_ui()\n</code></pre>"},{"location":"api/ui/#quantum_resistant_p2p.ui.OQSStatusWidget-functions","title":"Functions","text":""},{"location":"api/ui/#quantum_resistant_p2p.ui.KeyHistoryDialog","title":"<code>KeyHistoryDialog(key_storage, secure_logger=None, parent=None)</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>Dialog for viewing the history of key exchanges with true on-demand key decryption.</p> <p>Initialize the key history dialog.</p> Source code in <code>quantum_resistant_p2p\\ui\\key_history_dialog.py</code> <pre><code>def __init__(self, key_storage: KeyStorage, secure_logger=None, parent=None):\n    \"\"\"Initialize the key history dialog.\"\"\"\n    super().__init__(parent)\n\n    self.key_storage = key_storage\n    self.secure_logger = secure_logger\n    self.current_key_id = None      # Store key_id instead of decrypted key\n    self.current_key = None         # Only set when explicitly decrypted\n    self.decrypted_key_cache = {}   # Cache of decrypted keys (key_id -&gt; decrypted_key)\n\n    self.setWindowTitle(\"Key Exchange History\")\n    self.setMinimumSize(900, 600)\n\n    self._init_ui()\n</code></pre>"},{"location":"api/ui/#quantum_resistant_p2p.ui.KeyHistoryDialog-functions","title":"Functions","text":"<code>closeEvent(event)</code> \u00b6 <p>Handle dialog close event.</p> Source code in <code>quantum_resistant_p2p\\ui\\key_history_dialog.py</code> <pre><code>def closeEvent(self, event):\n    \"\"\"Handle dialog close event.\"\"\"\n    # Clear any decrypted keys from memory for security\n    self.current_key = None\n    self.key_details.clear()\n    self.decrypted_key_cache.clear()  # Clear the decrypted key cache\n\n    # Accept the close event\n    super().closeEvent(event)\n</code></pre>"},{"location":"api/ui/#quantum_resistant_p2p.ui.ChangePasswordDialog","title":"<code>ChangePasswordDialog(key_storage, require_old_password=True, parent=None)</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>Dialog for changing the key storage password.</p> <p>Initialize the change password dialog.</p> <p>Parameters:</p> Name Type Description Default <code>key_storage</code> <code>KeyStorage</code> <p>The key storage to change password for</p> required <code>require_old_password</code> <code>bool</code> <p>Whether to require the old password (True for normal changes,                  False for when we know the user just entered it)</p> <code>True</code> <code>parent</code> <p>The parent widget</p> <code>None</code> Source code in <code>quantum_resistant_p2p\\ui\\change_password_dialog.py</code> <pre><code>def __init__(self, key_storage: KeyStorage, require_old_password: bool = True, parent=None):\n    \"\"\"Initialize the change password dialog.\n\n    Args:\n        key_storage: The key storage to change password for\n        require_old_password: Whether to require the old password (True for normal changes,\n                             False for when we know the user just entered it)\n        parent: The parent widget\n    \"\"\"\n    super().__init__(parent)\n\n    self.key_storage = key_storage\n    self.require_old_password = require_old_password\n\n    self.setWindowTitle(\"Change Password\")\n    self.setMinimumWidth(400)\n\n    self._init_ui()\n</code></pre>"},{"location":"api/ui/#quantum_resistant_p2p.ui.ChangePasswordDialog-functions","title":"Functions","text":""},{"location":"api/ui/#quantum_resistant_p2p.ui.ResetPasswordDialog","title":"<code>ResetPasswordDialog(key_storage, parent=None)</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>Dialog for resetting the key storage when the password is forgotten.</p> <p>Initialize the password reset dialog.</p> <p>Parameters:</p> Name Type Description Default <code>key_storage</code> <code>KeyStorage</code> <p>The key storage to reset</p> required <code>parent</code> <p>The parent widget</p> <code>None</code> Source code in <code>quantum_resistant_p2p\\ui\\reset_password_dialog.py</code> <pre><code>def __init__(self, key_storage: KeyStorage, parent=None):\n    \"\"\"Initialize the password reset dialog.\n\n    Args:\n        key_storage: The key storage to reset\n        parent: The parent widget\n    \"\"\"\n    super().__init__(parent)\n\n    self.key_storage = key_storage\n\n    self.setWindowTitle(\"Reset Password\")\n    self.setMinimumWidth(450)\n\n    self._init_ui()\n</code></pre>"},{"location":"api/ui/#quantum_resistant_p2p.ui.ResetPasswordDialog-functions","title":"Functions","text":""},{"location":"api/ui/change_password_dialog/","title":"Change Password Dialog Module","text":"<p>Dialog for changing the key storage password. This module provides the UI for password management.</p>"},{"location":"api/ui/change_password_dialog/#quantum_resistant_p2p.ui.change_password_dialog","title":"<code>quantum_resistant_p2p.ui.change_password_dialog</code>","text":"<p>Dialog for changing the key storage password.</p>"},{"location":"api/ui/change_password_dialog/#quantum_resistant_p2p.ui.change_password_dialog-classes","title":"Classes","text":""},{"location":"api/ui/change_password_dialog/#quantum_resistant_p2p.ui.change_password_dialog.ChangePasswordDialog","title":"<code>ChangePasswordDialog(key_storage, require_old_password=True, parent=None)</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>Dialog for changing the key storage password.</p> <p>Initialize the change password dialog.</p> <p>Parameters:</p> Name Type Description Default <code>key_storage</code> <code>KeyStorage</code> <p>The key storage to change password for</p> required <code>require_old_password</code> <code>bool</code> <p>Whether to require the old password (True for normal changes,                  False for when we know the user just entered it)</p> <code>True</code> <code>parent</code> <p>The parent widget</p> <code>None</code> Source code in <code>quantum_resistant_p2p\\ui\\change_password_dialog.py</code> <pre><code>def __init__(self, key_storage: KeyStorage, require_old_password: bool = True, parent=None):\n    \"\"\"Initialize the change password dialog.\n\n    Args:\n        key_storage: The key storage to change password for\n        require_old_password: Whether to require the old password (True for normal changes,\n                             False for when we know the user just entered it)\n        parent: The parent widget\n    \"\"\"\n    super().__init__(parent)\n\n    self.key_storage = key_storage\n    self.require_old_password = require_old_password\n\n    self.setWindowTitle(\"Change Password\")\n    self.setMinimumWidth(400)\n\n    self._init_ui()\n</code></pre>"},{"location":"api/ui/change_password_dialog/#quantum_resistant_p2p.ui.change_password_dialog.ChangePasswordDialog-functions","title":"Functions","text":""},{"location":"api/ui/key_history_dialog/","title":"Key History Dialog Module","text":"<p>Dialog for viewing key exchange history with true on-demand key decryption. This module provides the UI for viewing key exchange history.</p>"},{"location":"api/ui/key_history_dialog/#quantum_resistant_p2p.ui.key_history_dialog","title":"<code>quantum_resistant_p2p.ui.key_history_dialog</code>","text":"<p>Dialog for viewing key exchange history with true on-demand key decryption.</p>"},{"location":"api/ui/key_history_dialog/#quantum_resistant_p2p.ui.key_history_dialog-classes","title":"Classes","text":""},{"location":"api/ui/key_history_dialog/#quantum_resistant_p2p.ui.key_history_dialog.KeyHistoryDialog","title":"<code>KeyHistoryDialog(key_storage, secure_logger=None, parent=None)</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>Dialog for viewing the history of key exchanges with true on-demand key decryption.</p> <p>Initialize the key history dialog.</p> Source code in <code>quantum_resistant_p2p\\ui\\key_history_dialog.py</code> <pre><code>def __init__(self, key_storage: KeyStorage, secure_logger=None, parent=None):\n    \"\"\"Initialize the key history dialog.\"\"\"\n    super().__init__(parent)\n\n    self.key_storage = key_storage\n    self.secure_logger = secure_logger\n    self.current_key_id = None      # Store key_id instead of decrypted key\n    self.current_key = None         # Only set when explicitly decrypted\n    self.decrypted_key_cache = {}   # Cache of decrypted keys (key_id -&gt; decrypted_key)\n\n    self.setWindowTitle(\"Key Exchange History\")\n    self.setMinimumSize(900, 600)\n\n    self._init_ui()\n</code></pre>"},{"location":"api/ui/key_history_dialog/#quantum_resistant_p2p.ui.key_history_dialog.KeyHistoryDialog-functions","title":"Functions","text":"<code>closeEvent(event)</code> \u00b6 <p>Handle dialog close event.</p> Source code in <code>quantum_resistant_p2p\\ui\\key_history_dialog.py</code> <pre><code>def closeEvent(self, event):\n    \"\"\"Handle dialog close event.\"\"\"\n    # Clear any decrypted keys from memory for security\n    self.current_key = None\n    self.key_details.clear()\n    self.decrypted_key_cache.clear()  # Clear the decrypted key cache\n\n    # Accept the close event\n    super().closeEvent(event)\n</code></pre>"},{"location":"api/ui/log_viewer_dialog/","title":"Log Viewer Dialog Module","text":"<p>Dialog for viewing secure logs. This module provides the UI for viewing application logs.</p>"},{"location":"api/ui/log_viewer_dialog/#quantum_resistant_p2p.ui.log_viewer_dialog","title":"<code>quantum_resistant_p2p.ui.log_viewer_dialog</code>","text":"<p>Dialog for viewing secure logs.</p>"},{"location":"api/ui/log_viewer_dialog/#quantum_resistant_p2p.ui.log_viewer_dialog-classes","title":"Classes","text":""},{"location":"api/ui/log_viewer_dialog/#quantum_resistant_p2p.ui.log_viewer_dialog.LogViewerDialog","title":"<code>LogViewerDialog(secure_logger, parent=None)</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>Dialog for viewing secure logs.</p> <p>Initialize the log viewer dialog.</p> <p>Parameters:</p> Name Type Description Default <code>secure_logger</code> <p>The secure logger instance</p> required <code>parent</code> <p>The parent widget</p> <code>None</code> Source code in <code>quantum_resistant_p2p\\ui\\log_viewer_dialog.py</code> <pre><code>def __init__(self, secure_logger, parent=None):\n    \"\"\"Initialize the log viewer dialog.\n\n    Args:\n        secure_logger: The secure logger instance\n        parent: The parent widget\n    \"\"\"\n    super().__init__(parent)\n\n    self.secure_logger = secure_logger\n\n    self.setWindowTitle(\"Secure Logs\")\n    self.setMinimumSize(800, 600)\n\n    self._init_ui()\n</code></pre>"},{"location":"api/ui/log_viewer_dialog/#quantum_resistant_p2p.ui.log_viewer_dialog.LogViewerDialog-functions","title":"Functions","text":""},{"location":"api/ui/login_dialog/","title":"Login Dialog Module","text":"<p>Login dialog for unlocking key storage. This module provides the UI for authentication.</p>"},{"location":"api/ui/login_dialog/#quantum_resistant_p2p.ui.login_dialog","title":"<code>quantum_resistant_p2p.ui.login_dialog</code>","text":"<p>Login dialog for unlocking key storage.</p>"},{"location":"api/ui/login_dialog/#quantum_resistant_p2p.ui.login_dialog-classes","title":"Classes","text":""},{"location":"api/ui/login_dialog/#quantum_resistant_p2p.ui.login_dialog.LoginDialog","title":"<code>LoginDialog(key_storage, parent=None)</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>Dialog for unlocking the key storage with a password.</p> <p>Initialize the login dialog.</p> <p>Parameters:</p> Name Type Description Default <code>key_storage</code> <code>KeyStorage</code> <p>The key storage to unlock</p> required <code>parent</code> <p>The parent widget</p> <code>None</code> Source code in <code>quantum_resistant_p2p\\ui\\login_dialog.py</code> <pre><code>def __init__(self, key_storage: KeyStorage, parent=None):\n    \"\"\"Initialize the login dialog.\n\n    Args:\n        key_storage: The key storage to unlock\n        parent: The parent widget\n    \"\"\"\n    super().__init__(parent)\n\n    self.key_storage = key_storage\n\n    self.setWindowTitle(\"Unlock Key Storage\")\n    self.setMinimumWidth(350)\n\n    self._init_ui()\n</code></pre>"},{"location":"api/ui/login_dialog/#quantum_resistant_p2p.ui.login_dialog.LoginDialog-functions","title":"Functions","text":"<code>try_unlock()</code> \u00b6 <p>Try to unlock the key storage with the entered password.</p> Source code in <code>quantum_resistant_p2p\\ui\\login_dialog.py</code> <pre><code>def try_unlock(self):\n    \"\"\"Try to unlock the key storage with the entered password.\"\"\"\n    password = self.password_input.text()\n    confirm = self.confirm_input.text()\n\n    if not password:\n        QMessageBox.warning(self, \"Error\", \"Please enter a password.\")\n        return\n\n    # Check if passwords match\n    if self.confirm_input.isVisible() and password != confirm:\n        QMessageBox.warning(self, \"Error\", \"Passwords do not match.\")\n        return\n\n    # Try to unlock the key storage\n    success = self.key_storage.unlock(password)\n\n    if success:\n        logger.info(\"Key storage unlocked successfully\")\n        self.login_successful.emit()\n        self.accept()\n    else:\n        # Show error dialog with option to try again or reset password\n        reply = QMessageBox(QMessageBox.Warning, \"Login Failed\", \n                            \"Failed to unlock key storage. Incorrect password?\", \n                            QMessageBox.NoButton, self)\n\n        # Add custom buttons\n        try_again_button = reply.addButton(\"Try Again\", QMessageBox.AcceptRole)\n        reset_button = reply.addButton(\"Reset Password\", QMessageBox.ActionRole)\n        cancel_button = reply.addButton(\"Cancel\", QMessageBox.RejectRole)\n\n        reply.exec_()\n\n        clicked_button = reply.clickedButton()\n\n        if clicked_button == try_again_button:\n            # Clear input and set focus for another attempt\n            self.password_input.clear()\n            self.confirm_input.clear()\n            self.password_input.setFocus()\n        elif clicked_button == reset_button:\n            # Show the reset password dialog\n            self._show_reset_password_dialog()\n        else:  # Cancel button\n            # Reject the dialog to close the application\n            self.reject()\n</code></pre>"},{"location":"api/ui/main_window/","title":"Main Window Module","text":"<p>Main window for the post-quantum P2P application. This module implements the main application window and coordinates other UI components.</p>"},{"location":"api/ui/main_window/#quantum_resistant_p2p.ui.main_window","title":"<code>quantum_resistant_p2p.ui.main_window</code>","text":"<p>Main window for the post-quantum P2P application.</p>"},{"location":"api/ui/main_window/#quantum_resistant_p2p.ui.main_window-classes","title":"Classes","text":""},{"location":"api/ui/main_window/#quantum_resistant_p2p.ui.main_window.MainWindow","title":"<code>MainWindow()</code>","text":"<p>               Bases: <code>QMainWindow</code></p> <p>Main window for the application.</p> <p>Initialize the main window.</p> Source code in <code>quantum_resistant_p2p\\ui\\main_window.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the main window.\"\"\"\n    super().__init__()\n\n    # Initialize components\n    self.key_storage = KeyStorage()\n    # Secure logger will be initialized after login when we have the master key\n    self.secure_logger = None\n\n    # Network components will be initialized after login\n    self.node = None\n    self.node_discovery = None\n    self.secure_messaging = None\n\n    # Track if message handler has been registered to prevent duplicates\n    self._message_handler_registered = False\n\n    # UI initialization\n    self.setWindowTitle(\"Quantum Resistant P2P\")\n    self.setMinimumSize(800, 600)\n\n    self.central_widget = QWidget()\n    self.setCentralWidget(self.central_widget)\n\n    layout = QVBoxLayout(self.central_widget)\n    layout.addWidget(QLabel(\"Logging in...\"))\n\n    # Connect async signal\n    self.async_task.connect(self._run_async_task)\n\n    # Show login dialog first\n    QTimer.singleShot(100, self._show_login_dialog)\n</code></pre>"},{"location":"api/ui/main_window/#quantum_resistant_p2p.ui.main_window.MainWindow-functions","title":"Functions","text":"<code>closeEvent(event)</code> \u00b6 <p>Handle the window close event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <p>The close event</p> required Source code in <code>quantum_resistant_p2p\\ui\\main_window.py</code> <pre><code>def closeEvent(self, event):\n    \"\"\"Handle the window close event.\n\n    Args:\n        event: The close event\n    \"\"\"\n    # If we have a messaging widget, make sure to clean it up\n    if hasattr(self, 'messaging') and self.messaging:\n        # This will trigger the destroyed signal and _cleanup_resources\n        self.messaging.deleteLater()\n\n    # Stop the network components asynchronously\n    asyncio.create_task(self._async_stop_network())\n    event.accept()\n</code></pre>"},{"location":"api/ui/messaging_widget/","title":"Messaging Widget Module","text":"<p>Widget for messaging functionality with file saving capabilities. This module provides the UI component for sending and receiving messages.</p>"},{"location":"api/ui/messaging_widget/#quantum_resistant_p2p.ui.messaging_widget","title":"<code>quantum_resistant_p2p.ui.messaging_widget</code>","text":"<p>Widget for messaging functionality with file saving capabilities.</p>"},{"location":"api/ui/messaging_widget/#quantum_resistant_p2p.ui.messaging_widget-classes","title":"Classes","text":""},{"location":"api/ui/messaging_widget/#quantum_resistant_p2p.ui.messaging_widget.MessagingWidget","title":"<code>MessagingWidget(secure_messaging, message_store=None, parent=None)</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>Widget for securely messaging with peers.</p> <p>Initialize the messaging widget.</p> <p>Parameters:</p> Name Type Description Default <code>secure_messaging</code> <code>SecureMessaging</code> <p>The secure messaging service</p> required <code>message_store</code> <p>The message store for persistent messages (optional)</p> <code>None</code> <code>parent</code> <p>The parent widget</p> <code>None</code> Source code in <code>quantum_resistant_p2p\\ui\\messaging_widget.py</code> <pre><code>def __init__(self, secure_messaging: SecureMessaging, message_store=None, parent=None):\n    \"\"\"Initialize the messaging widget.\n\n    Args:\n        secure_messaging: The secure messaging service\n        message_store: The message store for persistent messages (optional)\n        parent: The parent widget\n    \"\"\"\n    super().__init__(parent)\n\n    self.secure_messaging = secure_messaging\n    self.message_store = message_store\n    self.current_peer = None\n    self.is_connecting = False\n\n    self._init_ui()\n\n    # Connect async signal\n    self.async_task.connect(self._run_async_task)\n\n    # Register for crypto settings changes\n    self.secure_messaging.register_settings_change_listener(self._on_crypto_settings_changed)\n\n    # Add connection status checker timer\n    self.connection_checker = QTimer(self)\n    self.connection_checker.timeout.connect(self._check_connection_status)\n    self.connection_checker.start(2000)  # Check every 2 seconds\n\n    # Connect to the destroyed signal to clean up resources\n    self.destroyed.connect(self._cleanup_resources)\n</code></pre>"},{"location":"api/ui/messaging_widget/#quantum_resistant_p2p.ui.messaging_widget.MessagingWidget-functions","title":"Functions","text":"<code>set_current_peer(peer_id)</code> \u00b6 <p>Set the current peer for messaging.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <code>str</code> <p>The ID of the peer</p> required Source code in <code>quantum_resistant_p2p\\ui\\messaging_widget.py</code> <pre><code>def set_current_peer(self, peer_id: str):\n    \"\"\"Set the current peer for messaging.\n\n    Args:\n        peer_id: The ID of the peer\n    \"\"\"\n    # Clear previous notification flag\n    if hasattr(self, '_mismatch_notified'):\n        delattr(self, '_mismatch_notified')\n\n    self.current_peer = peer_id\n    self.peer_label.setText(f\"Chatting with: {peer_id[:8]}...\")\n\n    # Enable settings and refresh buttons when peer is selected\n    self.settings_button.setEnabled(True)\n    self.refresh_button.setEnabled(True)\n\n    # Clear the chat area and file message map\n    self.chat_area.clear()\n    self.file_messages.clear()\n\n    # Add a system message\n    self._add_system_message(f\"Started chat with {peer_id[:8]}...\")\n\n    # Check connection status\n    connected_peers = self.secure_messaging.node.get_peers()\n    is_connected = peer_id in connected_peers\n\n    # Initialize previous connection state\n    self.previous_connection_state = is_connected\n\n    if is_connected:\n        self._add_system_message(\"Connected to peer\")\n        has_shared_key = peer_id in self.secure_messaging.shared_keys\n        key_exchange_state = self.secure_messaging.key_exchange_states.get(peer_id, 0)\n\n        if has_shared_key and key_exchange_state == 4:  # KeyExchangeState.ESTABLISHED\n            self._add_system_message(\"Secure connection established\")\n            self._enable_messaging()\n        else:\n            self._add_system_message(\"No secure connection established. Use 'Establish Shared Key' button to create a secure channel.\", True)\n            self._disable_messaging()\n\n            # Request crypto settings to prepare for key exchange\n            self.async_task.emit(\n                self.secure_messaging.request_crypto_settings_from_peer(peer_id)\n            )\n\n        # Make crypto panel visible immediately with \"requesting\" status\n        self.crypto_panel.setVisible(True)\n\n        # Request crypto settings from the peer\n        self.async_task.emit(\n            self.secure_messaging.request_crypto_settings_from_peer(peer_id)\n        )\n    else:\n        self._add_system_message(\"Not connected to peer. Attempting to autoconnect...\", True)\n        self._disable_messaging()\n\n    # Load previous messages if we have a message store\n    if self.message_store:\n        messages = self.message_store.get_messages(peer_id)\n        if messages:\n            self._add_system_message(f\"Loading {len(messages)} previous messages...\")\n\n            for message in messages:\n                # Determine if this message is from us or the peer\n                is_outgoing = message.sender_id == self.secure_messaging.node.node_id\n                self._add_message(message, is_outgoing)\n\n    # Update the crypto settings display\n    self._update_crypto_display()\n\n    logger.info(f\"Set current peer to {peer_id}\")\n</code></pre> <code>initiate_connection(peer_id, host, port)</code> \u00b6 <p>Initiate connection to a peer.</p> <p>Parameters:</p> Name Type Description Default <code>peer_id</code> <code>str</code> <p>The ID of the peer</p> required <code>host</code> <code>str</code> <p>The host address of the peer</p> required <code>port</code> <code>int</code> <p>The port number of the peer</p> required Source code in <code>quantum_resistant_p2p\\ui\\messaging_widget.py</code> <pre><code>def initiate_connection(self, peer_id: str, host: str, port: int):\n    \"\"\"Initiate connection to a peer.\n\n    Args:\n        peer_id: The ID of the peer\n        host: The host address of the peer\n        port: The port number of the peer\n    \"\"\"\n    # Check if this is the currently selected peer\n    if peer_id != self.current_peer:\n        return\n\n    # Check if already connecting\n    if self.is_connecting:\n        return\n\n    self.is_connecting = True\n\n    self._add_system_message(f\"Connecting to {host}:{port}...\")\n\n    # Start connection task\n    self.async_task.emit(self._connect_to_peer(host, port))\n</code></pre> <code>handle_message(message)</code> \u00b6 <p>Handle a received message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>The received message</p> required Source code in <code>quantum_resistant_p2p\\ui\\messaging_widget.py</code> <pre><code>def handle_message(self, message: Message):\n    \"\"\"Handle a received message.\n\n    Args:\n        message: The received message\n    \"\"\"\n    logger.debug(f\"MessagingWidget displaying message {message.message_id} from {message.sender_id}\")\n\n    # Special handling for system messages\n    if message.is_system:\n        # Display as a system message\n        try:\n            content = message.content.decode(\"utf-8\")\n            is_warning = \"different\" in content.lower() or \"mismatch\" in content.lower()\n            self._add_system_message(content, is_warning)\n\n            # If this is a crypto settings message, add more details\n            if (\"crypto\" in content.lower() or \"settings\" in content.lower() or \n                \"algorithm\" in content.lower() or \"key exchange\" in content.lower()):\n                if hasattr(message, 'key_exchange_algo') and message.key_exchange_algo:\n                    self._add_system_message(f\"Peer key exchange: {message.key_exchange_algo}\")\n                if hasattr(message, 'symmetric_algo') and message.symmetric_algo:\n                    self._add_system_message(f\"Peer symmetric encryption: {message.symmetric_algo}\")\n                if hasattr(message, 'signature_algo') and message.signature_algo:\n                    self._add_system_message(f\"Peer signature: {message.signature_algo}\")\n\n                # Update the crypto settings display\n                self._update_crypto_display()\n\n        except Exception as e:\n            logger.error(f\"Error displaying system message: {e}\")\n        return\n\n    # Regular message handling\n    self._add_message(message, is_outgoing=False)\n\n    # Update peer crypto settings from message metadata if available\n    if hasattr(message, 'key_exchange_algo') or hasattr(message, 'symmetric_algo') or hasattr(message, 'signature_algo'):\n        if self.current_peer not in self.secure_messaging.peer_crypto_settings:\n            self.secure_messaging.peer_crypto_settings[self.current_peer] = {}\n\n        if hasattr(message, 'key_exchange_algo') and message.key_exchange_algo:\n            self.secure_messaging.peer_crypto_settings[self.current_peer][\"key_exchange\"] = message.key_exchange_algo\n\n        if hasattr(message, 'symmetric_algo') and message.symmetric_algo:\n            self.secure_messaging.peer_crypto_settings[self.current_peer][\"symmetric\"] = message.symmetric_algo\n\n        if hasattr(message, 'signature_algo') and message.signature_algo:\n            self.secure_messaging.peer_crypto_settings[self.current_peer][\"signature\"] = message.signature_algo\n\n        # Update the display\n        self._update_crypto_display()\n</code></pre>"},{"location":"api/ui/oqs_status_widget/","title":"OQS Status Widget Module","text":"<p>Widget to display OQS implementation status. This module provides a UI component for displaying Open Quantum Safe status.</p>"},{"location":"api/ui/oqs_status_widget/#quantum_resistant_p2p.ui.oqs_status_widget","title":"<code>quantum_resistant_p2p.ui.oqs_status_widget</code>","text":"<p>Widget to display OQS implementation status.</p>"},{"location":"api/ui/oqs_status_widget/#quantum_resistant_p2p.ui.oqs_status_widget-classes","title":"Classes","text":""},{"location":"api/ui/oqs_status_widget/#quantum_resistant_p2p.ui.oqs_status_widget.OQSStatusWidget","title":"<code>OQSStatusWidget(parent=None)</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>Widget to display OQS implementation status.</p> <p>Initialize the OQS status widget.</p> Source code in <code>quantum_resistant_p2p\\ui\\oqs_status_widget.py</code> <pre><code>def __init__(self, parent=None):\n    \"\"\"Initialize the OQS status widget.\"\"\"\n    super().__init__(parent)\n    self._init_ui()\n</code></pre>"},{"location":"api/ui/oqs_status_widget/#quantum_resistant_p2p.ui.oqs_status_widget.OQSStatusWidget-functions","title":"Functions","text":""},{"location":"api/ui/peer_list/","title":"Peer List Module","text":"<p>Widget for displaying and managing the list of peers. This module provides the UI component for displaying available peers.</p>"},{"location":"api/ui/peer_list/#quantum_resistant_p2p.ui.peer_list","title":"<code>quantum_resistant_p2p.ui.peer_list</code>","text":"<p>Widget for displaying and managing the list of peers.</p>"},{"location":"api/ui/peer_list/#quantum_resistant_p2p.ui.peer_list-classes","title":"Classes","text":""},{"location":"api/ui/peer_list/#quantum_resistant_p2p.ui.peer_list.PeerListWidget","title":"<code>PeerListWidget(node, discovery, secure_messaging=None, message_store=None, parent=None)</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>Widget for displaying and interacting with the list of peers.</p> <p>Initialize the peer list widget.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>P2PNode</code> <p>The P2P node</p> required <code>discovery</code> <code>NodeDiscovery</code> <p>The node discovery service</p> required <code>secure_messaging</code> <p>The secure messaging service (optional)</p> <code>None</code> <code>message_store</code> <p>The message store for persistent messages (optional)</p> <code>None</code> <code>parent</code> <p>The parent widget</p> <code>None</code> Source code in <code>quantum_resistant_p2p\\ui\\peer_list.py</code> <pre><code>def __init__(self, node: P2PNode, discovery: NodeDiscovery, secure_messaging=None, message_store=None, parent=None):\n    \"\"\"Initialize the peer list widget.\n\n    Args:\n        node: The P2P node\n        discovery: The node discovery service\n        secure_messaging: The secure messaging service (optional)\n        message_store: The message store for persistent messages (optional)\n        parent: The parent widget\n    \"\"\"\n    super().__init__(parent)\n\n    self.node = node\n    self.discovery = discovery\n    self.secure_messaging = secure_messaging\n    self.message_store = message_store\n\n    # Keep track of the currently selected peer\n    self.current_peer_id = None\n\n    self._init_ui()\n\n    # If we have secure messaging, register for crypto changes\n    if self.secure_messaging:\n        self.secure_messaging.register_settings_change_listener(self._refresh_crypto_indicators)\n</code></pre>"},{"location":"api/ui/peer_list/#quantum_resistant_p2p.ui.peer_list.PeerListWidget-functions","title":"Functions","text":"<code>update_peers(discovered, connected)</code> \u00b6 <p>Update the list of peers while preserving selection.</p> <p>Parameters:</p> Name Type Description Default <code>discovered</code> <code>list</code> <p>List of discovered peers (node_id, host, port)</p> required <code>connected</code> <code>list</code> <p>List of connected peer IDs</p> required Source code in <code>quantum_resistant_p2p\\ui\\peer_list.py</code> <pre><code>def update_peers(self, discovered: list, connected: list):\n    \"\"\"Update the list of peers while preserving selection.\n\n    Args:\n        discovered: List of discovered peers (node_id, host, port)\n        connected: List of connected peer IDs\n    \"\"\"\n    # Remember the currently selected peer ID\n    selected_rows = self.peer_table.selectedItems()\n    if selected_rows and selected_rows[0].column() == 0:  # Make sure we get a peer ID column\n        selected_peer_id = selected_rows[0].data(Qt.UserRole)\n    else:\n        selected_peer_id = self.current_peer_id\n\n    # Remember scroll position\n    scrollbar_pos = self.peer_table.verticalScrollBar().value()\n\n    # Clear and rebuild the table\n    self.peer_table.setRowCount(0)  # Clear all rows\n    self.peer_table.setSortingEnabled(False)  # Disable sorting while updating\n\n    # Rebuild the table\n    row = 0\n    for node_id, host, port in discovered:\n        self.peer_table.insertRow(row)\n\n        # Determine state\n        is_connected = node_id in connected\n        has_shared_key = False\n        is_secure = False\n\n        if self.secure_messaging:\n            has_shared_key = node_id in self.secure_messaging.shared_keys\n            key_exchange_state = self.secure_messaging.key_exchange_states.get(node_id, 0)\n            is_secure = has_shared_key and key_exchange_state == 4  # ESTABLISHED\n\n        # ID column (short peer ID + address)\n        id_item = QTableWidgetItem(f\"{node_id[:8]}...\")\n        id_item.setData(Qt.UserRole, node_id)  # Store full ID\n        id_item.setData(Qt.UserRole + 1, host)  # Store host\n        id_item.setData(Qt.UserRole + 2, port)  # Store port\n\n        # Set tooltip with full information\n        tooltip = f\"ID: {node_id}\\nHost: {host}\\nPort: {port}\"\n        if self.secure_messaging and node_id in self.secure_messaging.peer_crypto_settings:\n            peer_settings = self.secure_messaging.peer_crypto_settings[node_id]\n            key_exchange = peer_settings.get(\"key_exchange\", \"Unknown\")\n            symmetric = peer_settings.get(\"symmetric\", \"Unknown\")\n            signature = peer_settings.get(\"signature\", \"Unknown\")\n            tooltip += f\"\\n\\nCrypto Settings:\\nKey Exchange: {key_exchange}\\nSymmetric: {symmetric}\\nSignature: {signature}\"\n        id_item.setToolTip(tooltip)\n\n        # Status column\n        status_item = QTableWidgetItem()\n\n        # Set text based on state\n        if is_connected:\n            if is_secure:\n                status_text = \"Secure\"\n            else:\n                if has_shared_key:\n                    status_text = \"Connected, Key Issue\"\n                else:\n                    status_text = \"Connected\"\n\n            # Add crypto compatibility indicator\n            if self.secure_messaging and node_id in self.secure_messaging.peer_crypto_settings:\n                peer_settings = self.secure_messaging.peer_crypto_settings[node_id]\n                my_settings = {\n                    \"key_exchange\": self.secure_messaging.key_exchange.name,\n                    \"symmetric\": self.secure_messaging.symmetric.name,\n                    \"signature\": self.secure_messaging.signature.name\n                }\n\n                # Check for mismatches\n                has_mismatches = any(\n                    peer_settings.get(key, \"\") != my_settings[key]\n                    for key in my_settings\n                    if key in peer_settings\n                )\n\n                if has_mismatches:\n                    status_text += \" \u26a0\ufe0f\"\n\n        else:\n            status_text = \"Discovered\"\n\n        status_item.setText(status_text)\n\n        # Add to table\n        self.peer_table.setItem(row, 0, id_item)\n        self.peer_table.setItem(row, 1, status_item)\n\n        # Apply color based on state\n        background_color = Qt.white  # Default white\n        text_color = Qt.black  # Default black\n\n        if is_connected:\n            if is_secure:\n                background_color = QColor(230, 255, 230)  # Light green\n            else:\n                background_color = QColor(240, 240, 255)  # Light blue\n\n        # Apply colors to both columns\n        id_item.setBackground(background_color)\n        status_item.setBackground(background_color)\n        id_item.setForeground(text_color)\n        status_item.setForeground(text_color)\n\n        # Separately handle unread messages\n        if self.message_store and self.message_store.has_unread_messages(node_id):\n            unread_count = self.message_store.get_unread_count(node_id)\n\n            # Make text bold for unread messages\n            font = id_item.font()\n            font.setBold(True)\n            id_item.setFont(font)\n            status_item.setFont(font)\n\n            # Update status text to include unread count\n            status_item.setText(f\"{status_text} ({unread_count} unread)\")\n\n        row += 1\n\n    # Restore selection if possible\n    if selected_peer_id:\n        for r in range(self.peer_table.rowCount()):\n            item = self.peer_table.item(r, 0)  # ID column\n            if item and item.data(Qt.UserRole) == selected_peer_id:\n                self.peer_table.selectRow(r)\n                break\n\n    # Restore scroll position\n    self.peer_table.verticalScrollBar().setValue(scrollbar_pos)\n\n    # Re-enable sorting\n    self.peer_table.setSortingEnabled(True)\n\n    logger.debug(f\"Updated peer table with {len(discovered)} peers\")\n</code></pre>"},{"location":"api/ui/reset_password_dialog/","title":"Reset Password Dialog Module","text":"<p>Dialog for resetting the key storage password when it's forgotten. This module provides the UI for password recovery.</p>"},{"location":"api/ui/reset_password_dialog/#quantum_resistant_p2p.ui.reset_password_dialog","title":"<code>quantum_resistant_p2p.ui.reset_password_dialog</code>","text":"<p>Dialog for resetting the key storage password when it's forgotten.</p>"},{"location":"api/ui/reset_password_dialog/#quantum_resistant_p2p.ui.reset_password_dialog-classes","title":"Classes","text":""},{"location":"api/ui/reset_password_dialog/#quantum_resistant_p2p.ui.reset_password_dialog.ResetPasswordDialog","title":"<code>ResetPasswordDialog(key_storage, parent=None)</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>Dialog for resetting the key storage when the password is forgotten.</p> <p>Initialize the password reset dialog.</p> <p>Parameters:</p> Name Type Description Default <code>key_storage</code> <code>KeyStorage</code> <p>The key storage to reset</p> required <code>parent</code> <p>The parent widget</p> <code>None</code> Source code in <code>quantum_resistant_p2p\\ui\\reset_password_dialog.py</code> <pre><code>def __init__(self, key_storage: KeyStorage, parent=None):\n    \"\"\"Initialize the password reset dialog.\n\n    Args:\n        key_storage: The key storage to reset\n        parent: The parent widget\n    \"\"\"\n    super().__init__(parent)\n\n    self.key_storage = key_storage\n\n    self.setWindowTitle(\"Reset Password\")\n    self.setMinimumWidth(450)\n\n    self._init_ui()\n</code></pre>"},{"location":"api/ui/reset_password_dialog/#quantum_resistant_p2p.ui.reset_password_dialog.ResetPasswordDialog-functions","title":"Functions","text":""},{"location":"api/ui/security_metrics_dialog/","title":"Security Metrics Dialog Module","text":"<p>Dialog for displaying security metrics. This module provides the UI for viewing security-related statistics.</p>"},{"location":"api/ui/security_metrics_dialog/#quantum_resistant_p2p.ui.security_metrics_dialog","title":"<code>quantum_resistant_p2p.ui.security_metrics_dialog</code>","text":"<p>Dialog for displaying security metrics.</p>"},{"location":"api/ui/security_metrics_dialog/#quantum_resistant_p2p.ui.security_metrics_dialog-classes","title":"Classes","text":""},{"location":"api/ui/security_metrics_dialog/#quantum_resistant_p2p.ui.security_metrics_dialog.SecurityMetricsDialog","title":"<code>SecurityMetricsDialog(secure_messaging, secure_logger, parent=None)</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>Dialog for displaying security metrics.</p> <p>Initialize the security metrics dialog.</p> <p>Parameters:</p> Name Type Description Default <code>secure_messaging</code> <p>The secure messaging service</p> required <code>secure_logger</code> <p>The secure logger instance</p> required <code>parent</code> <p>The parent widget</p> <code>None</code> Source code in <code>quantum_resistant_p2p\\ui\\security_metrics_dialog.py</code> <pre><code>def __init__(self, secure_messaging, secure_logger, parent=None):\n    \"\"\"Initialize the security metrics dialog.\n\n    Args:\n        secure_messaging: The secure messaging service\n        secure_logger: The secure logger instance\n        parent: The parent widget\n    \"\"\"\n    super().__init__(parent)\n\n    self.secure_messaging = secure_messaging\n    self.secure_logger = secure_logger\n\n    self.setWindowTitle(\"Security Metrics\")\n    self.setMinimumSize(600, 450)\n\n    self._init_ui()\n</code></pre>"},{"location":"api/ui/security_metrics_dialog/#quantum_resistant_p2p.ui.security_metrics_dialog.SecurityMetricsDialog-functions","title":"Functions","text":""},{"location":"api/ui/settings_dialog/","title":"Settings Dialog Module","text":"<p>Dialog for application and cryptography settings. This module provides the UI for configuring application settings.</p>"},{"location":"api/ui/settings_dialog/#quantum_resistant_p2p.ui.settings_dialog","title":"<code>quantum_resistant_p2p.ui.settings_dialog</code>","text":"<p>Dialog for application and cryptography settings.</p>"},{"location":"api/ui/settings_dialog/#quantum_resistant_p2p.ui.settings_dialog-classes","title":"Classes","text":""},{"location":"api/ui/settings_dialog/#quantum_resistant_p2p.ui.settings_dialog.SettingsDialog","title":"<code>SettingsDialog(secure_messaging, parent=None)</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>Dialog for configuring application settings.</p> <p>Initialize the settings dialog.</p> <p>Parameters:</p> Name Type Description Default <code>secure_messaging</code> <code>SecureMessaging</code> <p>The secure messaging service</p> required <code>parent</code> <p>The parent widget</p> <code>None</code> Source code in <code>quantum_resistant_p2p\\ui\\settings_dialog.py</code> <pre><code>def __init__(self, secure_messaging: SecureMessaging, parent=None):\n    \"\"\"Initialize the settings dialog.\n\n    Args:\n        secure_messaging: The secure messaging service\n        parent: The parent widget\n    \"\"\"\n    super().__init__(parent)\n\n    self.secure_messaging = secure_messaging\n\n    self.setWindowTitle(\"Cryptography Settings\")\n    self.setMinimumWidth(550)\n\n    self._init_ui()\n</code></pre>"},{"location":"api/ui/settings_dialog/#quantum_resistant_p2p.ui.settings_dialog.SettingsDialog-functions","title":"Functions","text":""},{"location":"api/utils/","title":"Utils Package","text":"<p>Utility functions for the post-quantum P2P application. This package provides utility functions used by other components.</p>"},{"location":"api/utils/#quantum_resistant_p2p.utils","title":"<code>quantum_resistant_p2p.utils</code>","text":"<p>Utility functions for the post-quantum P2P application.</p>"},{"location":"api/utils/#quantum_resistant_p2p.utils-classes","title":"Classes","text":""},{"location":"api/utils/#quantum_resistant_p2p.utils.SecureFile","title":"<code>SecureFile(file_path)</code>","text":"<p>A secure file handler with protection against corruption and concurrent access.</p> <p>Initialize a secure file handler.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Union[str, Path]</code> <p>The path to the file</p> required Source code in <code>quantum_resistant_p2p\\utils\\secure_file.py</code> <pre><code>def __init__(self, file_path: Union[str, Path]):\n    \"\"\"Initialize a secure file handler.\n\n    Args:\n        file_path: The path to the file\n    \"\"\"\n    self.file_path = Path(file_path)\n    self.lock_path = self.file_path.with_suffix(self.file_path.suffix + '.lock')\n    self.backup_path = self.file_path.with_suffix(self.file_path.suffix + '.bak')\n</code></pre>"},{"location":"api/utils/#quantum_resistant_p2p.utils.SecureFile-functions","title":"Functions","text":"<code>read_json()</code> \u00b6 <p>Read and parse a JSON file safely.</p> <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>The parsed JSON data, or None if the file doesn't exist or is invalid</p> Source code in <code>quantum_resistant_p2p\\utils\\secure_file.py</code> <pre><code>def read_json(self) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Read and parse a JSON file safely.\n\n    Returns:\n        The parsed JSON data, or None if the file doesn't exist or is invalid\n    \"\"\"\n    # First try the primary file\n    data = self._read_json_file(self.file_path)\n\n    # If primary file is corrupted but backup exists, use the backup\n    if data is None and self.backup_path.exists():\n        logger.warning(f\"Using backup file for {self.file_path}\")\n        data = self._read_json_file(self.backup_path)\n\n        # If backup is valid, restore it to the main file\n        if data is not None:\n            self.write_json(data)\n\n    return data\n</code></pre> <code>write_json(data)</code> \u00b6 <p>Write data to a JSON file safely with atomic updates and backups.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>The data to write</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the write was successful, False otherwise</p> Source code in <code>quantum_resistant_p2p\\utils\\secure_file.py</code> <pre><code>def write_json(self, data: Dict[str, Any]) -&gt; bool:\n    \"\"\"Write data to a JSON file safely with atomic updates and backups.\n\n    Args:\n        data: The data to write\n\n    Returns:\n        True if the write was successful, False otherwise\n    \"\"\"\n    # Try to acquire the process lock\n    if not self._acquire_process_lock():\n        logger.error(f\"Could not acquire lock for {self.file_path}\")\n        return False\n\n    try:\n        # Create parent directory if it doesn't exist\n        self.file_path.parent.mkdir(parents=True, exist_ok=True)\n\n        # Make a backup of the existing file if it exists\n        if self.file_path.exists():\n            try:\n                shutil.copy2(self.file_path, self.backup_path)\n            except Exception as e:\n                logger.warning(f\"Failed to create backup: {e}\")\n\n        # Write to a temporary file first\n        with tempfile.NamedTemporaryFile(\n            mode='w', delete=False, dir=self.file_path.parent\n        ) as temp_file:\n            # Write the JSON data\n            json.dump(data, temp_file, indent=2)\n            temp_file.flush()\n            os.fsync(temp_file.fileno())  # Ensure data is written to disk\n            temp_path = temp_file.name\n\n        # Now atomically move the temp file to the target\n        shutil.move(temp_path, self.file_path)\n\n        return True\n    except Exception as e:\n        logger.error(f\"Error writing to {self.file_path}: {e}\")\n        return False\n    finally:\n        # Always release the process lock\n        self._release_process_lock()\n</code></pre> <code>append_bytes(data)</code> \u00b6 <p>Append binary data to a file with locking.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The binary data to append</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the append was successful, False otherwise</p> Source code in <code>quantum_resistant_p2p\\utils\\secure_file.py</code> <pre><code>def append_bytes(self, data: bytes) -&gt; bool:\n    \"\"\"Append binary data to a file with locking.\n\n    Args:\n        data: The binary data to append\n\n    Returns:\n        True if the append was successful, False otherwise\n    \"\"\"\n    try:\n        # Create parent directory if it doesn't exist\n        self.file_path.parent.mkdir(parents=True, exist_ok=True)\n\n        with open(self.file_path, 'ab') as f:\n            # Try to get an exclusive lock for writing\n            lock_acquired = _lock_file(f, exclusive=True)\n            try:\n                # Write the data\n                f.write(data)\n                f.flush()\n                return True\n            finally:\n                if lock_acquired:\n                    _unlock_file(f)\n\n        return True\n    except Exception as e:\n        logger.error(f\"Error appending to {self.file_path}: {e}\")\n        return False\n</code></pre> <code>read_bytes()</code> \u00b6 <p>Read binary data from a file with locking.</p> <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>The file contents as bytes, or None if the file doesn't exist or can't be read</p> Source code in <code>quantum_resistant_p2p\\utils\\secure_file.py</code> <pre><code>def read_bytes(self) -&gt; Optional[bytes]:\n    \"\"\"Read binary data from a file with locking.\n\n    Returns:\n        The file contents as bytes, or None if the file doesn't exist or can't be read\n    \"\"\"\n    if not self.file_path.exists():\n        return None\n\n    try:\n        with open(self.file_path, 'rb') as f:\n            # Try to get a shared lock for reading\n            lock_acquired = _lock_file(f, exclusive=False)\n            try:\n                # Read the file\n                return f.read()\n            finally:\n                if lock_acquired:\n                    _unlock_file(f)\n    except Exception as e:\n        logger.error(f\"Error reading {self.file_path}: {e}\")\n        return None\n</code></pre> <code>with_file_lock(callback, exclusive=True)</code> \u00b6 <p>Execute a callback with a file lock.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[BinaryIO], T]</code> <p>The function to call with the file handle</p> required <code>exclusive</code> <code>bool</code> <p>Whether to use exclusive (write) or shared (read) locking</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>The return value of the callback, or None if an error occurred</p> Source code in <code>quantum_resistant_p2p\\utils\\secure_file.py</code> <pre><code>def with_file_lock(self, callback: Callable[[BinaryIO], T], exclusive: bool = True) -&gt; Optional[T]:\n    \"\"\"Execute a callback with a file lock.\n\n    Args:\n        callback: The function to call with the file handle\n        exclusive: Whether to use exclusive (write) or shared (read) locking\n\n    Returns:\n        The return value of the callback, or None if an error occurred\n    \"\"\"\n    mode = 'ab' if exclusive else 'rb'\n\n    try:\n        # Create parent directory if it doesn't exist and we're writing\n        if exclusive:\n            self.file_path.parent.mkdir(parents=True, exist_ok=True)\n\n        with open(self.file_path, mode) as f:\n            # Try to get a lock\n            lock_acquired = _lock_file(f, exclusive=exclusive)\n            try:\n                # Call the callback with the file handle\n                return callback(f)\n            finally:\n                if lock_acquired:\n                    _unlock_file(f)\n    except Exception as e:\n        logger.error(f\"Error with file lock on {self.file_path}: {e}\")\n        return None\n</code></pre>"},{"location":"api/utils/secure_file/","title":"Secure File Module","text":"<p>Secure file operations with corruption protection. This module provides utilities for securely reading and writing files with protection against corruption, concurrent access issues, and proper cleanup.</p>"},{"location":"api/utils/secure_file/#quantum_resistant_p2p.utils.secure_file","title":"<code>quantum_resistant_p2p.utils.secure_file</code>","text":"<p>Secure file operations with corruption protection.</p> <p>This module provides utilities for securely reading and writing files with protection against corruption, concurrent access issues, and proper cleanup.</p>"},{"location":"api/utils/secure_file/#quantum_resistant_p2p.utils.secure_file-classes","title":"Classes","text":""},{"location":"api/utils/secure_file/#quantum_resistant_p2p.utils.secure_file.SecureFile","title":"<code>SecureFile(file_path)</code>","text":"<p>A secure file handler with protection against corruption and concurrent access.</p> <p>Initialize a secure file handler.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Union[str, Path]</code> <p>The path to the file</p> required Source code in <code>quantum_resistant_p2p\\utils\\secure_file.py</code> <pre><code>def __init__(self, file_path: Union[str, Path]):\n    \"\"\"Initialize a secure file handler.\n\n    Args:\n        file_path: The path to the file\n    \"\"\"\n    self.file_path = Path(file_path)\n    self.lock_path = self.file_path.with_suffix(self.file_path.suffix + '.lock')\n    self.backup_path = self.file_path.with_suffix(self.file_path.suffix + '.bak')\n</code></pre>"},{"location":"api/utils/secure_file/#quantum_resistant_p2p.utils.secure_file.SecureFile-functions","title":"Functions","text":"<code>read_json()</code> \u00b6 <p>Read and parse a JSON file safely.</p> <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>The parsed JSON data, or None if the file doesn't exist or is invalid</p> Source code in <code>quantum_resistant_p2p\\utils\\secure_file.py</code> <pre><code>def read_json(self) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Read and parse a JSON file safely.\n\n    Returns:\n        The parsed JSON data, or None if the file doesn't exist or is invalid\n    \"\"\"\n    # First try the primary file\n    data = self._read_json_file(self.file_path)\n\n    # If primary file is corrupted but backup exists, use the backup\n    if data is None and self.backup_path.exists():\n        logger.warning(f\"Using backup file for {self.file_path}\")\n        data = self._read_json_file(self.backup_path)\n\n        # If backup is valid, restore it to the main file\n        if data is not None:\n            self.write_json(data)\n\n    return data\n</code></pre> <code>write_json(data)</code> \u00b6 <p>Write data to a JSON file safely with atomic updates and backups.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>The data to write</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the write was successful, False otherwise</p> Source code in <code>quantum_resistant_p2p\\utils\\secure_file.py</code> <pre><code>def write_json(self, data: Dict[str, Any]) -&gt; bool:\n    \"\"\"Write data to a JSON file safely with atomic updates and backups.\n\n    Args:\n        data: The data to write\n\n    Returns:\n        True if the write was successful, False otherwise\n    \"\"\"\n    # Try to acquire the process lock\n    if not self._acquire_process_lock():\n        logger.error(f\"Could not acquire lock for {self.file_path}\")\n        return False\n\n    try:\n        # Create parent directory if it doesn't exist\n        self.file_path.parent.mkdir(parents=True, exist_ok=True)\n\n        # Make a backup of the existing file if it exists\n        if self.file_path.exists():\n            try:\n                shutil.copy2(self.file_path, self.backup_path)\n            except Exception as e:\n                logger.warning(f\"Failed to create backup: {e}\")\n\n        # Write to a temporary file first\n        with tempfile.NamedTemporaryFile(\n            mode='w', delete=False, dir=self.file_path.parent\n        ) as temp_file:\n            # Write the JSON data\n            json.dump(data, temp_file, indent=2)\n            temp_file.flush()\n            os.fsync(temp_file.fileno())  # Ensure data is written to disk\n            temp_path = temp_file.name\n\n        # Now atomically move the temp file to the target\n        shutil.move(temp_path, self.file_path)\n\n        return True\n    except Exception as e:\n        logger.error(f\"Error writing to {self.file_path}: {e}\")\n        return False\n    finally:\n        # Always release the process lock\n        self._release_process_lock()\n</code></pre> <code>append_bytes(data)</code> \u00b6 <p>Append binary data to a file with locking.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The binary data to append</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the append was successful, False otherwise</p> Source code in <code>quantum_resistant_p2p\\utils\\secure_file.py</code> <pre><code>def append_bytes(self, data: bytes) -&gt; bool:\n    \"\"\"Append binary data to a file with locking.\n\n    Args:\n        data: The binary data to append\n\n    Returns:\n        True if the append was successful, False otherwise\n    \"\"\"\n    try:\n        # Create parent directory if it doesn't exist\n        self.file_path.parent.mkdir(parents=True, exist_ok=True)\n\n        with open(self.file_path, 'ab') as f:\n            # Try to get an exclusive lock for writing\n            lock_acquired = _lock_file(f, exclusive=True)\n            try:\n                # Write the data\n                f.write(data)\n                f.flush()\n                return True\n            finally:\n                if lock_acquired:\n                    _unlock_file(f)\n\n        return True\n    except Exception as e:\n        logger.error(f\"Error appending to {self.file_path}: {e}\")\n        return False\n</code></pre> <code>read_bytes()</code> \u00b6 <p>Read binary data from a file with locking.</p> <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>The file contents as bytes, or None if the file doesn't exist or can't be read</p> Source code in <code>quantum_resistant_p2p\\utils\\secure_file.py</code> <pre><code>def read_bytes(self) -&gt; Optional[bytes]:\n    \"\"\"Read binary data from a file with locking.\n\n    Returns:\n        The file contents as bytes, or None if the file doesn't exist or can't be read\n    \"\"\"\n    if not self.file_path.exists():\n        return None\n\n    try:\n        with open(self.file_path, 'rb') as f:\n            # Try to get a shared lock for reading\n            lock_acquired = _lock_file(f, exclusive=False)\n            try:\n                # Read the file\n                return f.read()\n            finally:\n                if lock_acquired:\n                    _unlock_file(f)\n    except Exception as e:\n        logger.error(f\"Error reading {self.file_path}: {e}\")\n        return None\n</code></pre> <code>with_file_lock(callback, exclusive=True)</code> \u00b6 <p>Execute a callback with a file lock.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[BinaryIO], T]</code> <p>The function to call with the file handle</p> required <code>exclusive</code> <code>bool</code> <p>Whether to use exclusive (write) or shared (read) locking</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>The return value of the callback, or None if an error occurred</p> Source code in <code>quantum_resistant_p2p\\utils\\secure_file.py</code> <pre><code>def with_file_lock(self, callback: Callable[[BinaryIO], T], exclusive: bool = True) -&gt; Optional[T]:\n    \"\"\"Execute a callback with a file lock.\n\n    Args:\n        callback: The function to call with the file handle\n        exclusive: Whether to use exclusive (write) or shared (read) locking\n\n    Returns:\n        The return value of the callback, or None if an error occurred\n    \"\"\"\n    mode = 'ab' if exclusive else 'rb'\n\n    try:\n        # Create parent directory if it doesn't exist and we're writing\n        if exclusive:\n            self.file_path.parent.mkdir(parents=True, exist_ok=True)\n\n        with open(self.file_path, mode) as f:\n            # Try to get a lock\n            lock_acquired = _lock_file(f, exclusive=exclusive)\n            try:\n                # Call the callback with the file handle\n                return callback(f)\n            finally:\n                if lock_acquired:\n                    _unlock_file(f)\n    except Exception as e:\n        logger.error(f\"Error with file lock on {self.file_path}: {e}\")\n        return None\n</code></pre>"}]}